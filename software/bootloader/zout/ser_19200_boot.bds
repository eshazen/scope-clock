binary-debuggable-source
0000 0000 f ser_19200_boot.asm
0000 0000 s ;;; 
0000 0000 s ;;; Retro-25 Boostrap loader
0000 0000 s ;;; Eric Hazen - 2020
0000 0000 s ;;; 
0000 0000 s ;;; Tries for serial port load for 10s, then
0000 0000 s ;;; loads flash code (see flashtable below)
0000 0000 s ;;;
0000 0000 s ;;; ----- Serial loader ----------------------------
0000 0000 s ;;; operate at 19200 baud for 16MHz CPU clock
0000 0000 s ;;; (4800 baud for 4MHz CPU clock)
0000 0000 s ;;; 
0000 0000 s ;;; output '*'
0000 0000 s ;;; expect binary words (LSB first):
0000 0000 s ;;;    0x5791, <addr>, <count>
0000 0000 s ;;; then <count> data bytes
0000 0000 s ;;; jumps to <addr> after load
0000 0000 s ;;; if header not seen after a few bytes, start over
0000 0000 s ;;; by sending '*' again
0000 0000 s ;;;
0000 0000 s ;;; echo back all received bytes
0000 0000 s ;;;
0000 0000 s ;;; After serial timeout, copy flash images using flashtable
0000 0000 s ;;; to RAM, and jump to 'flashentry'
0000 0000 s ;;; 
0000 0000 s ;;; Mods:
0000 0000 s ;;; 21 Jan 2023, hazen - remove calc, only umon for scope clock
0000 0000 s ;;; 
0000 0000 s ;;; 17 Jun 2020, hazen - reflect RST vectors to $8000
0000 0000 s ;;; add second flash image:
0000 0000 s ;;;    UMON in EEPROM at $5000, org $8100
0000 0000 s ;;; ------------------------------------------------
0000 0000 s 
0000 0000 s ;;; expects to be stored at 0000 in flash, then
0000 0000 s ;;; relocates to 'ram' below
0000 0000 s 
0000 0000 s ;;; can be non-zero for testing
0000 0000 s rom:	equ	0
0000 0000 s 
0000 0000 s ;;; base of system RAM (RST vectors)
0000 0000 s ramb: 	equ	$8000
0000 0000 s ;;; RAM location where the boot loader relocates to
0000 0000 s ram:	equ	0f800h
0000 0000 s 	
0000 0000 s off	equ	ram-rom
0000 0000 s 
0000 0000 s 	org	rom
0000 0000 s 
0000 0000 d c33b00
0000 0000 s start:	jp	mover
0003 0003 d c30201
0003 0003 s 	jp	flashtable	;dummy jump to locate flash table	
0006 0006 s 
0006 0006 s ;	org	rom+40h		;skip past restart vectors
0006 0006 s 
0006 0006 s 	;; reflect the vectors up to bottom of RAM (normally $8000)
0008 0008 s 	org	$0008
0008 0008 d c30880
0008 0008 s 	jp	ramb+$0008
000b 000b s 
0010 0010 s 	org	$0010
0010 0010 d c31080
0010 0010 s 	jp	ramb+$0010
0013 0013 s 
0018 0018 s 	org	$0018
0018 0018 d c31880
0018 0018 s 	jp	ramb+$0018
001b 001b s 
0020 0020 s 	org	$0020
0020 0020 d c32080
0020 0020 s 	jp	ramb+$0020
0023 0023 s 
0028 0028 s 	org	$0028
0028 0028 d c32880
0028 0028 s 	jp	ramb+$0028
002b 002b s 
0030 0030 s 	org	$0030
0030 0030 d c33080
0030 0030 s 	jp	ramb+$0030
0033 0033 s 
0038 0038 s 	org	$0038
0038 0038 d c33880
0038 0038 s 	jp	ramb+$0038
003b 003b s 
003b 003b d 3100f8
003b 003b s mover:	ld	sp,ram
003e 003e s 
003e 003e s 	;; copy code to RAM
003e 003e d 210000
003e 003e s 	ld	hl,rom
0041 0041 d 1100f8
0041 0041 s 	ld	de,ram
0044 0044 d 011903
0044 0044 s 	ld	bc,last-rom+1	;size of code to move
0047 0047 d edb0
0047 0047 s 	ldir
0049 0049 s 
0049 0049 d c381fa
0049 0049 s 	jp	main+off
004c 004c s 
0100 0100 s 	org	rom+100h
0100 0100 s 
0100 0100 s ;;;
0100 0100 s ;;; table of flash images
0100 0100 s ;;; 
0100 0100 s flashentry:
0100 0100 d 0081
0100 0100 s 	dw	0x8100		;entry point (UMON)
0102 0102 s 
0102 0102 s fimgsiz: equ	8		;size of one entry in bytes
0102 0102 s 	
0102 0102 s flashtable:	
0102 0102 d feca
0102 0102 s 	dw	0xcafe		;magic number marks start of table
0104 0104 s 	
0104 0104 s ;;; second flash image (umon)
0104 0104 d 0050
0104 0104 s 	dw	0x5000		;above the first image
0106 0106 d 0081
0106 0106 s 	dw	0x8100		;RAM target address
0108 0108 d 000f
0108 0108 s 	dw	0x0f00		;size in bytes (must fit below 9000)
010a 010a d 0081
010a 010a s 	dw	0x8100		;entry point (ignored, see flashentry)
010c 010c s 
010c 010c d 0000000000000000
010c 010c s 	dw	0,0,0,0		;table ends with zeroes
0114 0114 s 
0200 0200 s 	org	rom+200h	;above flash table
0200 0200 s 	
0200 0200 s 	
0200 0200 s ;;;----------------------------------------------------
0200 0200 s ;;; all code from here on must be position-corrected
0200 0200 s ;;; (all absolute addresses must add "+off")
0200 0200 s ;;;----------------------------------------------------
0200 0200 s 
0200 0200 s ;;;
0200 0200 s ;;; 1200-baud bit-bang serial routines
0200 0200 s ;;;
0200 0200 s ;;; getc - read character, return in A
0200 0200 s ;;; putc - write character from A
0200 0200 s ;;;
0200 0200 s 	
0200 0200 s ;;; hardware ports
0200 0200 s led_port:	equ	0	;port 0 for LED/keyboard output
0200 0200 s led_bit:	equ	40H	;bit 6 for LED control
0200 0200 s 	
0200 0200 s serial_port:	equ	80H	;input port
0200 0200 s 	
0200 0200 s data_bit:	equ	80H	;input data mask
0200 0200 s 
0200 0200 s ;;; -------------------- macros --------------------
0200 0200 s ;;; 23/10 seem to be OK for 4800 baud (4MHz CPU) or 19200 (16MHz CPU)
0200 0200 s 
0200 0200 s full:	equ	23
0200 0200 s half:	equ	10
0200 0200 s 
0200 0200 s ;;; delay macro:  uses B
0200 0200 s ;;; 40 T-states/loop	
0200 0200 s delay	macro	p1
0200 0200 s 	local	dilly
0200 0200 s 	ld	b,p1
0200 0200 s 
0200 0200 s dilly:	nop
0200 0200 s 	nop
0200 0200 s 	nop
0200 0200 s 	nop
0200 0200 s 	nop
0200 0200 s 	djnz	dilly
0200 0200 s 	endm
0200 0200 s 
0200 0200 s bitdly	macro
0200 0200 s 	delay	full
0200 0200 s 	endm
0200 0200 s 
0200 0200 s halfdly macro
0200 0200 s 	delay	half
0200 0200 s 	endm
0200 0200 s 
0200 0200 s mark	macro
0200 0200 s 	ld	a,data_bit
0200 0200 s 	out	(led_port),a
0200 0200 s 	endm
0200 0200 s 
0200 0200 s spc	macro
0200 0200 s 	ld	a,0
0200 0200 s 	out	(led_port),a
0200 0200 s 	endm
0200 0200 s 
0200 0200 s ;;; ----------------------------------------
0200 0200 s 
0200 0200 s ;;; 
0200 0200 s ;;; receive a character to A
0200 0200 s ;;; 
0200 0200 s getc:	
0200 0200 d c5
0200 0200 s 	push	bc
0201 0201 d d5
0201 0201 s 	push	de
0202 0202 s 	
0202 0202 d 1e09
0202 0202 s 	ld	e,9		; bit count (start + 8 data)
0204 0204 s 	
0204 0204 s 	;; wait for high
0204 0204 d db80
0204 0204 s ci0:	in	a,(serial_port)
0206 0206 d e680
0206 0206 s 	and	data_bit
0208 0208 d 28fa
0208 0208 s 	jr	z,ci0		;loop if/while low
020a 020a s 	
020a 020a d db80
020a 020a s ci1:	in	a,(serial_port) ; read serial line
020c 020c d e680
020c 020c s 	and	data_bit	; isolate serial bit
020e 020e d 20fa
020e 020e s 	jr	nz,ci1		; loop while high
0210 0210 s 	halfdly			;delay to middle of first (start) bit
0210 0210 s 	delay	half
0210 0210 d 060a
0210 0210 s 	ld	b,half
0212 0212 s 
0212 0212 d 00
0212 0212 s ?b0001:	nop
0213 0213 d 00
0213 0213 s 	nop
0214 0214 d 00
0214 0214 s 	nop
0215 0215 d 00
0215 0215 s 	nop
0216 0216 d 00
0216 0216 s 	nop
0217 0217 d 10f9
0217 0217 s 	djnz	?b0001
0219 0219 s 	endm
0219 0219 s 	endm
0219 0219 s 
0219 0219 s ci3:
0219 0219 s 	bitdly			;delay to middle of LSB data bit
0219 0219 s 	delay	full
0219 0219 d 0617
0219 0219 s 	ld	b,full
021b 021b s 
021b 021b d 00
021b 021b s ?b0003:	nop
021c 021c d 00
021c 021c s 	nop
021d 021d d 00
021d 021d s 	nop
021e 021e d 00
021e 021e s 	nop
021f 021f d 00
021f 021f s 	nop
0220 0220 d 10f9
0220 0220 s 	djnz	?b0003
0222 0222 s 	endm
0222 0222 s 	endm
0222 0222 d db80
0222 0222 s 	in	a,(serial_port) ; read serial character
0224 0224 d e680
0224 0224 s 	and	data_bit	; isolate serial data
0226 0226 d 2801
0226 0226 s 	jr	z,ci6		; j if data is 0
0228 0228 d 3c
0228 0228 s 	inc	a		; now register A=serial data
0229 0229 d 1f
0229 0229 s ci6:	rra			; rotate it into carry
022a 022a d 1d
022a 022a s 	dec	e		; dec bit count
022b 022b d 2805
022b 022b s 	jr	z,ci5		; j if last bit
022d 022d s 	
022d 022d d 79
022d 022d s 	ld	a,c		; this is where we assemble char
022e 022e d 1f
022e 022e s 	rra			; rotate it into the character from carry
022f 022f d 4f
022f 022f s 	ld	c,a
0230 0230 s 
0230 0230 d 18e7
0230 0230 s 	jr	ci3		; do next bit
0232 0232 s 	
0232 0232 d 79
0232 0232 s ci5:	ld	a,c
0233 0233 d d1
0233 0233 s 	pop	de
0234 0234 d c1
0234 0234 s 	pop	bc
0235 0235 s 
0235 0235 d c9
0235 0235 s 	ret
0236 0236 s 
0236 0236 s ;;;
0236 0236 s ;;; send character in A
0236 0236 s ;;; saves all
0236 0236 s ;;; 
0236 0236 s 	
0236 0236 d c5
0236 0236 s putc:	push	bc
0237 0237 d d5
0237 0237 s 	push	de
0238 0238 d f5
0238 0238 s 	push	af
0239 0239 s 	
0239 0239 d 4f
0239 0239 s 	ld	c,a
023a 023a s 
023a 023a d 1e08
023a 023a s 	ld	e,8		;bit counter
023c 023c s 	
023c 023c s 	mark			;ensure a stop bit
023c 023c d 3e80
023c 023c s 	ld	a,data_bit
023e 023e d d300
023e 023e s 	out	(led_port),a
0240 0240 s 	endm
0240 0240 s 	bitdly
0240 0240 s 	delay	full
0240 0240 d 0617
0240 0240 s 	ld	b,full
0242 0242 s 
0242 0242 d 00
0242 0242 s ?b0006:	nop
0243 0243 d 00
0243 0243 s 	nop
0244 0244 d 00
0244 0244 s 	nop
0245 0245 d 00
0245 0245 s 	nop
0246 0246 d 00
0246 0246 s 	nop
0247 0247 d 10f9
0247 0247 s 	djnz	?b0006
0249 0249 s 	endm
0249 0249 s 	endm
0249 0249 s 	
0249 0249 s 	spc			;start bit
0249 0249 d 3e00
0249 0249 s 	ld	a,0
024b 024b d d300
024b 024b s 	out	(led_port),a
024d 024d s 	endm
024d 024d s 	bitdly
024d 024d s 	delay	full
024d 024d d 0617
024d 024d s 	ld	b,full
024f 024f s 
024f 024f d 00
024f 024f s ?b0009:	nop
0250 0250 d 00
0250 0250 s 	nop
0251 0251 d 00
0251 0251 s 	nop
0252 0252 d 00
0252 0252 s 	nop
0253 0253 d 00
0253 0253 s 	nop
0254 0254 d 10f9
0254 0254 s 	djnz	?b0009
0256 0256 s 	endm
0256 0256 s 	endm
0256 0256 s 	
0256 0256 s 	;; loop here for bits
0256 0256 d cb19
0256 0256 s rrot:	rr	c		;shift out LSB
0258 0258 d 3806
0258 0258 s 	jr	c,one
025a 025a s 	
025a 025a s 	spc
025a 025a d 3e00
025a 025a s 	ld	a,0
025c 025c d d300
025c 025c s 	out	(led_port),a
025e 025e s 	endm
025e 025e d 1804
025e 025e s 	jr	bite
0260 0260 s one:
0260 0260 s 	mark
0260 0260 d 3e80
0260 0260 s 	ld	a,data_bit
0262 0262 d d300
0262 0262 s 	out	(led_port),a
0264 0264 s 	endm
0264 0264 s bite:
0264 0264 s 	bitdly
0264 0264 s 	delay	full
0264 0264 d 0617
0264 0264 s 	ld	b,full
0266 0266 s 
0266 0266 d 00
0266 0266 s ?b0013:	nop
0267 0267 d 00
0267 0267 s 	nop
0268 0268 d 00
0268 0268 s 	nop
0269 0269 d 00
0269 0269 s 	nop
026a 026a d 00
026a 026a s 	nop
026b 026b d 10f9
026b 026b s 	djnz	?b0013
026d 026d s 	endm
026d 026d s 	endm
026d 026d s 	
026d 026d d 1d
026d 026d s 	dec	e
026e 026e d 20e6
026e 026e s 	jr	nz,rrot
0270 0270 s 	mark
0270 0270 d 3e80
0270 0270 s 	ld	a,data_bit
0272 0272 d d300
0272 0272 s 	out	(led_port),a
0274 0274 s 	endm
0274 0274 s 	bitdly			; stop bit
0274 0274 s 	delay	full
0274 0274 d 0617
0274 0274 s 	ld	b,full
0276 0276 s 
0276 0276 d 00
0276 0276 s ?b0016:	nop
0277 0277 d 00
0277 0277 s 	nop
0278 0278 d 00
0278 0278 s 	nop
0279 0279 d 00
0279 0279 s 	nop
027a 027a d 00
027a 027a s 	nop
027b 027b d 10f9
027b 027b s 	djnz	?b0016
027d 027d s 	endm
027d 027d s 	endm
027d 027d s 	
027d 027d d f1
027d 027d s 	pop	af
027e 027e d d1
027e 027e s 	pop	de
027f 027f d c1
027f 027f s 	pop	bc
0280 0280 d c9
0280 0280 s 	ret
0281 0281 s 	
0281 0281 s ;;; ----------------------------------------
0281 0281 s ;;; main program starts here
0281 0281 s ;;; ----------------------------------------
0281 0281 d 3e2a
0281 0281 s main:	ld	a,'*'		;output '*'
0283 0283 d cd36fa
0283 0283 s 	call	putc+off
0286 0286 s 
0286 0286 s ;;; delay here for 10s waiting for serial data, then jump to EEPROM loader
0286 0286 d 210000
0286 0286 s 	ld	hl,0
0289 0289 d 0632
0289 0289 s 	ld	b,50
028b 028b s 	
028b 028b s 	;; wait here for either a low on serial line or timeout
028b 028b d db80
028b 028b s schk:	in	a,(serial_port) ; read serial line
028d 028d d e680
028d 028d s 	and	data_bit	; isolate serial bit
028f 028f d 283b
028f 028f s 	jr	z,bload		; loop while high
0291 0291 s 
0291 0291 d 2b
0291 0291 s 	dec	hl
0292 0292 d 7c
0292 0292 s 	ld	a,h
0293 0293 d b5
0293 0293 s 	or	l
0294 0294 d 20f5
0294 0294 s 	jr	nz, schk
0296 0296 s 
0296 0296 d 10f3
0296 0296 s 	djnz	schk
0298 0298 s 
0298 0298 s ;;; EEPROM loader
0298 0298 s ;;; load all images from the flash table
0298 0298 d 2a0201
0298 0298 s 	ld	hl,(flashtable)
029b 029b d 7c
029b 029b s 	ld	a,h		;check for 0xcafe
029c 029c d feca
029c 029c s 	cp	0xca
029e 029e d 20e1
029e 029e s 	jr	nz,main
02a0 02a0 d 7d
02a0 02a0 s 	ld	a,l
02a1 02a1 d fefe
02a1 02a1 s 	cp	0xfe
02a3 02a3 d 20dc
02a3 02a3 s 	jr	nz,main
02a5 02a5 d dd210401
02a5 02a5 s 	ld	ix,flashtable+2	;first image
02a9 02a9 s flashy:	
02a9 02a9 d dd6e00
02a9 02a9 s 	ld	l,(ix)		;start address
02ac 02ac d dd6601
02ac 02ac s 	ld	h,(ix+1)
02af 02af s 	;; check for zero = end
02af 02af d 7c
02af 02af s 	ld	a,h
02b0 02b0 d b5
02b0 02b0 s 	or	l
02b1 02b1 d 2815
02b1 02b1 s 	jr	z,flash_done
02b3 02b3 d dd5e02
02b3 02b3 s 	ld	e,(ix+2)	;target address
02b6 02b6 d dd5603
02b6 02b6 s 	ld	d,(ix+3)
02b9 02b9 d dd4e04
02b9 02b9 s 	ld	c,(ix+4)	;count
02bc 02bc d dd4605
02bc 02bc s 	ld	b,(ix+5)
02bf 02bf d edb0
02bf 02bf s 	ldir			;move it
02c1 02c1 s 
02c1 02c1 d 010800
02c1 02c1 s 	ld	bc,fimgsiz
02c4 02c4 d dd09
02c4 02c4 s 	add	ix,bc
02c6 02c6 d 18e1
02c6 02c6 s 	jr	flashy
02c8 02c8 s 
02c8 02c8 s flash_done:	
02c8 02c8 d 2a0001
02c8 02c8 s 	ld	hl,(flashentry)	;start address
02cb 02cb s 
02cb 02cb d e9
02cb 02cb s 	jp	(hl)
02cc 02cc s 
02cc 02cc s ;;; got a serial character, start loader
02cc 02cc d 0605
02cc 02cc s bload:	ld	b,5		;max bad bytes
02ce 02ce s 	;; read chars until 5 received or 0x91 seen
02ce 02ce d cd00fa
02ce 02ce s bin1:	call	getc+off
02d1 02d1 d cd36fa
02d1 02d1 s 	call	putc+off
02d4 02d4 d fe91
02d4 02d4 s 	cp	0x91		;first magic byte?
02d6 02d6 d 2804
02d6 02d6 s 	jr	z,bin1a
02d8 02d8 d 10f4
02d8 02d8 s 	djnz	bin1
02da 02da d 18a5
02da 02da s 	jr	main		;bail out on error after 5 bad bytes
02dc 02dc s 	
02dc 02dc s 	;; read chars, skipping repeat 0x91, wait for 0x57
02dc 02dc d cd00fa
02dc 02dc s bin1a:	call	getc+off
02df 02df d cd36fa
02df 02df s 	call	putc+off
02e2 02e2 d fe91
02e2 02e2 s 	cp	0x91
02e4 02e4 d 28f6
02e4 02e4 s 	jr	z,bin1a
02e6 02e6 d fe57
02e6 02e6 s 	cp	0x57
02e8 02e8 d 2097
02e8 02e8 s 	jr	nz,main
02ea 02ea s 	
02ea 02ea s 	;; get address to hl
02ea 02ea d cd00fa
02ea 02ea s 	call	getc+off
02ed 02ed d cd36fa
02ed 02ed s 	call	putc+off
02f0 02f0 d 6f
02f0 02f0 s 	ld	l,a
02f1 02f1 d cd00fa
02f1 02f1 s 	call	getc+off
02f4 02f4 d cd36fa
02f4 02f4 s 	call	putc+off
02f7 02f7 d 67
02f7 02f7 s 	ld	h,a
02f8 02f8 d e5
02f8 02f8 s 	push	hl
02f9 02f9 d dde1
02f9 02f9 s 	pop	ix
02fb 02fb s 	;; get count to bc
02fb 02fb d cd00fa
02fb 02fb s 	call	getc+off
02fe 02fe d cd36fa
02fe 02fe s 	call	putc+off
0301 0301 d 4f
0301 0301 s 	ld	c,a
0302 0302 d cd00fa
0302 0302 s 	call	getc+off
0305 0305 d cd36fa
0305 0305 s 	call	putc+off
0308 0308 d 47
0308 0308 s 	ld	b,a
0309 0309 s 	;; read and store data
0309 0309 d cd00fa
0309 0309 s bin2:	call	getc+off
030c 030c d cd36fa
030c 030c s 	call	putc+off
030f 030f d 77
030f 030f s 	ld	(hl),a
0310 0310 d 23
0310 0310 s 	inc	hl
0311 0311 d 0b
0311 0311 s 	dec	bc
0312 0312 d 78
0312 0312 s 	ld	a,b
0313 0313 d b1
0313 0313 s 	or	c
0314 0314 d 20f3
0314 0314 s 	jr	nz,bin2
0316 0316 s 
0316 0316 d dde9
0316 0316 s 	jp	(ix)
0318 0318 s 
0318 0318 s last	equ	$
0318 0318 s 
0318 0318 s 	end
0204 a ci0
020a a ci1
0219 a ci3
0232 a ci5
0229 a ci6
f800 v off
f800 v ram
0260 a one
0000 v rom
0212 a ?b0001
021b a ?b0003
0266 a ?b0013
0242 a ?b0006
0276 a ?b0016
024f a ?b0009
02ce a bin1
0309 a bin2
000a v half
8000 v ramb
0200 a getc
0264 a bite
0281 a main
028b a schk
0017 v full
0318 v last
0236 a putc
0256 a rrot
02dc a bin1a
02cc a bload
003b a mover
0000 a start
02a9 a flashy
0040 v led_bit
0008 v fimgsiz
0080 v data_bit
0000 v led_port
02c8 a flash_done
0102 a flashtable
0100 a flashentry
0080 v serial_port
