   1:				;==================================================================================
   2:				; Modifications by Eric Hazen for the Retro-25 project 
   3:				;    (https://github.com/eshazen/retro-25)
   4:				; See <ESH> tags for my modifications
   5:				; Inserted my serial code at the end to keep it all in one file
   6:				;
   7:				;
   8:				;
   9:				;
  10:				; The updates to the original BASIC within this file are copyright Grant Searle
  11:				;
  12:				; You have permission to use this for NON COMMERCIAL USE ONLY
  13:				; If you wish to use it elsewhere, please include an acknowledgement to myself.
  14:				;
  15:				; http://searle.hostei.com/grant/index.html
  16:				; (now see http://searle.wales)
  17:				;
  18:				; eMail: home.micros01@btinternet.com
  19:				;
  20:				; If the above don't work, please perform an Internet search to see if I have
  21:				; updated the web page hosting service.
  22:				;
  23:				;==================================================================================
  24:				
  25:				; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  26:				; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  27:				; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  28:				; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  29:				; the original ROM code (checksum A934H). PA
  30:				
  31:				; GENERAL EQUATES
  32:				
  33:     -	0003          	CTRLC   .EQU    03H             ; Control "C"
  34:     -	0007          	CTRLG   .EQU    07H             ; Control "G"
  35:     -	0008          	BKSP    .EQU    08H             ; Back space
  36:     -	000A          	LF      .EQU    0AH             ; Line feed
  37:     -	000C          	CS      .EQU    0CH             ; Clear screen
  38:     -	000D          	CR      .EQU    0DH             ; Carriage return
  39:     -	000F          	CTRLO   .EQU    0FH             ; Control "O"
  40:     -	0011          	CTRLQ	.EQU	11H		; Control "Q"
  41:     -	0012          	CTRLR   .EQU    12H             ; Control "R"
  42:     -	0013          	CTRLS   .EQU    13H             ; Control "S"
  43:     -	0015          	CTRLU   .EQU    15H             ; Control "U"
  44:     -	001B          	ESC     .EQU    1BH             ; Escape
  45:     -	007F          	DEL     .EQU    7FH             ; Delete
  46:				
  47:				; BASIC WORK SPACE LOCATIONS
  48:				
  49:				;WRKSPC  .EQU    8045H             ; BASIC Work space
  50:     -	B045          	WRKSPC  .EQU    0B045H             ; BASIC Work space
  51:     -	B048          	USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
  52:     -	B04B          	OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
  53:     -	B04C          	OTPORT  .EQU    WRKSPC+7H           ; Port (p)
  54:     -	B04E          	DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
  55:     -	B04F          	DIV1    .EQU    WRKSPC+0AH           ; <- Values
  56:     -	B053          	DIV2    .EQU    WRKSPC+0EH           ; <-   to
  57:     -	B057          	DIV3    .EQU    WRKSPC+12H           ; <-   be
  58:     -	B05A          	DIV4    .EQU    WRKSPC+15H           ; <-inserted
  59:     -	B05C          	SEED    .EQU    WRKSPC+17H           ; Random number seed
  60:     -	B07F          	LSTRND  .EQU    WRKSPC+3AH           ; Last random number
  61:     -	B083          	INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
  62:     -	B084          	INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
  63:     -	B086          	NULLS   .EQU    WRKSPC+41H           ; Number of nulls
  64:     -	B087          	LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
  65:     -	B088          	COMMAN  .EQU    WRKSPC+43H           ; Width for commas
  66:     -	B089          	NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
  67:     -	B08A          	CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
  68:     -	B08B          	LINESC  .EQU    WRKSPC+46H           ; Lines counter
  69:     -	B08D          	LINESN  .EQU    WRKSPC+48H           ; Lines number
  70:     -	B08F          	CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
  71:     -	B091          	NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
  72:     -	B092          	BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
  73:     -	B093          	RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
  74:     -	B096          	POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
  75:     -	B099          	PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
  76:     -	B09C          	RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
  77:     -	B09F          	STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
  78:     -	B0A1          	LINEAT  .EQU    WRKSPC+5CH           ; Current line number
  79:     -	B0A3          	BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
  80:     -	B0A6          	BUFFER  .EQU    WRKSPC+61H           ; Input buffer
  81:     -	B0AB          	STACK   .EQU    WRKSPC+66H           ; Initial stack
  82:     -	B0F0          	CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
  83:     -	B0F1          	LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
  84:     -	B0F2          	TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
  85:     -	B0F3          	DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
  86:     -	B0F4          	LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
  87:     -	B0F6          	TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
  88:     -	B0F8          	TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
  89:     -	B104          	TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
  90:     -	B108          	STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
  91:     -	B10A          	CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
  92:     -	B10C          	LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
  93:     -	B10E          	DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
  94:     -	B110          	FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
  95:     -	B111          	LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
  96:     -	B112          	READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
  97:     -	B113          	BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
  98:     -	B115          	NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
  99:     -	B117          	ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
 100:     -	B119          	CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
 101:     -	B11B          	PROGND  .EQU    WRKSPC+0D6H          ; End of program
 102:     -	B11D          	VAREND  .EQU    WRKSPC+0D8H          ; End of variables
 103:     -	B11F          	ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
 104:     -	B121          	NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
 105:     -	B123          	FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
 106:     -	B125          	FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
 107:     -	B129          	FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
 108:     -	B12C          	FPEXP   .EQU    FPREG+3         ; Floating point exponent
 109:     -	B12D          	SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
 110:     -	B12E          	PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
 111:     -	B13B          	MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
 112:     -	B13E          	PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
 113:     -	B1A2          	STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
 114:				
 115:				; BASIC ERROR CODE VALUES
 116:				
 117:     -	0000          	NF      .EQU    00H             ; NEXT without FOR
 118:     -	0002          	SN      .EQU    02H             ; Syntax error
 119:     -	0004          	RG      .EQU    04H             ; RETURN without GOSUB
 120:     -	0006          	OD      .EQU    06H             ; Out of DATA
 121:     -	0008          	FC      .EQU    08H             ; Function call error
 122:     -	000A          	OV      .EQU    0AH             ; Overflow
 123:     -	000C          	OM      .EQU    0CH             ; Out of memory
 124:     -	000E          	UL      .EQU    0EH             ; Undefined line number
 125:     -	0010          	BS      .EQU    10H             ; Bad subscript
 126:     -	0012          	DD      .EQU    12H             ; Re-DIMensioned array
 127:     -	0014          	DZ      .EQU    14H             ; Division by zero (/0)
 128:     -	0016          	ID      .EQU    16H             ; Illegal direct
 129:     -	0018          	TM      .EQU    18H             ; Type miss-match
 130:     -	001A          	OS      .EQU    1AH             ; Out of string space
 131:     -	001C          	LS      .EQU    1CH             ; String too long
 132:     -	001E          	ST      .EQU    1EH             ; String formula too complex
 133:     -	0020          	CN      .EQU    20H             ; Can't CONTinue
 134:     -	0022          	UF      .EQU    22H             ; UnDEFined FN function
 135:     -	0024          	MO      .EQU    24H             ; Missing operand
 136:     -	0026          	HX      .EQU    26H             ; HEX error
 137:     -	0028          	BN      .EQU    28H             ; BIN error
 138:				
 139:				;        .ORG    8100H		; <ESH> lives in RAM
 140:     -	9100          	        .ORG    9100H		; above UMON <FIXME>
 141:				;;; NOTE: also need to change WRKSPC somewhere safe
 142:				
 143:    0+10	9100  C30691  	COLD:   JP      STARTB          ; Jump for cold start
 144:   10+10	9103  C3A491  	WARM:   JP      WARMST          ; Jump for warm start
 145:     -	9106          	STARTB: 
 146:   20+14	9106  DD210000	        LD      IX,0            ; Flag cold start
 147:   34+10	910A  C31191  	        JP      CSTART          ; Jump to initialise
 148:				
 149:     -	910D  BA99    	        .WORD   DEINT           ; Get integer -32768 to 32767
 150:     -	910F  30A1    	        .WORD   ABPASS          ; Return integer in AB
 151:				
 152:				
 153:   44+10	9111  2145B0  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
 154:   54+6	9114  F9      	        LD      SP,HL           ; Set up a temporary stack
 155:   60+10	9115  C351AD  	        JP      INITST          ; Go to initialise
 156:				
 157:   70+10	9118  11DE93  	INIT:   LD      DE,INITAB       ; Initialise workspace
 158:   80+7	911B  0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
 159:   87+10	911D  2145B0  	        LD      HL,WRKSPC       ; Into workspace RAM
 160:   97+7	9120  1A      	COPY:   LD      A,(DE)          ; Get source
 161:  104+7	9121  77      	        LD      (HL),A          ; To destination
 162:  111+6	9122  23      	        INC     HL              ; Next destination
 163:  117+6	9123  13      	        INC     DE              ; Next source
 164:  123+4	9124  05      	        DEC     B               ; Count bytes
 165:  127+10	9125  C22091  	        JP      NZ,COPY         ; More to move
 166:  137+6	9128  F9      	        LD      SP,HL           ; Temporary stack
 167:  143+17	9129  CDDF95  	        CALL    CLREG           ; Clear registers and stack
 168:  160+17	912C  CDB09B  	        CALL    PRNTCRLF        ; Output CRLF
 169:  177+13	912F  32EFB0  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 170:  190+13	9132  323EB1  	        LD      (PROGST),A      ; Initialise program area
 171:  203+10	9135  21F391  	MSIZE:  LD      HL,MEMMSG       ; Point to message
 172:  213+17	9138  CD4EA2  	        CALL    PRS             ; Output "Memory size"
 173:  230+17	913B  CDFC95  	        CALL    PROMPT          ; Get input with '?'
 174:  247+17	913E  CD0599  	        CALL    GETCHR          ; Get next character
 175:  264+4	9141  B7      	        OR      A               ; Set flags
 176:  268+10	9142  C25A91  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
 177:  278+10	9145  21A2B1  	        LD      HL,STLOOK       ; Point to start of RAM
 178:  288+6	9148  23      	MLOOP:  INC     HL              ; Next byte
 179:  294+4	9149  7C      	        LD      A,H             ; Above address FFFF ?
 180:  298+4	914A  B5      	        OR      L
 181:  302+10	914B  CA6C91  	        JP      Z,SETTOP        ; Yes - 64K RAM
 182:  312+7	914E  7E      	        LD      A,(HL)          ; Get contents
 183:  319+4	914F  47      	        LD      B,A             ; Save it
 184:  323+4	9150  2F      	        CPL                     ; Flip all bits
 185:  327+7	9151  77      	        LD      (HL),A          ; Put it back
 186:  334+7	9152  BE      	        CP      (HL)            ; RAM there if same
 187:  341+7	9153  70      	        LD      (HL),B          ; Restore old contents
 188:  348+10	9154  CA4891  	        JP      Z,MLOOP         ; If RAM - test next byte
 189:  358+10	9157  C36C91  	        JP      SETTOP          ; Top of RAM found
 190:				
 191:  368+17	915A  CDD499  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 192:  385+4	915D  B7      	        OR      A               ; Set flags on last byte
 193:  389+10	915E  C2AD94  	        JP      NZ,SNERR        ; ?SN Error if bad character
 194:  399+4	9161  EB      	        EX      DE,HL           ; Address into HL
 195:  403+6	9162  2B      	        DEC     HL              ; Back one byte
 196:  409+7	9163  3ED9    	        LD      A,11011001B     ; Test byte
 197:  416+7	9165  46      	        LD      B,(HL)          ; Get old contents
 198:  423+7	9166  77      	        LD      (HL),A          ; Load test byte
 199:  430+7	9167  BE      	        CP      (HL)            ; RAM there if same
 200:  437+7	9168  70      	        LD      (HL),B          ; Restore old contents
 201:  444+10	9169  C23591  	        JP      NZ,MSIZE        ; Ask again if no RAM
 202:				
 203:  454+6	916C  2B      	SETTOP: DEC     HL              ; Back one byte
 204:  460+10	916D  11A1B1  	        LD      DE,STLOOK-1     ; See if enough RAM
 205:  470+17	9170  CD7597  	        CALL    CPDEHL          ; Compare DE with HL
 206:  487+10	9173  DA3591  	        JP      C,MSIZE         ; Ask again if not enough RAM
 207:  497+10	9176  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 208:  507+16	9179  22F4B0  	        LD      (LSTRAM),HL     ; Save last available RAM
 209:  523+11	917C  19      	        ADD     HL,DE           ; Allocate string space
 210:  534+16	917D  229FB0  	        LD      (STRSPC),HL     ; Save string space
 211:  550+17	9180  CDBA95  	        CALL    CLRPTR          ; Clear program area
 212:  567+16	9183  2A9FB0  	        LD      HL,(STRSPC)     ; Get end of memory
 213:  583+10	9186  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 214:  593+11	9189  19      	        ADD     HL,DE           ; Adjust HL
 215:  604+10	918A  113EB1  	        LD      DE,PROGST       ; Start of program text
 216:  614+4	918D  7D      	        LD      A,L             ; Get LSB
 217:  618+4	918E  93      	        SUB     E               ; Adjust it
 218:  622+4	918F  6F      	        LD      L,A             ; Re-save
 219:  626+4	9190  7C      	        LD      A,H             ; Get MSB
 220:  630+4	9191  9A      	        SBC     A,D             ; Adjust it
 221:  634+4	9192  67      	        LD      H,A             ; Re-save
 222:  638+11	9193  E5      	        PUSH    HL              ; Save bytes free
 223:  649+10	9194  21BC91  	        LD      HL,SIGNON       ; Sign-on message
 224:  659+17	9197  CD4EA2  	        CALL    PRS             ; Output string
 225:  676+10	919A  E1      	        POP     HL              ; Get bytes free back
 226:  686+17	919B  CDF1A8  	        CALL    PRNTHL          ; Output amount of free memory
 227:  703+10	919E  21AD91  	        LD      HL,BFREE        ; " Bytes free" message
 228:  713+17	91A1  CD4EA2  	        CALL    PRS             ; Output string
 229:				
 230:  730+10	91A4  31ABB0  	WARMST: LD      SP,STACK        ; Temporary stack
 231:  740+17	91A7  CDDF95  	BRKRET: CALL    CLREG           ; Clear registers and stack
 232:  757+10	91AA  C3F894  	        JP      PRNTOK          ; Go to get command line
 233:				
 234:     -	91AD  20427974	BFREE:  .BYTE   " Bytes free",CR,LF,0,0
	              65732066
	              7265650D
	              0A0000
 235:				
 236:     -	91BC  5A383020	SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
	              42415349
	              43205665
	              7220342E
	              37620D0A
 237:     -	91D0  436F7079	        .BYTE   "Copyright ",40,"C",41
	              72696768
	              74202843
	              29
 238:     -	91DD  20313937	        .BYTE   " 1978 by Microsoft",CR,LF,0,0
	              38206279
	              204D6963
	              726F736F
	              66740D0A
	              0000
 239:				
 240:     -	91F3  4D656D6F	MEMMSG: .BYTE   "Memory top",0
	              72792074
	              6F7000
 241:				
 242:				; FUNCTION ADDRESS TABLE
 243:				
 244:     -	91FE  66A7    	FNCTAB: .WORD   SGN
 245:     -	9200  2AA8    	        .WORD   INT
 246:     -	9202  7CA7    	        .WORD   ABS
 247:     -	9204  48B0    	        .WORD   USR
 248:     -	9206  0EA1    	        .WORD   FRE
 249:     -	9208  93A4    	        .WORD   INP
 250:     -	920A  3CA1    	        .WORD   POS
 251:     -	920C  F0A9    	        .WORD   SQR
 252:     -	920E  CFAA    	        .WORD   RND
 253:     -	9210  0BA6    	        .WORD   LOG
 254:     -	9212  3EAA    	        .WORD   EXP
 255:     -	9214  44AB    	        .WORD   COS
 256:     -	9216  4AAB    	        .WORD   SIN
 257:     -	9218  ABAB    	        .WORD   TAN
 258:     -	921A  C0AB    	        .WORD   ATN
 259:     -	921C  E7A4    	        .WORD   PEEK
 260:     -	921E  2DAC    	        .WORD   DEEK
 261:     -	9220  96B0    	        .WORD   POINT
 262:     -	9222  C0A3    	        .WORD   LEN
 263:     -	9224  D8A1    	        .WORD   STR
 264:     -	9226  5AA4    	        .WORD   VAL
 265:     -	9228  CFA3    	        .WORD   ASC
 266:     -	922A  E0A3    	        .WORD   CHR
 267:     -	922C  4FAC    	        .WORD   HEX
 268:     -	922E  E2AC    	        .WORD   BIN
 269:     -	9230  F0A3    	        .WORD   LEFT
 270:     -	9232  20A4    	        .WORD   RIGHT
 271:     -	9234  2AA4    	        .WORD   MID
 272:				
 273:				; RESERVED WORD LIST
 274:				
 275:     -	9236  C54E44  	WORDS:  .BYTE   'E'+80H,"ND"
 276:     -	9239  C64F52  	        .BYTE   'F'+80H,"OR"
 277:     -	923C  CE455854	        .BYTE   'N'+80H,"EXT"
 278:     -	9240  C4415441	        .BYTE   'D'+80H,"ATA"
 279:     -	9244  C94E5055	        .BYTE   'I'+80H,"NPUT"
	              54
 280:     -	9249  C4494D  	        .BYTE   'D'+80H,"IM"
 281:     -	924C  D2454144	        .BYTE   'R'+80H,"EAD"
 282:     -	9250  CC4554  	        .BYTE   'L'+80H,"ET"
 283:     -	9253  C74F544F	        .BYTE   'G'+80H,"OTO"
 284:     -	9257  D2554E  	        .BYTE   'R'+80H,"UN"
 285:     -	925A  C946    	        .BYTE   'I'+80H,"F"
 286:     -	925C  D2455354	        .BYTE   'R'+80H,"ESTORE"
	              4F5245
 287:     -	9263  C74F5355	        .BYTE   'G'+80H,"OSUB"
	              42
 288:     -	9268  D2455455	        .BYTE   'R'+80H,"ETURN"
	              524E
 289:     -	926E  D2454D  	        .BYTE   'R'+80H,"EM"
 290:     -	9271  D3544F50	        .BYTE   'S'+80H,"TOP"
 291:     -	9275  CF5554  	        .BYTE   'O'+80H,"UT"
 292:     -	9278  CF4E    	        .BYTE   'O'+80H,"N"
 293:     -	927A  CE554C4C	        .BYTE   'N'+80H,"ULL"
 294:     -	927E  D7414954	        .BYTE   'W'+80H,"AIT"
 295:     -	9282  C44546  	        .BYTE   'D'+80H,"EF"
 296:     -	9285  D04F4B45	        .BYTE   'P'+80H,"OKE"
 297:     -	9289  C44F4B45	        .BYTE   'D'+80H,"OKE"
 298:     -	928D  D3435245	        .BYTE   'S'+80H,"CREEN"
	              454E
 299:     -	9293  CC494E45	        .BYTE   'L'+80H,"INES"
	              53
 300:     -	9298  C34C53  	        .BYTE   'C'+80H,"LS"
 301:     -	929B  D7494454	        .BYTE   'W'+80H,"IDTH"
	              48
 302:     -	92A0  CD4F4E49	        .BYTE   'M'+80H,"ONITOR"
	              544F52
 303:     -	92A7  D34554  	        .BYTE   'S'+80H,"ET"
 304:     -	92AA  D2455345	        .BYTE   'R'+80H,"ESET"
	              54
 305:     -	92AF  D052494E	        .BYTE   'P'+80H,"RINT"
	              54
 306:     -	92B4  C34F4E54	        .BYTE   'C'+80H,"ONT"
 307:     -	92B8  CC495354	        .BYTE   'L'+80H,"IST"
 308:     -	92BC  C34C4541	        .BYTE   'C'+80H,"LEAR"
	              52
 309:     -	92C1  C34C4F41	        .BYTE   'C'+80H,"LOAD"
	              44
 310:     -	92C6  C3534156	        .BYTE   'C'+80H,"SAVE"
	              45
 311:     -	92CB  CE4557  	        .BYTE   'N'+80H,"EW"
 312:				
 313:     -	92CE  D4414228	        .BYTE   'T'+80H,"AB("
 314:     -	92D2  D44F    	        .BYTE   'T'+80H,"O"
 315:     -	92D4  C64E    	        .BYTE   'F'+80H,"N"
 316:     -	92D6  D3504328	        .BYTE   'S'+80H,"PC("
 317:     -	92DA  D448454E	        .BYTE   'T'+80H,"HEN"
 318:     -	92DE  CE4F54  	        .BYTE   'N'+80H,"OT"
 319:     -	92E1  D3544550	        .BYTE   'S'+80H,"TEP"
 320:				
 321:     -	92E5  AB      	        .BYTE   '+'+80H
 322:     -	92E6  AD      	        .BYTE   '-'+80H
 323:     -	92E7  AA      	        .BYTE   '*'+80H
 324:     -	92E8  AF      	        .BYTE   '/'+80H
 325:     -	92E9  DE      	        .BYTE   '^'+80H
 326:     -	92EA  C14E44  	        .BYTE   'A'+80H,"ND"
 327:     -	92ED  CF52    	        .BYTE   'O'+80H,"R"
 328:     -	92EF  BE      	        .BYTE   '>'+80H
 329:     -	92F0  BD      	        .BYTE   '='+80H
 330:     -	92F1  BC      	        .BYTE   '<'+80H
 331:				
 332:     -	92F2  D3474E  	        .BYTE   'S'+80H,"GN"
 333:     -	92F5  C94E54  	        .BYTE   'I'+80H,"NT"
 334:     -	92F8  C14253  	        .BYTE   'A'+80H,"BS"
 335:     -	92FB  D55352  	        .BYTE   'U'+80H,"SR"
 336:     -	92FE  C65245  	        .BYTE   'F'+80H,"RE"
 337:     -	9301  C94E50  	        .BYTE   'I'+80H,"NP"
 338:     -	9304  D04F53  	        .BYTE   'P'+80H,"OS"
 339:     -	9307  D35152  	        .BYTE   'S'+80H,"QR"
 340:     -	930A  D24E44  	        .BYTE   'R'+80H,"ND"
 341:     -	930D  CC4F47  	        .BYTE   'L'+80H,"OG"
 342:     -	9310  C55850  	        .BYTE   'E'+80H,"XP"
 343:     -	9313  C34F53  	        .BYTE   'C'+80H,"OS"
 344:     -	9316  D3494E  	        .BYTE   'S'+80H,"IN"
 345:     -	9319  D4414E  	        .BYTE   'T'+80H,"AN"
 346:     -	931C  C1544E  	        .BYTE   'A'+80H,"TN"
 347:     -	931F  D045454B	        .BYTE   'P'+80H,"EEK"
 348:     -	9323  C445454B	        .BYTE   'D'+80H,"EEK"
 349:     -	9327  D04F494E	        .BYTE   'P'+80H,"OINT"
	              54
 350:     -	932C  CC454E  	        .BYTE   'L'+80H,"EN"
 351:     -	932F  D3545224	        .BYTE   'S'+80H,"TR$"
 352:     -	9333  D6414C  	        .BYTE   'V'+80H,"AL"
 353:     -	9336  C15343  	        .BYTE   'A'+80H,"SC"
 354:     -	9339  C3485224	        .BYTE   'C'+80H,"HR$"
 355:     -	933D  C8455824	        .BYTE   'H'+80H,"EX$"
 356:     -	9341  C2494E24	        .BYTE   'B'+80H,"IN$"
 357:     -	9345  CC454654	        .BYTE   'L'+80H,"EFT$"
	              24
 358:     -	934A  D2494748	        .BYTE   'R'+80H,"IGHT$"
	              5424
 359:     -	9350  CD494424	        .BYTE   'M'+80H,"ID$"
 360:     -	9354  80      	        .BYTE   80H             ; End of list marker
 361:				
 362:				; KEYWORD ADDRESS TABLE
 363:				
 364:     -	9355  5299    	WORDTB: .WORD   PEND
 365:     -	9357  4C98    	        .WORD   FOR
 366:     -	9359  2A9D    	        .WORD   NEXT
 367:     -	935B  9F9A    	        .WORD   DATA
 368:     -	935D  319C    	        .WORD   INPUT
 369:     -	935F  669F    	        .WORD   DIM
 370:     -	9361  609C    	        .WORD   READ
 371:     -	9363  B69A    	        .WORD   LET
 372:     -	9365  5C9A    	        .WORD   GOTO
 373:     -	9367  3F9A    	        .WORD   RUN
 374:     -	9369  2E9B    	        .WORD   IF
 375:     -	936B  1599    	        .WORD   RESTOR
 376:     -	936D  4B9A    	        .WORD   GOSUB
 377:     -	936F  7A9A    	        .WORD   RETURN
 378:     -	9371  A19A    	        .WORD   REM
 379:     -	9373  5099    	        .WORD   STOP
 380:     -	9375  9FA4    	        .WORD   POUT
 381:     -	9377  109B    	        .WORD   ON
 382:     -	9379  9199    	        .WORD   NULL
 383:     -	937B  A5A4    	        .WORD   WAIT
 384:     -	937D  44A1    	        .WORD   DEF
 385:     -	937F  EEA4    	        .WORD   POKE
 386:     -	9381  38AC    	        .WORD   DOKE
 387:     -	9383  A19A    	        .WORD   REM
 388:     -	9385  1EAC    	        .WORD   LINES
 389:     -	9387  11AC    	        .WORD   CLS
 390:     -	9389  16AC    	        .WORD   WIDTH
 391:     -	938B  4EAD    	        .WORD   MONITR
 392:     -	938D  99B0    	        .WORD   PSET
 393:     -	938F  9CB0    	        .WORD   RESET
 394:     -	9391  529B    	        .WORD   PRINT
 395:     -	9393  7E99    	        .WORD   CONT
 396:     -	9395  C197    	        .WORD   LIST
 397:     -	9397  F999    	        .WORD   CLEAR
 398:     -	9399  A19A    	        .WORD   REM
 399:     -	939B  A19A    	        .WORD   REM
 400:     -	939D  B995    	        .WORD   NEW
 401:				
 402:				; RESERVED WORD TOKEN VALUES
 403:				
 404:     -	0080          	ZEND    .EQU    080H            ; END
 405:     -	0081          	ZFOR    .EQU    081H            ; FOR
 406:     -	0083          	ZDATA   .EQU    083H            ; DATA
 407:     -	0088          	ZGOTO   .EQU    088H            ; GOTO
 408:     -	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 409:     -	008E          	ZREM    .EQU    08EH            ; REM
 410:     -	009E          	ZPRINT  .EQU    09EH            ; PRINT
 411:     -	00A4          	ZNEW    .EQU    0A4H            ; NEW
 412:				
 413:     -	00A5          	ZTAB    .EQU    0A5H            ; TAB
 414:     -	00A6          	ZTO     .EQU    0A6H            ; TO
 415:     -	00A7          	ZFN     .EQU    0A7H            ; FN
 416:     -	00A8          	ZSPC    .EQU    0A8H            ; SPC
 417:     -	00A9          	ZTHEN   .EQU    0A9H            ; THEN
 418:     -	00AA          	ZNOT    .EQU    0AAH            ; NOT
 419:     -	00AB          	ZSTEP   .EQU    0ABH            ; STEP
 420:				
 421:     -	00AC          	ZPLUS   .EQU    0ACH            ; +
 422:     -	00AD          	ZMINUS  .EQU    0ADH            ; -
 423:     -	00AE          	ZTIMES  .EQU    0AEH            ; *
 424:     -	00AF          	ZDIV    .EQU    0AFH            ; /
 425:     -	00B2          	ZOR     .EQU    0B2H            ; OR
 426:     -	00B3          	ZGTR    .EQU    0B3H            ; >
 427:     -	00B4          	ZEQUAL  .EQU    0B4H            ; M
 428:     -	00B5          	ZLTH    .EQU    0B5H            ; <
 429:     -	00B6          	ZSGN    .EQU    0B6H            ; SGN
 430:     -	00C7          	ZPOINT  .EQU    0C7H            ; POINT
 431:     -	00CF          	ZLEFT   .EQU    0CDH +2         ; LEFT$
 432:				
 433:				; ARITHMETIC PRECEDENCE TABLE
 434:				
 435:     -	939F  79      	PRITAB: .BYTE   79H             ; Precedence value
 436:     -	93A0  D8A8    	        .WORD   PADD            ; FPREG = <last> + FPREG
 437:				
 438:     -	93A2  79      	        .BYTE   79H             ; Precedence value
 439:     -	93A3  0CA5    	        .WORD   PSUB            ; FPREG = <last> - FPREG
 440:				
 441:     -	93A5  7C      	        .BYTE   7CH             ; Precedence value
 442:     -	93A6  4AA6    	        .WORD   MULT            ; PPREG = <last> * FPREG
 443:				
 444:     -	93A8  7C      	        .BYTE   7CH             ; Precedence value
 445:     -	93A9  ABA6    	        .WORD   DIV             ; FPREG = <last> / FPREG
 446:				
 447:     -	93AB  7F      	        .BYTE   7FH             ; Precedence value
 448:     -	93AC  F9A9    	        .WORD   POWER           ; FPREG = <last> ^ FPREG
 449:				
 450:     -	93AE  50      	        .BYTE   50H             ; Precedence value
 451:     -	93AF  BF9E    	        .WORD   PAND            ; FPREG = <last> AND FPREG
 452:				
 453:     -	93B1  46      	        .BYTE   46H             ; Precedence value
 454:     -	93B2  BE9E    	        .WORD   POR             ; FPREG = <last> OR FPREG
 455:				
 456:				; BASIC ERROR CODE LIST
 457:				
 458:     -	93B4  4E46    	ERRORS: .BYTE   "NF"            ; NEXT without FOR
 459:     -	93B6  534E    	        .BYTE   "SN"            ; Syntax error
 460:     -	93B8  5247    	        .BYTE   "RG"            ; RETURN without GOSUB
 461:     -	93BA  4F44    	        .BYTE   "OD"            ; Out of DATA
 462:     -	93BC  4643    	        .BYTE   "FC"            ; Illegal function call
 463:     -	93BE  4F56    	        .BYTE   "OV"            ; Overflow error
 464:     -	93C0  4F4D    	        .BYTE   "OM"            ; Out of memory
 465:     -	93C2  554C    	        .BYTE   "UL"            ; Undefined line
 466:     -	93C4  4253    	        .BYTE   "BS"            ; Bad subscript
 467:     -	93C6  4444    	        .BYTE   "DD"            ; Re-DIMensioned array
 468:     -	93C8  2F30    	        .BYTE   "/0"            ; Division by zero
 469:     -	93CA  4944    	        .BYTE   "ID"            ; Illegal direct
 470:     -	93CC  544D    	        .BYTE   "TM"            ; Type mis-match
 471:     -	93CE  4F53    	        .BYTE   "OS"            ; Out of string space
 472:     -	93D0  4C53    	        .BYTE   "LS"            ; String too long
 473:     -	93D2  5354    	        .BYTE   "ST"            ; String formula too complex
 474:     -	93D4  434E    	        .BYTE   "CN"            ; Can't CONTinue
 475:     -	93D6  5546    	        .BYTE   "UF"            ; Undefined FN function
 476:     -	93D8  4D4F    	        .BYTE   "MO"            ; Missing operand
 477:     -	93DA  4858    	        .BYTE   "HX"            ; HEX error
 478:     -	93DC  424E    	        .BYTE   "BN"            ; BIN error
 479:				
 480:				; INITIALISATION TABLE -------------------------------------------------------
 481:				
 482:  767+10	93DE  C3A491  	INITAB: JP      WARMST          ; Warm start jump
 483:  777+10	93E1  C3CF99  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
 484:  787+11	93E4  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 485:  798+10	93E6  C9      	        RET
 486:  808+7	93E7  D600    	        SUB     0               ; Division support routine
 487:  815+4	93E9  6F      	        LD      L,A
 488:  819+4	93EA  7C      	        LD      A,H
 489:  823+7	93EB  DE00    	        SBC     A,0
 490:  830+4	93ED  67      	        LD      H,A
 491:  834+4	93EE  78      	        LD      A,B
 492:  838+7	93EF  DE00    	        SBC     A,0
 493:  845+4	93F1  47      	        LD      B,A
 494:  849+7	93F2  3E00    	        LD      A,0
 495:  856+10	93F4  C9      	        RET
 496:     -	93F5  000000  	        .BYTE   0,0,0                   ; Random number seed table used by RND
 497:     -	93F8  354ACA99	        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
 498:     -	93FC  391C7698	        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
 499:     -	9400  2295B398	        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
 500:     -	9404  0ADD4798	        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
 501:     -	9408  53D19999	        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
 502:     -	940C  0A1A9F98	        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
 503:     -	9410  65BCCD98	        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
 504:     -	9414  D6773E98	        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
 505:     -	9418  52C74F80	        .BYTE   052H,0C7H,04FH,080H     ; Last random number
 506:  866+11	941C  DB00    	        IN      A,(0)           ; INP (x) skeleton
 507:  877+10	941E  C9      	        RET
 508:     -	941F  01      	        .BYTE   1               ; POS (x) number (1)
 509:     -	9420  FF      	        .BYTE   255             ; Terminal width (255 = no auto CRLF)
 510:     -	9421  1C      	        .BYTE   28              ; Width for commas (3 columns)
 511:     -	9422  00      	        .BYTE   0               ; No nulls after input bytes
 512:     -	9423  00      	        .BYTE   0               ; Output enabled (^O off)
 513:     -	9424  1400    	        .WORD   20              ; Initial lines counter
 514:     -	9426  1400    	        .WORD   20              ; Initial lines number
 515:     -	9428  0000    	        .WORD   0               ; Array load/save check sum
 516:     -	942A  00      	        .BYTE   0               ; Break not by NMI
 517:     -	942B  00      	        .BYTE   0               ; Break flag
 518:  887+10	942C  C3F296  	        JP      TTYLIN          ; Input reflection (set to TTY)
 519:  897+10	942F  C30000  	        JP      $0000           ; POINT reflection unused
 520:  907+10	9432  C30000  	        JP      $0000           ; SET reflection
 521:  917+10	9435  C30000  	        JP      $0000          	; RESET reflection
 522:     -	9438  A2B1    	        .WORD   STLOOK          ; Temp string space
 523:     -	943A  FEFF    	        .WORD   -2              ; Current line number (cold)
 524:     -	943C  3FB1    	        .WORD   PROGST+1        ; Start of program text
 525:     -	943E          	INITBE:                         
 526:				
 527:				; END OF INITIALISATION TABLE ---------------------------------------------------
 528:				
 529:     -	943E  20457272	ERRMSG: .BYTE   " Error",0
	              6F7200
 530:     -	9445  20696E20	INMSG:  .BYTE   " in ",0
	              00
 531:     -	9449          	ZERBYT  .EQU    $-1             ; A zero byte
 532:     -	944A  4F6B0D0A	OKMSG:  .BYTE   "Ok",CR,LF,0,0
	              0000
 533:     -	9450  42726561	BRKMSG: .BYTE   "Break",0
	              6B00
 534:				
 535:  927+10	9456  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 536:  937+11	9459  39      	        ADD     HL,SP           ; same index as specified
 537:  948+7	945A  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 538:  955+6	945B  23      	        INC     HL              ; Point to index address
 539:  961+7	945C  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 540:  968+5+6	945E  C0      	        RET     NZ              ; No - exit
 541:  973+7	945F  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 542:  980+6	9460  23      	        INC     HL
 543:  986+7	9461  46      	        LD      B,(HL)
 544:  993+6	9462  23      	        INC     HL              ; Point to sign of STEP
 545:  999+11	9463  E5      	        PUSH    HL              ; Save pointer to sign
 546: 1010+4	9464  69      	        LD      L,C             ; HL = address of "FOR" index
 547: 1014+4	9465  60      	        LD      H,B
 548: 1018+4	9466  7A      	        LD      A,D             ; See if an index was specified
 549: 1022+4	9467  B3      	        OR      E               ; DE = 0 if no index specified
 550: 1026+4	9468  EB      	        EX      DE,HL           ; Specified index into HL
 551: 1030+10	9469  CA7094  	        JP      Z,INDFND        ; Skip if no index given
 552: 1040+4	946C  EB      	        EX      DE,HL           ; Index back into DE
 553: 1044+17	946D  CD7597  	        CALL    CPDEHL          ; Compare index with one given
 554: 1061+10	9470  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 555: 1071+10	9473  E1      	        POP     HL              ; Restore pointer to sign
 556: 1081+5+6	9474  C8      	        RET     Z               ; Return if block found
 557: 1086+11	9475  09      	        ADD     HL,BC           ; Point to next block
 558: 1097+10	9476  C35A94  	        JP      LOKFOR          ; Keep on looking
 559:				
 560: 1107+17	9479  CD9394  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 561: 1124+11	947C  C5      	MOVSTR: PUSH    BC              ; Save end of source
 562: 1135+19	947D  E3      	        EX      (SP),HL         ; Swap source and dest" end
 563: 1154+10	947E  C1      	        POP     BC              ; Get end of destination
 564: 1164+17	947F  CD7597  	MOVLP:  CALL    CPDEHL          ; See if list moved
 565: 1181+7	9482  7E      	        LD      A,(HL)          ; Get byte
 566: 1188+7	9483  02      	        LD      (BC),A          ; Move it
 567: 1195+5+6	9484  C8      	        RET     Z               ; Exit if all done
 568: 1200+6	9485  0B      	        DEC     BC              ; Next byte to move to
 569: 1206+6	9486  2B      	        DEC     HL              ; Next byte to move
 570: 1212+10	9487  C37F94  	        JP      MOVLP           ; Loop until all bytes moved
 571:				
 572: 1222+11	948A  E5      	CHKSTK: PUSH    HL              ; Save code string address
 573: 1233+16	948B  2A1FB1  	        LD      HL,(ARREND)     ; Lowest free memory
 574: 1249+7	948E  0600    	        LD      B,0             ; BC = Number of levels to test
 575: 1256+11	9490  09      	        ADD     HL,BC           ; 2 Bytes for each level
 576: 1267+11	9491  09      	        ADD     HL,BC
 577:     -	9492  3E      	        .BYTE   3EH             ; Skip "PUSH HL"
 578: 1278+11	9493  E5      	ENFMEM: PUSH    HL              ; Save code string address
 579: 1289+7	9494  3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 580: 1296+4	9496  95      	        SUB     L
 581: 1300+4	9497  6F      	        LD      L,A
 582: 1304+7	9498  3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 583: 1311+4	949A  9C      	        SBC     A,H
 584: 1315+10	949B  DAA294  	        JP      C,OMERR         ; Not enough - ?OM Error
 585: 1325+4	949E  67      	        LD      H,A
 586: 1329+11	949F  39      	        ADD     HL,SP           ; Test if stack is overflowed
 587: 1340+10	94A0  E1      	        POP     HL              ; Restore code string address
 588: 1350+5+6	94A1  D8      	        RET     C               ; Return if enough mmory
 589: 1355+7	94A2  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 590: 1362+10	94A4  C3C194  	        JP      ERROR
 591:				
 592: 1372+16	94A7  2A0EB1  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 593: 1388+16	94AA  22A1B0  	        LD      (LINEAT),HL     ; Save as current line
 594: 1404+7	94AD  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 595:     -	94AF  01      	        .BYTE   01H             ; Skip "LD E,DZ"
 596: 1411+7	94B0  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 597:     -	94B2  01      	        .BYTE   01H             ; Skip "LD E,NF"
 598: 1418+7	94B3  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 599:     -	94B5  01      	        .BYTE   01H             ; Skip "LD E,DD"
 600: 1425+7	94B6  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 601:     -	94B8  01      	        .BYTE   01H             ; Skip "LD E,UF"
 602: 1432+7	94B9  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 603:     -	94BB  01      	        .BYTE   01H             ; Skip "LD E,OV
 604: 1439+7	94BC  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 605:     -	94BE  01      	        .BYTE   01H             ; Skip "LD E,TM"
 606: 1446+7	94BF  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 607:				
 608: 1453+17	94C1  CDDF95  	ERROR:  CALL    CLREG           ; Clear registers and stack
 609: 1470+13	94C4  328AB0  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 610: 1483+17	94C7  CDA39B  	        CALL    STTLIN          ; Start new line
 611: 1500+10	94CA  21B493  	        LD      HL,ERRORS       ; Point to error codes
 612: 1510+4	94CD  57      	        LD      D,A             ; D = 0 (A is 0)
 613: 1514+7	94CE  3E3F    	        LD      A,'?'
 614: 1521+17	94D0  CD8697  	        CALL    OUTC            ; Output '?'
 615: 1538+11	94D3  19      	        ADD     HL,DE           ; Offset to correct error code
 616: 1549+7	94D4  7E      	        LD      A,(HL)          ; First character
 617: 1556+17	94D5  CD8697  	        CALL    OUTC            ; Output it
 618: 1573+17	94D8  CD0599  	        CALL    GETCHR          ; Get next character
 619: 1590+17	94DB  CD8697  	        CALL    OUTC            ; Output it
 620: 1607+10	94DE  213E94  	        LD      HL,ERRMSG       ; "Error" message
 621: 1617+17	94E1  CD4EA2  	ERRIN:  CALL    PRS             ; Output message
 622: 1634+16	94E4  2AA1B0  	        LD      HL,(LINEAT)     ; Get line of error
 623: 1650+10	94E7  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 624: 1660+17	94EA  CD7597  	        CALL    CPDEHL          ; See if cold start error
 625: 1677+10	94ED  CA1191  	        JP      Z,CSTART        ; Cold start error - Restart
 626: 1687+4	94F0  7C      	        LD      A,H             ; Was it a direct error?
 627: 1691+4	94F1  A5      	        AND     L               ; Line = -1 if direct error
 628: 1695+4	94F2  3C      	        INC     A
 629: 1699+10+7	94F3  C4E9A8  	        CALL    NZ,LINEIN       ; No - output line of error
 630:     -	94F6  3E      	        .BYTE   3EH             ; Skip "POP BC"
 631: 1709+10	94F7  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 632:				
 633: 1719+4	94F8  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 634: 1723+13	94F9  328AB0  	        LD      (CTLOFG),A      ; Enable output
 635: 1736+17	94FC  CDA39B  	        CALL    STTLIN          ; Start new line
 636: 1753+10	94FF  214A94  	        LD      HL,OKMSG        ; "Ok" message
 637: 1763+17	9502  CD4EA2  	        CALL    PRS             ; Output "Ok"
 638: 1780+10	9505  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 639: 1790+16	9508  22A1B0  	        LD      (LINEAT),HL     ; Save as current line
 640: 1806+17	950B  CDF296  	        CALL    GETLIN          ; Get an input line
 641: 1823+10	950E  DA0595  	        JP      C,GETCMD        ; Get line again if break
 642: 1833+17	9511  CD0599  	        CALL    GETCHR          ; Get first character
 643: 1850+4	9514  3C      	        INC     A               ; Test if end of line
 644: 1854+4	9515  3D      	        DEC     A               ; Without affecting Carry
 645: 1858+10	9516  CA0595  	        JP      Z,GETCMD        ; Nothing entered - Get another
 646: 1868+11	9519  F5      	        PUSH    AF              ; Save Carry status
 647: 1879+17	951A  CDD499  	        CALL    ATOH            ; Get line number into DE
 648: 1896+11	951D  D5      	        PUSH    DE              ; Save line number
 649: 1907+17	951E  CD0996  	        CALL    CRUNCH          ; Tokenise rest of line
 650: 1924+4	9521  47      	        LD      B,A             ; Length of tokenised line
 651: 1928+10	9522  D1      	        POP     DE              ; Restore line number
 652: 1938+10	9523  F1      	        POP     AF              ; Restore Carry
 653: 1948+10	9524  D2E598  	        JP      NC,EXCUTE       ; No line number - Direct mode
 654: 1958+11	9527  D5      	        PUSH    DE              ; Save line number
 655: 1969+11	9528  C5      	        PUSH    BC              ; Save length of tokenised line
 656: 1980+4	9529  AF      	        XOR     A
 657: 1984+13	952A  3211B1  	        LD      (LSTBIN),A      ; Clear last byte input
 658: 1997+17	952D  CD0599  	        CALL    GETCHR          ; Get next character
 659: 2014+4	9530  B7      	        OR      A               ; Set flags
 660: 2018+11	9531  F5      	        PUSH    AF              ; And save them
 661: 2029+17	9532  CD9995  	        CALL    SRCHLN          ; Search for line number in DE
 662: 2046+10	9535  DA3E95  	        JP      C,LINFND        ; Jump if line found
 663: 2056+10	9538  F1      	        POP     AF              ; Get status
 664: 2066+11	9539  F5      	        PUSH    AF              ; And re-save
 665: 2077+10	953A  CA759A  	        JP      Z,ULERR         ; Nothing after number - Error
 666: 2087+4	953D  B7      	        OR      A               ; Clear Carry
 667: 2091+11	953E  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 668: 2102+10	953F  D25595  	        JP      NC,INEWLN       ; Line not found - Insert new
 669: 2112+4	9542  EB      	        EX      DE,HL           ; Next line address in DE
 670: 2116+16	9543  2A1BB1  	        LD      HL,(PROGND)     ; End of program
 671: 2132+7	9546  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 672: 2139+7	9547  02      	        LD      (BC),A
 673: 2146+6	9548  03      	        INC     BC              ; Next destination
 674: 2152+6	9549  13      	        INC     DE              ; Next source
 675: 2158+17	954A  CD7597  	        CALL    CPDEHL          ; All done?
 676: 2175+10	954D  C24695  	        JP      NZ,SFTPRG       ; More to do
 677: 2185+4	9550  60      	        LD      H,B             ; HL - New end of program
 678: 2189+4	9551  69      	        LD      L,C
 679: 2193+16	9552  221BB1  	        LD      (PROGND),HL     ; Update end of program
 680:				
 681: 2209+10	9555  D1      	INEWLN: POP     DE              ; Get address of line,
 682: 2219+10	9556  F1      	        POP     AF              ; Get status
 683: 2229+10	9557  CA7C95  	        JP      Z,SETPTR        ; No text - Set up pointers
 684: 2239+16	955A  2A1BB1  	        LD      HL,(PROGND)     ; Get end of program
 685: 2255+19	955D  E3      	        EX      (SP),HL         ; Get length of input line
 686: 2274+10	955E  C1      	        POP     BC              ; End of program to BC
 687: 2284+11	955F  09      	        ADD     HL,BC           ; Find new end
 688: 2295+11	9560  E5      	        PUSH    HL              ; Save new end
 689: 2306+17	9561  CD7994  	        CALL    MOVUP           ; Make space for line
 690: 2323+10	9564  E1      	        POP     HL              ; Restore new end
 691: 2333+16	9565  221BB1  	        LD      (PROGND),HL     ; Update end of program pointer
 692: 2349+4	9568  EB      	        EX      DE,HL           ; Get line to move up in HL
 693: 2353+7	9569  74      	        LD      (HL),H          ; Save MSB
 694: 2360+10	956A  D1      	        POP     DE              ; Get new line number
 695: 2370+6	956B  23      	        INC     HL              ; Skip pointer
 696: 2376+6	956C  23      	        INC     HL
 697: 2382+7	956D  73      	        LD      (HL),E          ; Save LSB of line number
 698: 2389+6	956E  23      	        INC     HL
 699: 2395+7	956F  72      	        LD      (HL),D          ; Save MSB of line number
 700: 2402+6	9570  23      	        INC     HL              ; To first byte in line
 701: 2408+10	9571  11A6B0  	        LD      DE,BUFFER       ; Copy buffer to program
 702: 2418+7	9574  1A      	MOVBUF: LD      A,(DE)          ; Get source
 703: 2425+7	9575  77      	        LD      (HL),A          ; Save destinations
 704: 2432+6	9576  23      	        INC     HL              ; Next source
 705: 2438+6	9577  13      	        INC     DE              ; Next destination
 706: 2444+4	9578  B7      	        OR      A               ; Done?
 707: 2448+10	9579  C27495  	        JP      NZ,MOVBUF       ; No - Repeat
 708: 2458+17	957C  CDC595  	SETPTR: CALL    RUNFST          ; Set line pointers
 709: 2475+6	957F  23      	        INC     HL              ; To LSB of pointer
 710: 2481+4	9580  EB      	        EX      DE,HL           ; Address to DE
 711: 2485+4	9581  62      	PTRLP:  LD      H,D             ; Address to HL
 712: 2489+4	9582  6B      	        LD      L,E
 713: 2493+7	9583  7E      	        LD      A,(HL)          ; Get LSB of pointer
 714: 2500+6	9584  23      	        INC     HL              ; To MSB of pointer
 715: 2506+7	9585  B6      	        OR      (HL)            ; Compare with MSB pointer
 716: 2513+10	9586  CA0595  	        JP      Z,GETCMD        ; Get command line if end
 717: 2523+6	9589  23      	        INC     HL              ; To LSB of line number
 718: 2529+6	958A  23      	        INC     HL              ; Skip line number
 719: 2535+6	958B  23      	        INC     HL              ; Point to first byte in line
 720: 2541+4	958C  AF      	        XOR     A               ; Looking for 00 byte
 721: 2545+7	958D  BE      	FNDEND: CP      (HL)            ; Found end of line?
 722: 2552+6	958E  23      	        INC     HL              ; Move to next byte
 723: 2558+10	958F  C28D95  	        JP      NZ,FNDEND       ; No - Keep looking
 724: 2568+4	9592  EB      	        EX      DE,HL           ; Next line address to HL
 725: 2572+7	9593  73      	        LD      (HL),E          ; Save LSB of pointer
 726: 2579+6	9594  23      	        INC     HL
 727: 2585+7	9595  72      	        LD      (HL),D          ; Save MSB of pointer
 728: 2592+10	9596  C38195  	        JP      PTRLP           ; Do next line
 729:				
 730: 2602+16	9599  2AA3B0  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 731: 2618+4	959C  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 732: 2622+4	959D  4D      	        LD      C,L
 733: 2626+7	959E  7E      	        LD      A,(HL)          ; Get address of next line
 734: 2633+6	959F  23      	        INC     HL
 735: 2639+7	95A0  B6      	        OR      (HL)            ; End of program found?
 736: 2646+6	95A1  2B      	        DEC     HL
 737: 2652+5+6	95A2  C8      	        RET     Z               ; Yes - Line not found
 738: 2657+6	95A3  23      	        INC     HL
 739: 2663+6	95A4  23      	        INC     HL
 740: 2669+7	95A5  7E      	        LD      A,(HL)          ; Get LSB of line number
 741: 2676+6	95A6  23      	        INC     HL
 742: 2682+7	95A7  66      	        LD      H,(HL)          ; Get MSB of line number
 743: 2689+4	95A8  6F      	        LD      L,A
 744: 2693+17	95A9  CD7597  	        CALL    CPDEHL          ; Compare with line in DE
 745: 2710+4	95AC  60      	        LD      H,B             ; HL = Start of this line
 746: 2714+4	95AD  69      	        LD      L,C
 747: 2718+7	95AE  7E      	        LD      A,(HL)          ; Get LSB of next line address
 748: 2725+6	95AF  23      	        INC     HL
 749: 2731+7	95B0  66      	        LD      H,(HL)          ; Get MSB of next line address
 750: 2738+4	95B1  6F      	        LD      L,A             ; Next line to HL
 751: 2742+4	95B2  3F      	        CCF
 752: 2746+5+6	95B3  C8      	        RET     Z               ; Lines found - Exit
 753: 2751+4	95B4  3F      	        CCF
 754: 2755+5+6	95B5  D0      	        RET     NC              ; Line not found,at line after
 755: 2760+10	95B6  C39C95  	        JP      SRCHLP          ; Keep looking
 756:				
 757: 2770+5+6	95B9  C0      	NEW:    RET     NZ              ; Return if any more on line
 758: 2775+16	95BA  2AA3B0  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 759: 2791+4	95BD  AF      	        XOR     A               ; Set program area to empty
 760: 2795+7	95BE  77      	        LD      (HL),A          ; Save LSB = 00
 761: 2802+6	95BF  23      	        INC     HL
 762: 2808+7	95C0  77      	        LD      (HL),A          ; Save MSB = 00
 763: 2815+6	95C1  23      	        INC     HL
 764: 2821+16	95C2  221BB1  	        LD      (PROGND),HL     ; Set program end
 765:				
 766: 2837+16	95C5  2AA3B0  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 767: 2853+6	95C8  2B      	        DEC     HL
 768:				
 769: 2859+16	95C9  2213B1  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 770: 2875+16	95CC  2AF4B0  	        LD      HL,(LSTRAM)     ; Get end of RAM
 771: 2891+16	95CF  2208B1  	        LD      (STRBOT),HL     ; Clear string space
 772: 2907+4	95D2  AF      	        XOR     A
 773: 2911+17	95D3  CD1599  	        CALL    RESTOR          ; Reset DATA pointers
 774: 2928+16	95D6  2A1BB1  	        LD      HL,(PROGND)     ; Get end of program
 775: 2944+16	95D9  221DB1  	        LD      (VAREND),HL     ; Clear variables
 776: 2960+16	95DC  221FB1  	        LD      (ARREND),HL     ; Clear arrays
 777:				
 778: 2976+10	95DF  C1      	CLREG:  POP     BC              ; Save return address
 779: 2986+16	95E0  2A9FB0  	        LD      HL,(STRSPC)     ; Get end of working RAN
 780: 3002+6	95E3  F9      	        LD      SP,HL           ; Set stack
 781: 3008+10	95E4  21F8B0  	        LD      HL,TMSTPL       ; Temporary string pool
 782: 3018+16	95E7  22F6B0  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 783: 3034+4	95EA  AF      	        XOR     A               ; A = 00
 784: 3038+4	95EB  6F      	        LD      L,A             ; HL = 0000
 785: 3042+4	95EC  67      	        LD      H,A
 786: 3046+16	95ED  2219B1  	        LD      (CONTAD),HL     ; No CONTinue
 787: 3062+13	95F0  3210B1  	        LD      (FORFLG),A      ; Clear FOR flag
 788: 3075+16	95F3  2223B1  	        LD      (FNRGNM),HL     ; Clear FN argument
 789: 3091+11	95F6  E5      	        PUSH    HL              ; HL = 0000
 790: 3102+11	95F7  C5      	        PUSH    BC              ; Put back return
 791: 3113+16	95F8  2A13B1  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 792: 3129+10	95FB  C9      	        RET                     ; Return to execution driver
 793:				
 794: 3139+7	95FC  3E3F    	PROMPT: LD      A,'?'           ; '?'
 795: 3146+17	95FE  CD8697  	        CALL    OUTC            ; Output character
 796: 3163+7	9601  3E20    	        LD      A,' '           ; Space
 797: 3170+17	9603  CD8697  	        CALL    OUTC            ; Output character
 798: 3187+10	9606  C393B0  	        JP      RINPUT          ; Get input line
 799:				
 800: 3197+4	9609  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 801: 3201+13	960A  32F3B0  	        LD      (DATFLG),A      ; Reset literal flag
 802: 3214+7	960D  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 803: 3221+10	960F  11A6B0  	        LD      DE,BUFFER       ; Start of input buffer
 804: 3231+7	9612  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 805: 3238+7	9613  FE20    	        CP      ' '             ; Is it a space?
 806: 3245+10	9615  CA9196  	        JP      Z,MOVDIR        ; Yes - Copy direct
 807: 3255+4	9618  47      	        LD      B,A             ; Save character
 808: 3259+7	9619  FE22    	        CP      '"'             ; Is it a quote?
 809: 3266+10	961B  CAB196  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 810: 3276+4	961E  B7      	        OR      A               ; Is it end of buffer?
 811: 3280+10	961F  CAB896  	        JP      Z,ENDBUF        ; Yes - End buffer
 812: 3290+13	9622  3AF3B0  	        LD      A,(DATFLG)      ; Get data type
 813: 3303+4	9625  B7      	        OR      A               ; Literal?
 814: 3307+7	9626  7E      	        LD      A,(HL)          ; Get byte to copy
 815: 3314+10	9627  C29196  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 816: 3324+7	962A  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 817: 3331+7	962C  3E9E    	        LD      A,ZPRINT        ; "PRINT" token
 818: 3338+10	962E  CA9196  	        JP      Z,MOVDIR        ; Yes - replace it
 819: 3348+7	9631  7E      	        LD      A,(HL)          ; Get byte again
 820: 3355+7	9632  FE30    	        CP      '0'             ; Is it less than '0'
 821: 3362+10	9634  DA3C96  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 822: 3372+7	9637  FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
 823: 3379+10	9639  DA9196  	        JP      C,MOVDIR        ; Yes - copy it direct
 824: 3389+11	963C  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 825: 3400+10	963D  113592  	        LD      DE,WORDS-1      ; Point to table
 826: 3410+11	9640  C5      	        PUSH    BC              ; Save count
 827: 3421+10	9641  018D96  	        LD      BC,RETNAD       ; Where to return to
 828: 3431+11	9644  C5      	        PUSH    BC              ; Save return address
 829: 3442+7	9645  067F    	        LD      B,ZEND-1        ; First token value -1
 830: 3449+7	9647  7E      	        LD      A,(HL)          ; Get byte
 831: 3456+7	9648  FE61    	        CP      'a'             ; Less than 'a' ?
 832: 3463+10	964A  DA5596  	        JP      C,SEARCH        ; Yes - search for words
 833: 3473+7	964D  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 834: 3480+10	964F  D25596  	        JP      NC,SEARCH       ; Yes - search for words
 835: 3490+7	9652  E65F    	        AND     01011111B       ; Force upper case
 836: 3497+7	9654  77      	        LD      (HL),A          ; Replace byte
 837: 3504+7	9655  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 838: 3511+4	9656  EB      	        EX      DE,HL
 839: 3515+6	9657  23      	GETNXT: INC     HL              ; Get next reserved word
 840: 3521+7	9658  B6      	        OR      (HL)            ; Start of word?
 841: 3528+10	9659  F25796  	        JP      P,GETNXT        ; No - move on
 842: 3538+4	965C  04      	        INC     B               ; Increment token value
 843: 3542+7	965D  7E      	        LD      A, (HL)         ; Get byte from table
 844: 3549+7	965E  E67F    	        AND     01111111B       ; Strip bit 7
 845: 3556+5+6	9660  C8      	        RET     Z               ; Return if end of list
 846: 3561+4	9661  B9      	        CP      C               ; Same character as in buffer?
 847: 3565+10	9662  C25796  	        JP      NZ,GETNXT       ; No - get next word
 848: 3575+4	9665  EB      	        EX      DE,HL
 849: 3579+11	9666  E5      	        PUSH    HL              ; Save start of word
 850:				
 851: 3590+6	9667  13      	NXTBYT: INC     DE              ; Look through rest of word
 852: 3596+7	9668  1A      	        LD      A,(DE)          ; Get byte from table
 853: 3603+4	9669  B7      	        OR      A               ; End of word ?
 854: 3607+10	966A  FA8996  	        JP      M,MATCH         ; Yes - Match found
 855: 3617+4	966D  4F      	        LD      C,A             ; Save it
 856: 3621+4	966E  78      	        LD      A,B             ; Get token value
 857: 3625+7	966F  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 858: 3632+10	9671  C27896  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 859: 3642+17	9674  CD0599  	        CALL    GETCHR          ; Get next character
 860: 3659+6	9677  2B      	        DEC     HL              ; Cancel increment from GETCHR
 861: 3665+6	9678  23      	NOSPC:  INC     HL              ; Next byte
 862: 3671+7	9679  7E      	        LD      A,(HL)          ; Get byte
 863: 3678+7	967A  FE61    	        CP      'a'             ; Less than 'a' ?
 864: 3685+10	967C  DA8196  	        JP      C,NOCHNG        ; Yes - don't change
 865: 3695+7	967F  E65F    	        AND     01011111B       ; Make upper case
 866: 3702+4	9681  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 867: 3706+10	9682  CA6796  	        JP      Z,NXTBYT        ; Yes - keep testing
 868: 3716+10	9685  E1      	        POP     HL              ; Get back start of word
 869: 3726+10	9686  C35596  	        JP      SEARCH          ; Look at next word
 870:				
 871: 3736+4	9689  48      	MATCH:  LD      C,B             ; Word found - Save token value
 872: 3740+10	968A  F1      	        POP     AF              ; Throw away return
 873: 3750+4	968B  EB      	        EX      DE,HL
 874: 3754+10	968C  C9      	        RET                     ; Return to "RETNAD"
 875: 3764+4	968D  EB      	RETNAD: EX      DE,HL           ; Get address in string
 876: 3768+4	968E  79      	        LD      A,C             ; Get token value
 877: 3772+10	968F  C1      	        POP     BC              ; Restore buffer length
 878: 3782+10	9690  D1      	        POP     DE              ; Get destination address
 879: 3792+6	9691  23      	MOVDIR: INC     HL              ; Next source in buffer
 880: 3798+7	9692  12      	        LD      (DE),A          ; Put byte in buffer
 881: 3805+6	9693  13      	        INC     DE              ; Move up buffer
 882: 3811+4	9694  0C      	        INC     C               ; Increment length of buffer
 883: 3815+7	9695  D63A    	        SUB     ':'             ; End of statement?
 884: 3822+10	9697  CA9F96  	        JP      Z,SETLIT        ; Jump if multi-statement line
 885: 3832+7	969A  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 886: 3839+10	969C  C2A296  	        JP      NZ,TSTREM       ; No - see if REM
 887: 3849+13	969F  32F3B0  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 888: 3862+7	96A2  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 889: 3869+10	96A4  C21296  	        JP      NZ,CRNCLP       ; No - Leave flag
 890: 3879+4	96A7  47      	        LD      B,A             ; Copy rest of buffer
 891: 3883+7	96A8  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 892: 3890+4	96A9  B7      	        OR      A               ; End of line ?
 893: 3894+10	96AA  CAB896  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 894: 3904+4	96AD  B8      	        CP      B               ; End of statement ?
 895: 3908+10	96AE  CA9196  	        JP      Z,MOVDIR        ; Yes - Get next one
 896: 3918+6	96B1  23      	CPYLIT: INC     HL              ; Move up source string
 897: 3924+7	96B2  12      	        LD      (DE),A          ; Save in destination
 898: 3931+4	96B3  0C      	        INC     C               ; Increment length
 899: 3935+6	96B4  13      	        INC     DE              ; Move up destination
 900: 3941+10	96B5  C3A896  	        JP      NXTCHR          ; Repeat
 901:				
 902: 3951+10	96B8  21A5B0  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 903: 3961+7	96BB  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 904: 3968+6	96BC  13      	        INC     DE
 905: 3974+7	96BD  12      	        LD      (DE),A          ; A = 00
 906: 3981+6	96BE  13      	        INC     DE
 907: 3987+7	96BF  12      	        LD      (DE),A          ; A = 00
 908: 3994+10	96C0  C9      	        RET
 909:				
 910: 4004+13	96C1  3A89B0  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
 911: 4017+4	96C4  B7      	        OR      A               ; Is it zero?
 912: 4021+7	96C5  3E00    	        LD      A,0             ; Zero A - Leave flags
 913: 4028+13	96C7  3289B0  	        LD      (NULFLG),A      ; Zero null flag
 914: 4041+10	96CA  C2D596  	        JP      NZ,ECHDEL       ; Set - Echo it
 915: 4051+4	96CD  05      	        DEC     B               ; Decrement length
 916: 4055+10	96CE  CAF296  	        JP      Z,GETLIN        ; Get line again if empty
 917: 4065+17	96D1  CD8697  	        CALL    OUTC            ; Output null character
 918:     -	96D4  3E      	        .BYTE   3EH             ; Skip "DEC B"
 919: 4082+4	96D5  05      	ECHDEL: DEC     B               ; Count bytes in buffer
 920: 4086+6	96D6  2B      	        DEC     HL              ; Back space buffer
 921: 4092+10	96D7  CAE996  	        JP      Z,OTKLN         ; No buffer - Try again
 922: 4102+7	96DA  7E      	        LD      A,(HL)          ; Get deleted byte
 923: 4109+17	96DB  CD8697  	        CALL    OUTC            ; Echo it
 924: 4126+10	96DE  C3FB96  	        JP      MORINP          ; Get more input
 925:				
 926: 4136+4	96E1  05      	DELCHR: DEC     B               ; Count bytes in buffer
 927: 4140+6	96E2  2B      	        DEC     HL              ; Back space buffer
 928: 4146+17	96E3  CD8697  	        CALL    OUTC            ; Output character in A
 929: 4163+10	96E6  C2FB96  	        JP      NZ,MORINP       ; Not end - Get more
 930: 4173+17	96E9  CD8697  	OTKLN:  CALL    OUTC            ; Output character in A
 931: 4190+17	96EC  CDB09B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 932: 4207+10	96EF  C3F296  	        JP      TTYLIN          ; Get line again
 933:				
 934:     -	96F2          	GETLIN:
 935: 4217+10	96F2  21A6B0  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 936: 4227+7	96F5  0601    	        LD      B,1             ; Set buffer as empty
 937: 4234+4	96F7  AF      	        XOR     A
 938: 4238+13	96F8  3289B0  	        LD      (NULFLG),A      ; Clear null flag
 939: 4251+17	96FB  CDB097  	MORINP: CALL    CLOTST          ; Get character and test ^O
 940: 4268+4	96FE  4F      	        LD      C,A             ; Save character in C
 941: 4272+7	96FF  FE7F    	        CP      DEL             ; Delete character?
 942: 4279+10	9701  CAC196  	        JP      Z,DODEL         ; Yes - Process it
 943: 4289+13	9704  3A89B0  	        LD      A,(NULFLG)      ; Get null flag
 944: 4302+4	9707  B7      	        OR      A               ; Test null flag status
 945: 4306+10	9708  CA1497  	        JP      Z,PROCES        ; Reset - Process character
 946: 4316+7	970B  3E00    	        LD      A,0             ; Set a null
 947: 4323+17	970D  CD8697  	        CALL    OUTC            ; Output null
 948: 4340+4	9710  AF      	        XOR     A               ; Clear A
 949: 4344+13	9711  3289B0  	        LD      (NULFLG),A      ; Reset null flag
 950: 4357+4	9714  79      	PROCES: LD      A,C             ; Get character
 951: 4361+7	9715  FE07    	        CP      CTRLG           ; Bell?
 952: 4368+10	9717  CA5897  	        JP      Z,PUTCTL        ; Yes - Save it
 953: 4378+7	971A  FE03    	        CP      CTRLC           ; Is it control "C"?
 954: 4385+10+7	971C  CCB09B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 955: 4395+4	971F  37      	        SCF                     ; Flag break
 956: 4399+5+6	9720  C8      	        RET     Z               ; Return if control "C"
 957: 4404+7	9721  FE0D    	        CP      CR              ; Is it enter?
 958: 4411+10	9723  CAAB9B  	        JP      Z,ENDINP        ; Yes - Terminate input
 959: 4421+7	9726  FE15    	        CP      CTRLU           ; Is it control "U"?
 960: 4428+10	9728  CAEC96  	        JP      Z,KILIN         ; Yes - Get another line
 961: 4438+7	972B  FE40    	        CP      '@'             ; Is it "kill line"?
 962: 4445+10	972D  CAE996  	        JP      Z,OTKLN         ; Yes - Kill line
 963: 4455+7	9730  FE5F    	        CP      '_'             ; Is it delete?
 964: 4462+10	9732  CAE196  	        JP      Z,DELCHR        ; Yes - Delete character
 965: 4472+7	9735  FE08    	        CP      BKSP            ; Is it backspace?
 966: 4479+10	9737  CAE196  	        JP      Z,DELCHR        ; Yes - Delete character
 967: 4489+7	973A  FE12    	        CP      CTRLR           ; Is it control "R"?
 968: 4496+10	973C  C25397  	        JP      NZ,PUTBUF       ; No - Put in buffer
 969: 4506+11	973F  C5      	        PUSH    BC              ; Save buffer length
 970: 4517+11	9740  D5      	        PUSH    DE              ; Save DE
 971: 4528+11	9741  E5      	        PUSH    HL              ; Save buffer address
 972: 4539+10	9742  3600    	        LD      (HL),0          ; Mark end of buffer
 973: 4549+17	9744  CD62AD  	        CALL    OUTNCR          ; Output and do CRLF
 974: 4566+10	9747  21A6B0  	        LD      HL,BUFFER       ; Point to buffer start
 975: 4576+17	974A  CD4EA2  	        CALL    PRS             ; Output buffer
 976: 4593+10	974D  E1      	        POP     HL              ; Restore buffer address
 977: 4603+10	974E  D1      	        POP     DE              ; Restore DE
 978: 4613+10	974F  C1      	        POP     BC              ; Restore buffer length
 979: 4623+10	9750  C3FB96  	        JP      MORINP          ; Get another character
 980:				
 981: 4633+7	9753  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
 982: 4640+10	9755  DAFB96  	        JP      C,MORINP        ; Yes - Ignore
 983: 4650+4	9758  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
 984: 4654+7	9759  FE49    	        CP      72+1            ; Test for line overflow
 985: 4661+7	975B  3E07    	        LD      A,CTRLG         ; Set a bell
 986: 4668+10	975D  D26D97  	        JP      NC,OUTNBS       ; Ring bell if buffer full
 987: 4678+4	9760  79      	        LD      A,C             ; Get character
 988: 4682+7	9761  71      	        LD      (HL),C          ; Save in buffer
 989: 4689+13	9762  3211B1  	        LD      (LSTBIN),A      ; Save last input byte
 990: 4702+6	9765  23      	        INC     HL              ; Move up buffer
 991: 4708+4	9766  04      	        INC     B               ; Increment length
 992: 4712+17	9767  CD8697  	OUTIT:  CALL    OUTC            ; Output the character entered
 993: 4729+10	976A  C3FB96  	        JP      MORINP          ; Get another character
 994:				
 995: 4739+17	976D  CD8697  	OUTNBS: CALL    OUTC            ; Output bell and back over it
 996: 4756+7	9770  3E08    	        LD      A,BKSP          ; Set back space
 997: 4763+10	9772  C36797  	        JP      OUTIT           ; Output it and get more
 998:				
 999: 4773+4	9775  7C      	CPDEHL: LD      A,H             ; Get H
1000: 4777+4	9776  92      	        SUB     D               ; Compare with D
1001: 4781+5+6	9777  C0      	        RET     NZ              ; Different - Exit
1002: 4786+4	9778  7D      	        LD      A,L             ; Get L
1003: 4790+4	9779  93      	        SUB     E               ; Compare with E
1004: 4794+10	977A  C9      	        RET                     ; Return status
1005:				
1006: 4804+7	977B  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
1007: 4811+19	977C  E3      	        EX      (SP),HL         ; Address of test byte
1008: 4830+7	977D  BE      	        CP      (HL)            ; Same as in code string?
1009: 4837+6	977E  23      	        INC     HL              ; Return address
1010: 4843+19	977F  E3      	        EX      (SP),HL         ; Put it back
1011: 4862+10	9780  CA0599  	        JP      Z,GETCHR        ; Yes - Get next character
1012: 4872+10	9783  C3AD94  	        JP      SNERR           ; Different - ?SN Error
1013:				
1014: 4882+11	9786  F5      	OUTC:   PUSH    AF              ; Save character
1015: 4893+13	9787  3A8AB0  	        LD      A,(CTLOFG)      ; Get control "O" flag
1016: 4906+4	978A  B7      	        OR      A               ; Is it set?
1017: 4910+10	978B  C283A2  	        JP      NZ,POPAF        ; Yes - don't output
1018: 4920+10	978E  F1      	        POP     AF              ; Restore character
1019: 4930+11	978F  C5      	        PUSH    BC              ; Save buffer length
1020: 4941+11	9790  F5      	        PUSH    AF              ; Save character
1021: 4952+7	9791  FE20    	        CP      ' '             ; Is it a control code?
1022: 4959+10	9793  DAAA97  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1023: 4969+13	9796  3A87B0  	        LD      A,(LWIDTH)      ; Get line width
1024: 4982+4	9799  47      	        LD      B,A             ; To B
1025: 4986+13	979A  3AF0B0  	        LD      A,(CURPOS)      ; Get cursor position
1026: 4999+4	979D  04      	        INC     B               ; Width 255?
1027: 5003+10	979E  CAA697  	        JP      Z,INCLEN        ; Yes - No width limit
1028: 5013+4	97A1  05      	        DEC     B               ; Restore width
1029: 5017+4	97A2  B8      	        CP      B               ; At end of line?
1030: 5021+10+7	97A3  CCB09B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1031: 5031+4	97A6  3C      	INCLEN: INC     A               ; Move on one character
1032: 5035+13	97A7  32F0B0  	        LD      (CURPOS),A      ; Save new position
1033: 5048+10	97AA  F1      	DINPOS: POP     AF              ; Restore character
1034: 5058+10	97AB  C1      	        POP     BC              ; Restore buffer length
1035: 5068+17	97AC  CD4BAD  	        CALL    MONOUT          ; Send it
1036: 5085+10	97AF  C9      	        RET
1037:				
1038: 5095+17	97B0  CD0DAC  	CLOTST: CALL    GETINP          ; Get input character
1039: 5112+7	97B3  E67F    	        AND     01111111B       ; Strip bit 7
1040: 5119+7	97B5  FE0F    	        CP      CTRLO           ; Is it control "O"?
1041: 5126+5+6	97B7  C0      	        RET     NZ              ; No don't flip flag
1042: 5131+13	97B8  3A8AB0  	        LD      A,(CTLOFG)      ; Get flag
1043: 5144+4	97BB  2F      	        CPL                     ; Flip it
1044: 5148+13	97BC  328AB0  	        LD      (CTLOFG),A      ; Put it back
1045: 5161+4	97BF  AF      	        XOR     A               ; Null character
1046: 5165+10	97C0  C9      	        RET
1047:				
1048: 5175+17	97C1  CDD499  	LIST:   CALL    ATOH            ; ASCII number to DE
1049: 5192+5+6	97C4  C0      	        RET     NZ              ; Return if anything extra
1050: 5197+10	97C5  C1      	        POP     BC              ; Rubbish - Not needed
1051: 5207+17	97C6  CD9995  	        CALL    SRCHLN          ; Search for line number in DE
1052: 5224+11	97C9  C5      	        PUSH    BC              ; Save address of line
1053: 5235+17	97CA  CD1798  	        CALL    SETLIN          ; Set up lines counter
1054: 5252+10	97CD  E1      	LISTLP: POP     HL              ; Restore address of line
1055: 5262+7	97CE  4E      	        LD      C,(HL)          ; Get LSB of next line
1056: 5269+6	97CF  23      	        INC     HL
1057: 5275+7	97D0  46      	        LD      B,(HL)          ; Get MSB of next line
1058: 5282+6	97D1  23      	        INC     HL
1059: 5288+4	97D2  78      	        LD      A,B             ; BC = 0 (End of program)?
1060: 5292+4	97D3  B1      	        OR      C
1061: 5296+10	97D4  CAF894  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1062: 5306+17	97D7  CD2098  	        CALL    COUNT           ; Count lines
1063: 5323+17	97DA  CD3099  	        CALL    TSTBRK          ; Test for break key
1064: 5340+11	97DD  C5      	        PUSH    BC              ; Save address of next line
1065: 5351+17	97DE  CDB09B  	        CALL    PRNTCRLF        ; Output CRLF
1066: 5368+7	97E1  5E      	        LD      E,(HL)          ; Get LSB of line number
1067: 5375+6	97E2  23      	        INC     HL
1068: 5381+7	97E3  56      	        LD      D,(HL)          ; Get MSB of line number
1069: 5388+6	97E4  23      	        INC     HL
1070: 5394+11	97E5  E5      	        PUSH    HL              ; Save address of line start
1071: 5405+4	97E6  EB      	        EX      DE,HL           ; Line number to HL
1072: 5409+17	97E7  CDF1A8  	        CALL    PRNTHL          ; Output line number in decimal
1073: 5426+7	97EA  3E20    	        LD      A,' '           ; Space after line number
1074: 5433+10	97EC  E1      	        POP     HL              ; Restore start of line address
1075: 5443+17	97ED  CD8697  	LSTLP2: CALL    OUTC            ; Output character in A
1076: 5460+7	97F0  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1077: 5467+4	97F1  B7      	        OR      A               ; End of line?
1078: 5471+6	97F2  23      	        INC     HL              ; To next byte in line
1079: 5477+10	97F3  CACD97  	        JP      Z,LISTLP        ; Yes - get next line
1080: 5487+10	97F6  F2ED97  	        JP      P,LSTLP2        ; No token - output it
1081: 5497+7	97F9  D67F    	        SUB     ZEND-1          ; Find and output word
1082: 5504+4	97FB  4F      	        LD      C,A             ; Token offset+1 to C
1083: 5508+10	97FC  113692  	        LD      DE,WORDS        ; Reserved word list
1084: 5518+7	97FF  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1085: 5525+6	9800  13      	        INC     DE              ; Move on to next
1086: 5531+4	9801  B7      	        OR      A               ; Is it start of word?
1087: 5535+10	9802  F2FF97  	        JP      P,FNDTOK        ; No - Keep looking for word
1088: 5545+4	9805  0D      	        DEC     C               ; Count words
1089: 5549+10	9806  C2FF97  	        JP      NZ,FNDTOK       ; Not there - keep looking
1090: 5559+7	9809  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1091: 5566+17	980B  CD8697  	        CALL    OUTC            ; Output first character
1092: 5583+7	980E  1A      	        LD      A,(DE)          ; Get next character
1093: 5590+6	980F  13      	        INC     DE              ; Move on to next
1094: 5596+4	9810  B7      	        OR      A               ; Is it end of word?
1095: 5600+10	9811  F20998  	        JP      P,OUTWRD        ; No - output the rest
1096: 5610+10	9814  C3F097  	        JP      LSTLP3          ; Next byte in line
1097:				
1098: 5620+11	9817  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1099: 5631+16	9818  2A8DB0  	        LD      HL,(LINESN)     ; Get LINES number
1100: 5647+16	981B  228BB0  	        LD      (LINESC),HL     ; Save in LINES counter
1101: 5663+10	981E  E1      	        POP     HL
1102: 5673+10	981F  C9      	        RET
1103:				
1104: 5683+11	9820  E5      	COUNT:  PUSH    HL              ; Save code string address
1105: 5694+11	9821  D5      	        PUSH    DE
1106: 5705+16	9822  2A8BB0  	        LD      HL,(LINESC)     ; Get LINES counter
1107: 5721+10	9825  11FFFF  	        LD      DE,-1
1108: 5731+15	9828  ED5A    	        ADC     HL,DE           ; Decrement
1109: 5746+16	982A  228BB0  	        LD      (LINESC),HL     ; Put it back
1110: 5762+10	982D  D1      	        POP     DE
1111: 5772+10	982E  E1      	        POP     HL              ; Restore code string address
1112: 5782+5+6	982F  F0      	        RET     P               ; Return if more lines to go
1113: 5787+11	9830  E5      	        PUSH    HL              ; Save code string address
1114: 5798+16	9831  2A8DB0  	        LD      HL,(LINESN)     ; Get LINES number
1115: 5814+16	9834  228BB0  	        LD      (LINESC),HL     ; Reset LINES counter
1116: 5830+17	9837  CD0DAC  	        CALL    GETINP          ; Get input character
1117: 5847+7	983A  FE03    	        CP      CTRLC           ; Is it control "C"?
1118: 5854+10	983C  CA4398  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1119: 5864+10	983F  E1      	        POP     HL              ; Restore code string address
1120: 5874+10	9840  C32098  	        JP      COUNT           ; Keep on counting
1121:				
1122: 5884+16	9843  2A8DB0  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1123: 5900+16	9846  228BB0  	        LD      (LINESC),HL     ; Reset LINES counter
1124: 5916+10	9849  C3A791  	        JP      BRKRET          ; Go and output "Break"
1125:				
1126: 5926+7	984C  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1127: 5933+13	984E  3210B1  	        LD      (FORFLG),A      ; Save "FOR" flag
1128: 5946+17	9851  CDB69A  	        CALL    LET             ; Set up initial index
1129: 5963+10	9854  C1      	        POP     BC              ; Drop RETurn address
1130: 5973+11	9855  E5      	        PUSH    HL              ; Save code string address
1131: 5984+17	9856  CD9F9A  	        CALL    DATA            ; Get next statement address
1132: 6001+16	9859  220CB1  	        LD      (LOOPST),HL     ; Save it for start of loop
1133: 6017+10	985C  210200  	        LD      HL,2            ; Offset for "FOR" block
1134: 6027+11	985F  39      	        ADD     HL,SP           ; Point to it
1135: 6038+17	9860  CD5A94  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1136: 6055+10	9863  D1      	        POP     DE              ; Get code string address
1137: 6065+10	9864  C27C98  	        JP      NZ,FORFND       ; No nesting found
1138: 6075+11	9867  09      	        ADD     HL,BC           ; Move into "FOR" block
1139: 6086+11	9868  D5      	        PUSH    DE              ; Save code string address
1140: 6097+6	9869  2B      	        DEC     HL
1141: 6103+7	986A  56      	        LD      D,(HL)          ; Get MSB of loop statement
1142: 6110+6	986B  2B      	        DEC     HL
1143: 6116+7	986C  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1144: 6123+6	986D  23      	        INC     HL
1145: 6129+6	986E  23      	        INC     HL
1146: 6135+11	986F  E5      	        PUSH    HL              ; Save block address
1147: 6146+16	9870  2A0CB1  	        LD      HL,(LOOPST)     ; Get address of loop statement
1148: 6162+17	9873  CD7597  	        CALL    CPDEHL          ; Compare the FOR loops
1149: 6179+10	9876  E1      	        POP     HL              ; Restore block address
1150: 6189+10	9877  C26098  	        JP      NZ,FORSLP       ; Different FORs - Find another
1151: 6199+10	987A  D1      	        POP     DE              ; Restore code string address
1152: 6209+6	987B  F9      	        LD      SP,HL           ; Remove all nested loops
1153:				
1154: 6215+4	987C  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1155: 6219+7	987D  0E08    	        LD      C,8
1156: 6226+17	987F  CD8A94  	        CALL    CHKSTK          ; Check for 8 levels of stack
1157: 6243+11	9882  E5      	        PUSH    HL              ; Save code string address
1158: 6254+16	9883  2A0CB1  	        LD      HL,(LOOPST)     ; Get first statement of loop
1159: 6270+19	9886  E3      	        EX      (SP),HL         ; Save and restore code string
1160: 6289+11	9887  E5      	        PUSH    HL              ; Re-save code string address
1161: 6300+16	9888  2AA1B0  	        LD      HL,(LINEAT)     ; Get current line number
1162: 6316+19	988B  E3      	        EX      (SP),HL         ; Save and restore code string
1163: 6335+17	988C  CD789D  	        CALL    TSTNUM          ; Make sure it's a number
1164: 6352+17	988F  CD7B97  	        CALL    CHKSYN          ; Make sure "TO" is next
1165:     -	9892  A6      	        .BYTE   ZTO          ; "TO" token
1166: 6369+17	9893  CD759D  	        CALL    GETNUM          ; Get "TO" expression value
1167: 6386+11	9896  E5      	        PUSH    HL              ; Save code string address
1168: 6397+17	9897  CDA3A7  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1169: 6414+10	989A  E1      	        POP     HL              ; Restore code string address
1170: 6424+11	989B  C5      	        PUSH    BC              ; Save "TO" value in block
1171: 6435+11	989C  D5      	        PUSH    DE
1172: 6446+10	989D  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1173: 6456+4	98A0  51      	        LD      D,C             ; C=0
1174: 6460+4	98A1  5A      	        LD      E,D             ; D=0
1175: 6464+7	98A2  7E      	        LD      A,(HL)          ; Get next byte in code string
1176: 6471+7	98A3  FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
1177: 6478+7	98A5  3E01    	        LD      A,1             ; Sign of step = 1
1178: 6485+10	98A7  C2B898  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1179: 6495+17	98AA  CD0599  	        CALL    GETCHR          ; Jump over "STEP" token
1180: 6512+17	98AD  CD759D  	        CALL    GETNUM          ; Get step value
1181: 6529+11	98B0  E5      	        PUSH    HL              ; Save code string address
1182: 6540+17	98B1  CDA3A7  	        CALL    BCDEFP          ; Move STEP to BCDE
1183: 6557+17	98B4  CD57A7  	        CALL    TSTSGN          ; Test sign of FPREG
1184: 6574+10	98B7  E1      	        POP     HL              ; Restore code string address
1185: 6584+11	98B8  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1186: 6595+11	98B9  D5      	        PUSH    DE
1187: 6606+11	98BA  F5      	        PUSH    AF              ; Save sign of STEP
1188: 6617+6	98BB  33      	        INC     SP              ; Don't save flags
1189: 6623+11	98BC  E5      	        PUSH    HL              ; Save code string address
1190: 6634+16	98BD  2A13B1  	        LD      HL,(BRKLIN)     ; Get address of index variable
1191: 6650+19	98C0  E3      	        EX      (SP),HL         ; Save and restore code string
1192: 6669+7	98C1  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1193: 6676+11	98C3  C5      	        PUSH    BC              ; Save it
1194: 6687+6	98C4  33      	        INC     SP              ; Don't save C
1195:				
1196: 6693+17	98C5  CD3099  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1197: 6710+16	98C8  2213B1  	        LD      (BRKLIN),HL     ; Save code address for break
1198: 6726+7	98CB  7E      	        LD      A,(HL)          ; Get next byte in code string
1199: 6733+7	98CC  FE3A    	        CP      ':'             ; Multi statement line?
1200: 6740+10	98CE  CAE598  	        JP      Z,EXCUTE        ; Yes - Execute it
1201: 6750+4	98D1  B7      	        OR      A               ; End of line?
1202: 6754+10	98D2  C2AD94  	        JP      NZ,SNERR        ; No - Syntax error
1203: 6764+6	98D5  23      	        INC     HL              ; Point to address of next line
1204: 6770+7	98D6  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1205: 6777+6	98D7  23      	        INC     HL
1206: 6783+7	98D8  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1207: 6790+10	98D9  CA5A99  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1208: 6800+6	98DC  23      	        INC     HL              ; Point to line number
1209: 6806+7	98DD  5E      	        LD      E,(HL)          ; Get LSB of line number
1210: 6813+6	98DE  23      	        INC     HL
1211: 6819+7	98DF  56      	        LD      D,(HL)          ; Get MSB of line number
1212: 6826+4	98E0  EB      	        EX      DE,HL           ; Line number to HL
1213: 6830+16	98E1  22A1B0  	        LD      (LINEAT),HL     ; Save as current line number
1214: 6846+4	98E4  EB      	        EX      DE,HL           ; Line number back to DE
1215: 6850+17	98E5  CD0599  	EXCUTE: CALL    GETCHR          ; Get key word
1216: 6867+10	98E8  11C598  	        LD      DE,RUNCNT       ; Where to RETurn to
1217: 6877+11	98EB  D5      	        PUSH    DE              ; Save for RETurn
1218: 6888+5+6	98EC  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1219: 6893+7	98ED  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1220: 6900+10	98EF  DAB69A  	        JP      C,LET           ; No - try to assign it
1221: 6910+7	98F2  FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1222: 6917+10	98F4  D2AD94  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1223: 6927+4	98F7  07      	        RLCA                    ; Double it
1224: 6931+4	98F8  4F      	        LD      C,A             ; BC = Offset into table
1225: 6935+7	98F9  0600    	        LD      B,0
1226: 6942+4	98FB  EB      	        EX      DE,HL           ; Save code string address
1227: 6946+10	98FC  215593  	        LD      HL,WORDTB       ; Keyword address table
1228: 6956+11	98FF  09      	        ADD     HL,BC           ; Point to routine address
1229: 6967+7	9900  4E      	        LD      C,(HL)          ; Get LSB of routine address
1230: 6974+6	9901  23      	        INC     HL
1231: 6980+7	9902  46      	        LD      B,(HL)          ; Get MSB of routine address
1232: 6987+11	9903  C5      	        PUSH    BC              ; Save routine address
1233: 6998+4	9904  EB      	        EX      DE,HL           ; Restore code string address
1234:				
1235: 7002+6	9905  23      	GETCHR: INC     HL              ; Point to next character
1236: 7008+7	9906  7E      	        LD      A,(HL)          ; Get next code string byte
1237: 7015+7	9907  FE3A    	        CP      ':'             ; Z if ':'
1238: 7022+5+6	9909  D0      	        RET     NC              ; NC if > "9"
1239: 7027+7	990A  FE20    	        CP      ' '
1240: 7034+10	990C  CA0599  	        JP      Z,GETCHR        ; Skip over spaces
1241: 7044+7	990F  FE30    	        CP      '0'
1242: 7051+4	9911  3F      	        CCF                     ; NC if < '0'
1243: 7055+4	9912  3C      	        INC     A               ; Test for zero - Leave carry
1244: 7059+4	9913  3D      	        DEC     A               ; Z if Null
1245: 7063+10	9914  C9      	        RET
1246:				
1247: 7073+4	9915  EB      	RESTOR: EX      DE,HL           ; Save code string address
1248: 7077+16	9916  2AA3B0  	        LD      HL,(BASTXT)     ; Point to start of program
1249: 7093+10	9919  CA2A99  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1250: 7103+4	991C  EB      	        EX      DE,HL           ; Restore code string address
1251: 7107+17	991D  CDD499  	        CALL    ATOH            ; Get line number to DE
1252: 7124+11	9920  E5      	        PUSH    HL              ; Save code string address
1253: 7135+17	9921  CD9995  	        CALL    SRCHLN          ; Search for line number in DE
1254: 7152+4	9924  60      	        LD      H,B             ; HL = Address of line
1255: 7156+4	9925  69      	        LD      L,C
1256: 7160+10	9926  D1      	        POP     DE              ; Restore code string address
1257: 7170+10	9927  D2759A  	        JP      NC,ULERR        ; ?UL Error if not found
1258: 7180+6	992A  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1259: 7186+16	992B  2221B1  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1260: 7202+4	992E  EB      	        EX      DE,HL           ; Restore code string address
1261: 7206+10	992F  C9      	        RET
1262:				
1263:				;;; <ESH> edit a bit to check for break, then read character
1264:				;TSTBRK: RST     18H             ; Check input status
1265:				;        RET     Z               ; No key, go back
1266:				;        RST     10H             ; Get the key into A
1267:				
1268: 7216+17	9930  CD7FAD  	TSTBRK:	call	umon_chkbrk	;<ESH> check for break, then input char
1269: 7233+5+6	9933  C8      	        RET     Z               ; No key, go back
1270: 7238+7	9934  FE1B    	        CP      ESC             ; Escape key?
1271: 7245+7+5	9936  2813    	        JR      Z,BRK           ; Yes, break
1272: 7252+7	9938  FE03    	        CP      CTRLC           ; <Ctrl-C>
1273: 7259+7+5	993A  280F    	        JR      Z,BRK           ; Yes, break
1274: 7266+7	993C  FE13    	        CP      CTRLS           ; Stop scrolling?
1275: 7273+5+6	993E  C0      	        RET     NZ              ; Other key, ignore
1276:				
1277:				;STALL:  RST     10H             ; Wait for key <FIXME>
1278: 7278+17	993F  CD8FAD  	STALL:  call	umon_getc	;<ESH> read serial
1279: 7295+7	9942  FE11    	        CP      CTRLQ           ; Resume scrolling?
1280: 7302+5+6	9944  C8      	        RET      Z              ; Release the chokehold
1281: 7307+7	9945  FE03    	        CP      CTRLC           ; Second break?
1282: 7314+7+5	9947  2807    	        JR      Z,STOP          ; Break during hold exits prog
1283: 7321+12	9949  18F4    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1284:				
1285: 7333+7	994B  3EFF    	BRK     LD      A,$FF           ; Set BRKFLG
1286: 7340+13	994D  3292B0  	        LD      (BRKFLG),A      ; Store it
1287:				
1288:				
1289: 7353+5+6	9950  C0      	STOP:   RET     NZ              ; Exit if anything else
1290:     -	9951  F6      	        .BYTE   0F6H            ; Flag "STOP"
1291: 7358+5+6	9952  C0      	PEND:   RET     NZ              ; Exit if anything else
1292: 7363+16	9953  2213B1  	        LD      (BRKLIN),HL     ; Save point of break
1293:     -	9956  21      	        .BYTE   21H             ; Skip "OR 11111111B"
1294: 7379+7	9957  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1295: 7386+10	9959  C1      	        POP     BC              ; Return not needed and more
1296: 7396+16	995A  2AA1B0  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1297: 7412+11	995D  F5      	        PUSH    AF              ; Save STOP / END status
1298: 7423+4	995E  7D      	        LD      A,L             ; Is it direct break?
1299: 7427+4	995F  A4      	        AND     H
1300: 7431+4	9960  3C      	        INC     A               ; Line is -1 if direct break
1301: 7435+10	9961  CA6D99  	        JP      Z,NOLIN         ; Yes - No line number
1302: 7445+16	9964  2217B1  	        LD      (ERRLIN),HL     ; Save line of break
1303: 7461+16	9967  2A13B1  	        LD      HL,(BRKLIN)     ; Get point of break
1304: 7477+16	996A  2219B1  	        LD      (CONTAD),HL     ; Save point to CONTinue
1305: 7493+4	996D  AF      	NOLIN:  XOR     A
1306: 7497+13	996E  328AB0  	        LD      (CTLOFG),A      ; Enable output
1307: 7510+17	9971  CDA39B  	        CALL    STTLIN          ; Start a new line
1308: 7527+10	9974  F1      	        POP     AF              ; Restore STOP / END status
1309: 7537+10	9975  215094  	        LD      HL,BRKMSG       ; "Break" message
1310: 7547+10	9978  C2E194  	        JP      NZ,ERRIN        ; "in line" wanted?
1311: 7557+10	997B  C3F894  	        JP      PRNTOK          ; Go to command mode
1312:				
1313: 7567+16	997E  2A19B1  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1314: 7583+4	9981  7C      	        LD      A,H             ; Is it zero?
1315: 7587+4	9982  B5      	        OR      L
1316: 7591+7	9983  1E20    	        LD      E,CN            ; ?CN Error
1317: 7598+10	9985  CAC194  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1318: 7608+4	9988  EB      	        EX      DE,HL           ; Save code string address
1319: 7612+16	9989  2A17B1  	        LD      HL,(ERRLIN)     ; Get line of last break
1320: 7628+16	998C  22A1B0  	        LD      (LINEAT),HL     ; Set up current line number
1321: 7644+4	998F  EB      	        EX      DE,HL           ; Restore code string address
1322: 7648+10	9990  C9      	        RET                     ; CONTinue where left off
1323:				
1324: 7658+17	9991  CDD6A4  	NULL:   CALL    GETINT          ; Get integer 0-255
1325: 7675+5+6	9994  C0      	        RET     NZ              ; Return if bad value
1326: 7680+13	9995  3286B0  	        LD      (NULLS),A       ; Set nulls number
1327: 7693+10	9998  C9      	        RET
1328:				
1329:				
1330: 7703+11	9999  E5      	ACCSUM: PUSH    HL              ; Save address in array
1331: 7714+16	999A  2A8FB0  	        LD      HL,(CHKSUM)     ; Get check sum
1332: 7730+7	999D  0600    	        LD      B,0             ; BC - Value of byte
1333: 7737+4	999F  4F      	        LD      C,A
1334: 7741+11	99A0  09      	        ADD     HL,BC           ; Add byte to check sum
1335: 7752+16	99A1  228FB0  	        LD      (CHKSUM),HL     ; Re-save check sum
1336: 7768+10	99A4  E1      	        POP     HL              ; Restore address in array
1337: 7778+10	99A5  C9      	        RET
1338:				
1339: 7788+7	99A6  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1340: 7795+7	99A7  FE41    	        CP      'A'             ; < 'a' ?
1341: 7802+5+6	99A9  D8      	        RET     C               ; Carry set if not letter
1342: 7807+7	99AA  FE5B    	        CP      'Z'+1           ; > 'z' ?
1343: 7814+4	99AC  3F      	        CCF
1344: 7818+10	99AD  C9      	        RET                     ; Carry set if not letter
1345:				
1346: 7828+17	99AE  CD0599  	FPSINT: CALL    GETCHR          ; Get next character
1347: 7845+17	99B1  CD759D  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1348: 7862+17	99B4  CD57A7  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1349: 7879+10	99B7  FACF99  	        JP      M,FCERR         ; Negative - ?FC Error
1350: 7889+13	99BA  3A2CB1  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1351: 7902+7	99BD  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1352: 7909+10	99BF  DAFFA7  	        JP      C,FPINT         ; Yes - convert it
1353: 7919+10	99C2  018090  	        LD      BC,9080H        ; BCDE = -32768
1354: 7929+10	99C5  110000  	        LD      DE,0000
1355: 7939+11	99C8  E5      	        PUSH    HL              ; Save code string address
1356: 7950+17	99C9  CDD2A7  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1357: 7967+10	99CC  E1      	        POP     HL              ; Restore code string address
1358: 7977+4	99CD  51      	        LD      D,C             ; MSB to D
1359: 7981+5+6	99CE  C8      	        RET     Z               ; Return if in range
1360: 7986+7	99CF  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1361: 7993+10	99D1  C3C194  	        JP      ERROR           ; Output error-
1362:				
1363: 8003+6	99D4  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1364: 8009+10	99D5  110000  	GETLN:  LD      DE,0            ; Get number to DE
1365: 8019+17	99D8  CD0599  	GTLNLP: CALL    GETCHR          ; Get next character
1366: 8036+5+6	99DB  D0      	        RET     NC              ; Exit if not a digit
1367: 8041+11	99DC  E5      	        PUSH    HL              ; Save code string address
1368: 8052+11	99DD  F5      	        PUSH    AF              ; Save digit
1369: 8063+10	99DE  219819  	        LD      HL,65529/10     ; Largest number 65529
1370: 8073+17	99E1  CD7597  	        CALL    CPDEHL          ; Number in range?
1371: 8090+10	99E4  DAAD94  	        JP      C,SNERR         ; No - ?SN Error
1372: 8100+4	99E7  62      	        LD      H,D             ; HL = Number
1373: 8104+4	99E8  6B      	        LD      L,E
1374: 8108+11	99E9  19      	        ADD     HL,DE           ; Times 2
1375: 8119+11	99EA  29      	        ADD     HL,HL           ; Times 4
1376: 8130+11	99EB  19      	        ADD     HL,DE           ; Times 5
1377: 8141+11	99EC  29      	        ADD     HL,HL           ; Times 10
1378: 8152+10	99ED  F1      	        POP     AF              ; Restore digit
1379: 8162+7	99EE  D630    	        SUB     '0'             ; Make it 0 to 9
1380: 8169+4	99F0  5F      	        LD      E,A             ; DE = Value of digit
1381: 8173+7	99F1  1600    	        LD      D,0
1382: 8180+11	99F3  19      	        ADD     HL,DE           ; Add to number
1383: 8191+4	99F4  EB      	        EX      DE,HL           ; Number to DE
1384: 8195+10	99F5  E1      	        POP     HL              ; Restore code string address
1385: 8205+10	99F6  C3D899  	        JP      GTLNLP          ; Go to next character
1386:				
1387: 8215+10	99F9  CAC995  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1388: 8225+17	99FC  CDB199  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1389: 8242+6	99FF  2B      	        DEC     HL              ; Cancel increment
1390: 8248+17	9A00  CD0599  	        CALL    GETCHR          ; Get next character
1391: 8265+11	9A03  E5      	        PUSH    HL              ; Save code string address
1392: 8276+16	9A04  2AF4B0  	        LD      HL,(LSTRAM)     ; Get end of RAM
1393: 8292+10	9A07  CA1C9A  	        JP      Z,STORED        ; No value given - Use stored
1394: 8302+10	9A0A  E1      	        POP     HL              ; Restore code string address
1395: 8312+17	9A0B  CD7B97  	        CALL    CHKSYN          ; Check for comma
1396:     -	9A0E  2C      	        .BYTE      ','
1397: 8329+11	9A0F  D5      	        PUSH    DE              ; Save number
1398: 8340+17	9A10  CDB199  	        CALL    POSINT          ; Get integer 0 to 32767
1399: 8357+6	9A13  2B      	        DEC     HL              ; Cancel increment
1400: 8363+17	9A14  CD0599  	        CALL    GETCHR          ; Get next character
1401: 8380+10	9A17  C2AD94  	        JP      NZ,SNERR        ; ?SN Error if more on line
1402: 8390+19	9A1A  E3      	        EX      (SP),HL         ; Save code string address
1403: 8409+4	9A1B  EB      	        EX      DE,HL           ; Number to DE
1404: 8413+4	9A1C  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1405: 8417+4	9A1D  93      	        SUB     E               ; Subtract LSB of string space
1406: 8421+4	9A1E  5F      	        LD      E,A             ; Save LSB
1407: 8425+4	9A1F  7C      	        LD      A,H             ; Get MSB of new RAM top
1408: 8429+4	9A20  9A      	        SBC     A,D             ; Subtract MSB of string space
1409: 8433+4	9A21  57      	        LD      D,A             ; Save MSB
1410: 8437+10	9A22  DAA294  	        JP      C,OMERR         ; ?OM Error if not enough mem
1411: 8447+11	9A25  E5      	        PUSH    HL              ; Save RAM top
1412: 8458+16	9A26  2A1BB1  	        LD      HL,(PROGND)     ; Get program end
1413: 8474+10	9A29  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1414: 8484+11	9A2C  09      	        ADD     HL,BC           ; Get lowest address
1415: 8495+17	9A2D  CD7597  	        CALL    CPDEHL          ; Enough memory?
1416: 8512+10	9A30  D2A294  	        JP      NC,OMERR        ; No - ?OM Error
1417: 8522+4	9A33  EB      	        EX      DE,HL           ; RAM top to HL
1418: 8526+16	9A34  229FB0  	        LD      (STRSPC),HL     ; Set new string space
1419: 8542+10	9A37  E1      	        POP     HL              ; End of memory to use
1420: 8552+16	9A38  22F4B0  	        LD      (LSTRAM),HL     ; Set new top of RAM
1421: 8568+10	9A3B  E1      	        POP     HL              ; Restore code string address
1422: 8578+10	9A3C  C3C995  	        JP      INTVAR          ; Initialise variables
1423:				
1424: 8588+10	9A3F  CAC595  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1425: 8598+17	9A42  CDC995  	        CALL    INTVAR          ; Initialise variables
1426: 8615+10	9A45  01C598  	        LD      BC,RUNCNT       ; Execution driver loop
1427: 8625+10	9A48  C35B9A  	        JP      RUNLIN          ; RUN from line number
1428:				
1429: 8635+7	9A4B  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1430: 8642+17	9A4D  CD8A94  	        CALL    CHKSTK          ; Check for 3 levels of stack
1431: 8659+10	9A50  C1      	        POP     BC              ; Get return address
1432: 8669+11	9A51  E5      	        PUSH    HL              ; Save code string for RETURN
1433: 8680+11	9A52  E5      	        PUSH    HL              ; And for GOSUB routine
1434: 8691+16	9A53  2AA1B0  	        LD      HL,(LINEAT)     ; Get current line
1435: 8707+19	9A56  E3      	        EX      (SP),HL         ; Into stack - Code string out
1436: 8726+7	9A57  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1437: 8733+11	9A59  F5      	        PUSH    AF              ; Save token
1438: 8744+6	9A5A  33      	        INC     SP              ; Don't save flags
1439:				
1440: 8750+11	9A5B  C5      	RUNLIN: PUSH    BC              ; Save return address
1441: 8761+17	9A5C  CDD499  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1442: 8778+17	9A5F  CDA19A  	        CALL    REM             ; Get end of line
1443: 8795+11	9A62  E5      	        PUSH    HL              ; Save end of line
1444: 8806+16	9A63  2AA1B0  	        LD      HL,(LINEAT)     ; Get current line
1445: 8822+17	9A66  CD7597  	        CALL    CPDEHL          ; Line after current?
1446: 8839+10	9A69  E1      	        POP     HL              ; Restore end of line
1447: 8849+6	9A6A  23      	        INC     HL              ; Start of next line
1448: 8855+10+7	9A6B  DC9C95  	        CALL    C,SRCHLP        ; Line is after current line
1449: 8865+10+7	9A6E  D49995  	        CALL    NC,SRCHLN       ; Line is before current line
1450: 8875+4	9A71  60      	        LD      H,B             ; Set up code string address
1451: 8879+4	9A72  69      	        LD      L,C
1452: 8883+6	9A73  2B      	        DEC     HL              ; Incremented after
1453: 8889+5+6	9A74  D8      	        RET     C               ; Line found
1454: 8894+7	9A75  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1455: 8901+10	9A77  C3C194  	        JP      ERROR           ; Output error message
1456:				
1457: 8911+5+6	9A7A  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1458: 8916+7	9A7B  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1459: 8923+17	9A7D  CD5694  	        CALL    BAKSTK          ; Look "GOSUB" block
1460: 8940+6	9A80  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1461: 8946+7	9A81  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1462: 8953+7	9A83  1E04    	        LD      E,RG            ; ?RG Error
1463: 8960+10	9A85  C2C194  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1464: 8970+10	9A88  E1      	        POP     HL              ; Get RETURN line number
1465: 8980+16	9A89  22A1B0  	        LD      (LINEAT),HL     ; Save as current
1466: 8996+6	9A8C  23      	        INC     HL              ; Was it from direct statement?
1467: 9002+4	9A8D  7C      	        LD      A,H
1468: 9006+4	9A8E  B5      	        OR      L               ; Return to line
1469: 9010+10	9A8F  C2999A  	        JP      NZ,RETLIN       ; No - Return to line
1470: 9020+13	9A92  3A11B1  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1471: 9033+4	9A95  B7      	        OR      A               ; If so buffer is corrupted
1472: 9037+10	9A96  C2F794  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1473: 9047+10	9A99  21C598  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1474: 9057+19	9A9C  E3      	        EX      (SP),HL         ; Into stack - Code string out
1475:     -	9A9D  3E      	        .BYTE      3EH             ; Skip "POP HL"
1476: 9076+10	9A9E  E1      	NXTDTA: POP     HL              ; Restore code string address
1477:				
1478:     -	9A9F  013A    	DATA:   .BYTE      01H,3AH         ; ':' End of statement
1479: 9086+7	9AA1  0E00    	REM:    LD      C,0             ; 00  End of statement
1480: 9093+7	9AA3  0600    	        LD      B,0
1481: 9100+4	9AA5  79      	NXTSTL: LD      A,C             ; Statement and byte
1482: 9104+4	9AA6  48      	        LD      C,B
1483: 9108+4	9AA7  47      	        LD      B,A             ; Statement end byte
1484: 9112+7	9AA8  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1485: 9119+4	9AA9  B7      	        OR      A               ; End of line?
1486: 9123+5+6	9AAA  C8      	        RET     Z               ; Yes - Exit
1487: 9128+4	9AAB  B8      	        CP      B               ; End of statement?
1488: 9132+5+6	9AAC  C8      	        RET     Z               ; Yes - Exit
1489: 9137+6	9AAD  23      	        INC     HL              ; Next byte
1490: 9143+7	9AAE  FE22    	        CP      '"'             ; Literal string?
1491: 9150+10	9AB0  CAA59A  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1492: 9160+10	9AB3  C3A89A  	        JP      NXTSTT          ; Keep looking
1493:				
1494: 9170+17	9AB6  CD6B9F  	LET:    CALL    GETVAR          ; Get variable name
1495: 9187+17	9AB9  CD7B97  	        CALL    CHKSYN          ; Make sure "=" follows
1496:     -	9ABC  B4      	        .BYTE      ZEQUAL          ; "=" token
1497: 9204+11	9ABD  D5      	        PUSH    DE              ; Save address of variable
1498: 9215+13	9ABE  3AF2B0  	        LD      A,(TYPE)        ; Get data type
1499: 9228+11	9AC1  F5      	        PUSH    AF              ; Save type
1500: 9239+17	9AC2  CD879D  	        CALL    EVAL            ; Evaluate expression
1501: 9256+10	9AC5  F1      	        POP     AF              ; Restore type
1502: 9266+19	9AC6  E3      	        EX      (SP),HL         ; Save code - Get var addr
1503: 9285+16	9AC7  2213B1  	        LD      (BRKLIN),HL     ; Save address of variable
1504: 9301+4	9ACA  1F      	        RRA                     ; Adjust type
1505: 9305+17	9ACB  CD7A9D  	        CALL    CHKTYP          ; Check types are the same
1506: 9322+10	9ACE  CA099B  	        JP      Z,LETNUM        ; Numeric - Move value
1507: 9332+11	9AD1  E5      	LETSTR: PUSH    HL              ; Save address of string var
1508: 9343+16	9AD2  2A29B1  	        LD      HL,(FPREG)      ; Pointer to string entry
1509: 9359+11	9AD5  E5      	        PUSH    HL              ; Save it on stack
1510: 9370+6	9AD6  23      	        INC     HL              ; Skip over length
1511: 9376+6	9AD7  23      	        INC     HL
1512: 9382+7	9AD8  5E      	        LD      E,(HL)          ; LSB of string address
1513: 9389+6	9AD9  23      	        INC     HL
1514: 9395+7	9ADA  56      	        LD      D,(HL)          ; MSB of string address
1515: 9402+16	9ADB  2AA3B0  	        LD      HL,(BASTXT)     ; Point to start of program
1516: 9418+17	9ADE  CD7597  	        CALL    CPDEHL          ; Is string before program?
1517: 9435+10	9AE1  D2F89A  	        JP      NC,CRESTR       ; Yes - Create string entry
1518: 9445+16	9AE4  2A9FB0  	        LD      HL,(STRSPC)     ; Point to string space
1519: 9461+17	9AE7  CD7597  	        CALL    CPDEHL          ; Is string literal in program?
1520: 9478+10	9AEA  D1      	        POP     DE              ; Restore address of string
1521: 9488+10	9AEB  D2009B  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1522: 9498+10	9AEE  2104B1  	        LD      HL,TMPSTR       ; Temporary string pool
1523: 9508+17	9AF1  CD7597  	        CALL    CPDEHL          ; Is string in temporary pool?
1524: 9525+10	9AF4  D2009B  	        JP      NC,MVSTPT       ; No - Set up pointer
1525:     -	9AF7  3E      	        .BYTE   3EH             ; Skip "POP DE"
1526: 9535+10	9AF8  D1      	CRESTR: POP     DE              ; Restore address of string
1527: 9545+17	9AF9  CDAFA3  	        CALL    BAKTMP          ; Back to last tmp-str entry
1528: 9562+4	9AFC  EB      	        EX      DE,HL           ; Address of string entry
1529: 9566+17	9AFD  CDE8A1  	        CALL    SAVSTR          ; Save string in string area
1530: 9583+17	9B00  CDAFA3  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1531: 9600+10	9B03  E1      	        POP     HL              ; Get string pointer
1532: 9610+17	9B04  CDB2A7  	        CALL    DETHL4          ; Move string pointer to var
1533: 9627+10	9B07  E1      	        POP     HL              ; Restore code string address
1534: 9637+10	9B08  C9      	        RET
1535:				
1536: 9647+11	9B09  E5      	LETNUM: PUSH    HL              ; Save address of variable
1537: 9658+17	9B0A  CDAFA7  	        CALL    FPTHL           ; Move value to variable
1538: 9675+10	9B0D  D1      	        POP     DE              ; Restore address of variable
1539: 9685+10	9B0E  E1      	        POP     HL              ; Restore code string address
1540: 9695+10	9B0F  C9      	        RET
1541:				
1542: 9705+17	9B10  CDD6A4  	ON:     CALL    GETINT          ; Get integer 0-255
1543: 9722+7	9B13  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1544: 9729+4	9B14  47      	        LD      B,A             ; Save in B
1545: 9733+7	9B15  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1546: 9740+10	9B17  CA1F9B  	        JP      Z,ONGO          ; Yes - Find line number
1547: 9750+17	9B1A  CD7B97  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1548:     -	9B1D  88      	        .BYTE   ZGOTO           ; "GOTO" token
1549: 9767+6	9B1E  2B      	        DEC     HL              ; Cancel increment
1550: 9773+4	9B1F  4B      	ONGO:   LD      C,E             ; Integer of branch value
1551: 9777+4	9B20  0D      	ONGOLP: DEC     C               ; Count branches
1552: 9781+4	9B21  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1553: 9785+10	9B22  CAED98  	        JP      Z,ONJMP         ; Go to that line if right one
1554: 9795+17	9B25  CDD599  	        CALL    GETLN           ; Get line number to DE
1555: 9812+7	9B28  FE2C    	        CP      ','             ; Another line number?
1556: 9819+5+6	9B2A  C0      	        RET     NZ              ; No - Drop through
1557: 9824+10	9B2B  C3209B  	        JP      ONGOLP          ; Yes - loop
1558:				
1559: 9834+17	9B2E  CD879D  	IF:     CALL    EVAL            ; Evaluate expression
1560: 9851+7	9B31  7E      	        LD      A,(HL)          ; Get token
1561: 9858+7	9B32  FE88    	        CP      ZGOTO           ; "GOTO" token?
1562: 9865+10	9B34  CA3C9B  	        JP      Z,IFGO          ; Yes - Get line
1563: 9875+17	9B37  CD7B97  	        CALL    CHKSYN          ; Make sure it's "THEN"
1564:     -	9B3A  A9      	        .BYTE      ZTHEN           ; "THEN" token
1565: 9892+6	9B3B  2B      	        DEC     HL              ; Cancel increment
1566: 9898+17	9B3C  CD789D  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1567: 9915+17	9B3F  CD57A7  	        CALL    TSTSGN          ; Test state of expression
1568: 9932+10	9B42  CAA19A  	        JP      Z,REM           ; False - Drop through
1569: 9942+17	9B45  CD0599  	        CALL    GETCHR          ; Get next character
1570: 9959+10	9B48  DA5C9A  	        JP      C,GOTO          ; Number - GOTO that line
1571: 9969+10	9B4B  C3EC98  	        JP      IFJMP           ; Otherwise do statement
1572:				
1573: 9979+6	9B4E  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1574: 9985+17	9B4F  CD0599  	        CALL    GETCHR          ; Get next character
1575:10002+10	9B52  CAB09B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1576:10012+5+6	9B55  C8      	PRNTLP: RET     Z               ; End of list - Exit
1577:10017+7	9B56  FEA5    	        CP      ZTAB            ; "TAB(" token?
1578:10024+10	9B58  CAE39B  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1579:10034+7	9B5B  FEA8    	        CP      ZSPC            ; "SPC(" token?
1580:10041+10	9B5D  CAE39B  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1581:10051+11	9B60  E5      	        PUSH    HL              ; Save code string address
1582:10062+7	9B61  FE2C    	        CP      ','             ; Comma?
1583:10069+10	9B63  CACC9B  	        JP      Z,DOCOM         ; Yes - Move to next zone
1584:10079+7	9B66  FE3B    	        CP      59 ;";"         ; Semi-colon?
1585:10086+10	9B68  CA069C  	        JP      Z,NEXITM        ; Do semi-colon routine
1586:10096+10	9B6B  C1      	        POP     BC              ; Code string address to BC
1587:10106+17	9B6C  CD879D  	        CALL    EVAL            ; Evaluate expression
1588:10123+11	9B6F  E5      	        PUSH    HL              ; Save code string address
1589:10134+13	9B70  3AF2B0  	        LD      A,(TYPE)        ; Get variable type
1590:10147+4	9B73  B7      	        OR      A               ; Is it a string variable?
1591:10151+10	9B74  C29C9B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1592:10161+17	9B77  CDFCA8  	        CALL    NUMASC          ; Convert number to text
1593:10178+17	9B7A  CD0CA2  	        CALL    CRTST           ; Create temporary string
1594:10195+10	9B7D  3620    	        LD      (HL),' '        ; Followed by a space
1595:10205+16	9B7F  2A29B1  	        LD      HL,(FPREG)      ; Get length of output
1596:10221+11	9B82  34      	        INC     (HL)            ; Plus 1 for the space
1597:10232+16	9B83  2A29B1  	        LD      HL,(FPREG)      ; < Not needed >
1598:10248+13	9B86  3A87B0  	        LD      A,(LWIDTH)      ; Get width of line
1599:10261+4	9B89  47      	        LD      B,A             ; To B
1600:10265+4	9B8A  04      	        INC     B               ; Width 255 (No limit)?
1601:10269+10	9B8B  CA989B  	        JP      Z,PRNTNB        ; Yes - Output number string
1602:10279+4	9B8E  04      	        INC     B               ; Adjust it
1603:10283+13	9B8F  3AF0B0  	        LD      A,(CURPOS)      ; Get cursor position
1604:10296+7	9B92  86      	        ADD     A,(HL)          ; Add length of string
1605:10303+4	9B93  3D      	        DEC     A               ; Adjust it
1606:10307+4	9B94  B8      	        CP      B               ; Will output fit on this line?
1607:10311+10+7	9B95  D4B09B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1608:10321+17	9B98  CD51A2  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1609:10338+4	9B9B  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1610:10342+10+7	9B9C  C451A2  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1611:10352+10	9B9F  E1      	        POP     HL              ; Restore code string address
1612:10362+10	9BA0  C34E9B  	        JP      MRPRNT          ; See if more to PRINT
1613:				
1614:10372+13	9BA3  3AF0B0  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1615:10385+4	9BA6  B7      	        OR      A               ; Already at start?
1616:10389+5+6	9BA7  C8      	        RET     Z               ; Yes - Do nothing
1617:10394+10	9BA8  C3B09B  	        JP      PRNTCRLF        ; Start a new line
1618:				
1619:10404+10	9BAB  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1620:10414+10	9BAD  21A5B0  	        LD      HL,BUFFER-1     ; Point to buffer
1621:10424+7	9BB0  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1622:10431+17	9BB2  CD8697  	        CALL    OUTC            ; Output character
1623:10448+7	9BB5  3E0A    	        LD      A,LF            ; Load a LF
1624:10455+17	9BB7  CD8697  	        CALL    OUTC            ; Output character
1625:10472+4	9BBA  AF      	DONULL: XOR     A               ; Set to position 0
1626:10476+13	9BBB  32F0B0  	        LD      (CURPOS),A      ; Store it
1627:10489+13	9BBE  3A86B0  	        LD      A,(NULLS)       ; Get number of nulls
1628:10502+4	9BC1  3D      	NULLP:  DEC     A               ; Count them
1629:10506+5+6	9BC2  C8      	        RET     Z               ; Return if done
1630:10511+11	9BC3  F5      	        PUSH    AF              ; Save count
1631:10522+4	9BC4  AF      	        XOR     A               ; Load a null
1632:10526+17	9BC5  CD8697  	        CALL    OUTC            ; Output it
1633:10543+10	9BC8  F1      	        POP     AF              ; Restore count
1634:10553+10	9BC9  C3C19B  	        JP      NULLP           ; Keep counting
1635:				
1636:10563+13	9BCC  3A88B0  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1637:10576+4	9BCF  47      	        LD      B,A             ; Save in B
1638:10580+13	9BD0  3AF0B0  	        LD      A,(CURPOS)      ; Get current position
1639:10593+4	9BD3  B8      	        CP      B               ; Within the limit?
1640:10597+10+7	9BD4  D4B09B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1641:10607+10	9BD7  D2069C  	        JP      NC,NEXITM       ; Get next item
1642:10617+7	9BDA  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1643:10624+10	9BDC  D2DA9B  	        JP      NC,ZONELP       ; Repeat if more zones
1644:10634+4	9BDF  2F      	        CPL                     ; Number of spaces to output
1645:10638+10	9BE0  C3FB9B  	        JP      ASPCS           ; Output them
1646:				
1647:10648+11	9BE3  F5      	DOTAB:  PUSH    AF              ; Save token
1648:10659+17	9BE4  CDD3A4  	        CALL    FNDNUM          ; Evaluate expression
1649:10676+17	9BE7  CD7B97  	        CALL    CHKSYN          ; Make sure ")" follows
1650:     -	9BEA  29      	        .BYTE   ")"
1651:10693+6	9BEB  2B      	        DEC     HL              ; Back space on to ")"
1652:10699+10	9BEC  F1      	        POP     AF              ; Restore token
1653:10709+7	9BED  D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
1654:10716+11	9BEF  E5      	        PUSH    HL              ; Save code string address
1655:10727+10	9BF0  CAF69B  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1656:10737+13	9BF3  3AF0B0  	        LD      A,(CURPOS)      ; Get current position
1657:10750+4	9BF6  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1658:10754+4	9BF7  83      	        ADD     A,E             ; Total number to print
1659:10758+10	9BF8  D2069C  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1660:10768+4	9BFB  3C      	ASPCS:  INC     A               ; Output A spaces
1661:10772+4	9BFC  47      	        LD      B,A             ; Save number to print
1662:10776+7	9BFD  3E20    	        LD      A,' '           ; Space
1663:10783+17	9BFF  CD8697  	SPCLP:  CALL    OUTC            ; Output character in A
1664:10800+4	9C02  05      	        DEC     B               ; Count them
1665:10804+10	9C03  C2FF9B  	        JP      NZ,SPCLP        ; Repeat if more
1666:10814+10	9C06  E1      	NEXITM: POP     HL              ; Restore code string address
1667:10824+17	9C07  CD0599  	        CALL    GETCHR          ; Get next character
1668:10841+10	9C0A  C3559B  	        JP      PRNTLP          ; More to print
1669:				
1670:     -	9C0D  3F526564	REDO:   .BYTE   "?Redo from start",CR,LF,0
	              6F206672
	              6F6D2073
	              74617274
	              0D0A00
1671:				
1672:10851+13	9C20  3A12B1  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1673:10864+4	9C23  B7      	        OR      A
1674:10868+10	9C24  C2A794  	        JP      NZ,DATSNR       ; READ - ?SN Error
1675:10878+10	9C27  C1      	        POP     BC              ; Throw away code string addr
1676:10888+10	9C28  210D9C  	        LD      HL,REDO         ; "Redo from start" message
1677:10898+17	9C2B  CD4EA2  	        CALL    PRS             ; Output string
1678:10915+10	9C2E  C3F895  	        JP      DOAGN           ; Do last INPUT again
1679:				
1680:10925+17	9C31  CDB9A1  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1681:10942+7	9C34  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1682:10949+7	9C35  FE22    	        CP      '"'             ; Is there a prompt string?
1683:10956+7	9C37  3E00    	        LD      A,0             ; Clear A and leave flags
1684:10963+13	9C39  328AB0  	        LD      (CTLOFG),A      ; Enable output
1685:10976+10	9C3C  C24B9C  	        JP      NZ,NOPMPT       ; No prompt - get input
1686:10986+17	9C3F  CD0DA2  	        CALL    QTSTR           ; Get string terminated by '"'
1687:11003+17	9C42  CD7B97  	        CALL    CHKSYN          ; Check for ';' after prompt
1688:     -	9C45  3B      	        .BYTE   ';'
1689:11020+11	9C46  E5      	        PUSH    HL              ; Save code string address
1690:11031+17	9C47  CD51A2  	        CALL    PRS1            ; Output prompt string
1691:     -	9C4A  3E      	        .BYTE   3EH             ; Skip "PUSH HL"
1692:11048+11	9C4B  E5      	NOPMPT: PUSH    HL              ; Save code string address
1693:11059+17	9C4C  CDFC95  	        CALL    PROMPT          ; Get input with "? " prompt
1694:11076+10	9C4F  C1      	        POP     BC              ; Restore code string address
1695:11086+10	9C50  DA5799  	        JP      C,INPBRK        ; Break pressed - Exit
1696:11096+6	9C53  23      	        INC     HL              ; Next byte
1697:11102+7	9C54  7E      	        LD      A,(HL)          ; Get it
1698:11109+4	9C55  B7      	        OR      A               ; End of line?
1699:11113+6	9C56  2B      	        DEC     HL              ; Back again
1700:11119+11	9C57  C5      	        PUSH    BC              ; Re-save code string address
1701:11130+10	9C58  CA9E9A  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1702:11140+10	9C5B  362C    	        LD      (HL),','        ; Store comma as separator
1703:11150+10	9C5D  C3659C  	        JP      NXTITM          ; Get next item
1704:				
1705:11160+11	9C60  E5      	READ:   PUSH    HL              ; Save code string address
1706:11171+16	9C61  2A21B1  	        LD      HL,(NXTDAT)     ; Next DATA statement
1707:     -	9C64  F6      	        .BYTE   0F6H            ; Flag "READ"
1708:11187+4	9C65  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1709:11191+13	9C66  3212B1  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1710:11204+19	9C69  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1711:11223+10	9C6A  C3719C  	        JP      GTVLUS          ; Get values
1712:				
1713:11233+17	9C6D  CD7B97  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1714:     -	9C70  2C      	        .BYTE      ','
1715:11250+17	9C71  CD6B9F  	GTVLUS: CALL    GETVAR          ; Get variable name
1716:11267+19	9C74  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1717:11286+11	9C75  D5      	        PUSH    DE              ; Save variable address
1718:11297+7	9C76  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1719:11304+7	9C77  FE2C    	        CP      ','             ; Comma?
1720:11311+10	9C79  CA999C  	        JP      Z,ANTVLU        ; Yes - Get another value
1721:11321+13	9C7C  3A12B1  	        LD      A,(READFG)      ; Is it READ?
1722:11334+4	9C7F  B7      	        OR      A
1723:11338+10	9C80  C2069D  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1724:11348+7	9C83  3E3F    	        LD      A,'?'           ; More INPUT needed
1725:11355+17	9C85  CD8697  	        CALL    OUTC            ; Output character
1726:11372+17	9C88  CDFC95  	        CALL    PROMPT          ; Get INPUT with prompt
1727:11389+10	9C8B  D1      	        POP     DE              ; Variable address
1728:11399+10	9C8C  C1      	        POP     BC              ; Code string address
1729:11409+10	9C8D  DA5799  	        JP      C,INPBRK        ; Break pressed
1730:11419+6	9C90  23      	        INC     HL              ; Point to next DATA byte
1731:11425+7	9C91  7E      	        LD      A,(HL)          ; Get byte
1732:11432+4	9C92  B7      	        OR      A               ; Is it zero (No input) ?
1733:11436+6	9C93  2B      	        DEC     HL              ; Back space INPUT pointer
1734:11442+11	9C94  C5      	        PUSH    BC              ; Save code string address
1735:11453+10	9C95  CA9E9A  	        JP      Z,NXTDTA        ; Find end of buffer
1736:11463+11	9C98  D5      	        PUSH    DE              ; Save variable address
1737:11474+13	9C99  3AF2B0  	ANTVLU: LD      A,(TYPE)        ; Check data type
1738:11487+4	9C9C  B7      	        OR      A               ; Is it numeric?
1739:11491+10	9C9D  CAC39C  	        JP      Z,INPBIN        ; Yes - Convert to binary
1740:11501+17	9CA0  CD0599  	        CALL    GETCHR          ; Get next character
1741:11518+4	9CA3  57      	        LD      D,A             ; Save input character
1742:11522+4	9CA4  47      	        LD      B,A             ; Again
1743:11526+7	9CA5  FE22    	        CP      '"'             ; Start of literal sting?
1744:11533+10	9CA7  CAB79C  	        JP      Z,STRENT        ; Yes - Create string entry
1745:11543+13	9CAA  3A12B1  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1746:11556+4	9CAD  B7      	        OR      A
1747:11560+4	9CAE  57      	        LD      D,A             ; Save 00 if "INPUT"
1748:11564+10	9CAF  CAB49C  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1749:11574+7	9CB2  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1750:11581+7	9CB4  062C    	ITMSEP: LD      B,','           ; Item separator
1751:11588+6	9CB6  2B      	        DEC     HL              ; Back space for DTSTR
1752:11594+17	9CB7  CD10A2  	STRENT: CALL    DTSTR           ; Get string terminated by D
1753:11611+4	9CBA  EB      	        EX      DE,HL           ; String address to DE
1754:11615+10	9CBB  21CE9C  	        LD      HL,LTSTND       ; Where to go after LETSTR
1755:11625+19	9CBE  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1756:11644+11	9CBF  D5      	        PUSH    DE              ; Save address of string
1757:11655+10	9CC0  C3D19A  	        JP      LETSTR          ; Assign string to variable
1758:				
1759:11665+17	9CC3  CD0599  	INPBIN: CALL    GETCHR          ; Get next character
1760:11682+17	9CC6  CD5EA8  	        CALL    ASCTFP          ; Convert ASCII to FP number
1761:11699+19	9CC9  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1762:11718+17	9CCA  CDAFA7  	        CALL    FPTHL           ; Move FPREG to variable
1763:11735+10	9CCD  E1      	        POP     HL              ; Restore input pointer
1764:11745+6	9CCE  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1765:11751+17	9CCF  CD0599  	        CALL    GETCHR          ; Get next character
1766:11768+10	9CD2  CADA9C  	        JP      Z,MORDT         ; End of line - More needed?
1767:11778+7	9CD5  FE2C    	        CP      ','             ; Another value?
1768:11785+10	9CD7  C2209C  	        JP      NZ,BADINP       ; No - Bad input
1769:11795+19	9CDA  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1770:11814+6	9CDB  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1771:11820+17	9CDC  CD0599  	        CALL    GETCHR          ; Get next character
1772:11837+10	9CDF  C26D9C  	        JP      NZ,NEDMOR       ; More needed - Get it
1773:11847+10	9CE2  D1      	        POP     DE              ; Restore DATA pointer
1774:11857+13	9CE3  3A12B1  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1775:11870+4	9CE6  B7      	        OR      A
1776:11874+4	9CE7  EB      	        EX      DE,HL           ; DATA pointer to HL
1777:11878+10	9CE8  C22B99  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1778:11888+11	9CEB  D5      	        PUSH    DE              ; Save code string address
1779:11899+7	9CEC  B6      	        OR      (HL)            ; More input given?
1780:11906+10	9CED  21F59C  	        LD      HL,EXTIG        ; "?Extra ignored" message
1781:11916+10+7	9CF0  C44EA2  	        CALL    NZ,PRS          ; Output string if extra given
1782:11926+10	9CF3  E1      	        POP     HL              ; Restore code string address
1783:11936+10	9CF4  C9      	        RET
1784:				
1785:     -	9CF5  3F457874	EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
	              72612069
	              676E6F72
	              65640D0A
	              00
1786:				
1787:11946+17	9D06  CD9F9A  	FDTLP:  CALL    DATA            ; Get next statement
1788:11963+4	9D09  B7      	        OR      A               ; End of line?
1789:11967+10	9D0A  C21F9D  	        JP      NZ,FANDT        ; No - See if DATA statement
1790:11977+6	9D0D  23      	        INC     HL
1791:11983+7	9D0E  7E      	        LD      A,(HL)          ; End of program?
1792:11990+6	9D0F  23      	        INC     HL
1793:11996+7	9D10  B6      	        OR      (HL)            ; 00 00 Ends program
1794:12003+7	9D11  1E06    	        LD      E,OD            ; ?OD Error
1795:12010+10	9D13  CAC194  	        JP      Z,ERROR         ; Yes - Out of DATA
1796:12020+6	9D16  23      	        INC     HL
1797:12026+7	9D17  5E      	        LD      E,(HL)          ; LSB of line number
1798:12033+6	9D18  23      	        INC     HL
1799:12039+7	9D19  56      	        LD      D,(HL)          ; MSB of line number
1800:12046+4	9D1A  EB      	        EX      DE,HL
1801:12050+16	9D1B  220EB1  	        LD      (DATLIN),HL     ; Set line of current DATA item
1802:12066+4	9D1E  EB      	        EX      DE,HL
1803:12070+17	9D1F  CD0599  	FANDT:  CALL    GETCHR          ; Get next character
1804:12087+7	9D22  FE83    	        CP      ZDATA           ; "DATA" token
1805:12094+10	9D24  C2069D  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1806:12104+10	9D27  C3999C  	        JP      ANTVLU          ; Found - Convert input
1807:				
1808:12114+10	9D2A  110000  	NEXT:   LD      DE,0            ; In case no index given
1809:12124+10+7	9D2D  C46B9F  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1810:12134+16	9D30  2213B1  	        LD      (BRKLIN),HL     ; Save code string address
1811:12150+17	9D33  CD5694  	        CALL    BAKSTK          ; Look for "FOR" block
1812:12167+10	9D36  C2B394  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1813:12177+6	9D39  F9      	        LD      SP,HL           ; Clear nested loops
1814:12183+11	9D3A  D5      	        PUSH    DE              ; Save index address
1815:12194+7	9D3B  7E      	        LD      A,(HL)          ; Get sign of STEP
1816:12201+6	9D3C  23      	        INC     HL
1817:12207+11	9D3D  F5      	        PUSH    AF              ; Save sign of STEP
1818:12218+11	9D3E  D5      	        PUSH    DE              ; Save index address
1819:12229+17	9D3F  CD95A7  	        CALL    PHLTFP          ; Move index value to FPREG
1820:12246+19	9D42  E3      	        EX      (SP),HL         ; Save address of TO value
1821:12265+11	9D43  E5      	        PUSH    HL              ; Save address of index
1822:12276+17	9D44  CD02A5  	        CALL    ADDPHL          ; Add STEP to index value
1823:12293+10	9D47  E1      	        POP     HL              ; Restore address of index
1824:12303+17	9D48  CDAFA7  	        CALL    FPTHL           ; Move value to index variable
1825:12320+10	9D4B  E1      	        POP     HL              ; Restore address of TO value
1826:12330+17	9D4C  CDA6A7  	        CALL    LOADFP          ; Move TO value to BCDE
1827:12347+11	9D4F  E5      	        PUSH    HL              ; Save address of line of FOR
1828:12358+17	9D50  CDD2A7  	        CALL    CMPNUM          ; Compare index with TO value
1829:12375+10	9D53  E1      	        POP     HL              ; Restore address of line num
1830:12385+10	9D54  C1      	        POP     BC              ; Address of sign of STEP
1831:12395+4	9D55  90      	        SUB     B               ; Compare with expected sign
1832:12399+17	9D56  CDA6A7  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1833:12416+10	9D59  CA659D  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1834:12426+4	9D5C  EB      	        EX      DE,HL           ; Loop statement line number
1835:12430+16	9D5D  22A1B0  	        LD      (LINEAT),HL     ; Set loop line number
1836:12446+4	9D60  69      	        LD      L,C             ; Set code string to loop
1837:12450+4	9D61  60      	        LD      H,B
1838:12454+10	9D62  C3C198  	        JP      PUTFID          ; Put back "FOR" and continue
1839:				
1840:12464+6	9D65  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1841:12470+16	9D66  2A13B1  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1842:12486+7	9D69  7E      	        LD      A,(HL)          ; Get next byte in code string
1843:12493+7	9D6A  FE2C    	        CP      ','             ; More NEXTs ?
1844:12500+10	9D6C  C2C598  	        JP      NZ,RUNCNT       ; No - Do next statement
1845:12510+17	9D6F  CD0599  	        CALL    GETCHR          ; Position to index name
1846:12527+17	9D72  CD2D9D  	        CALL    NEXT1           ; Re-enter NEXT routine
1847:				; < will not RETurn to here , Exit to RUNCNT or Loop >
1848:				
1849:12544+17	9D75  CD879D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1850:     -	9D78  F6      	TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1851:12561+4	9D79  37      	TSTSTR: SCF                     ; Set carry (string)
1852:12565+13	9D7A  3AF2B0  	CHKTYP: LD      A,(TYPE)        ; Check types match
1853:12578+4	9D7D  8F      	        ADC     A,A             ; Expected + actual
1854:12582+4	9D7E  B7      	        OR      A               ; Clear carry , set parity
1855:12586+5+6	9D7F  E8      	        RET     PE              ; Even parity - Types match
1856:12591+10	9D80  C3BF94  	        JP      TMERR           ; Different types - Error
1857:				
1858:12601+17	9D83  CD7B97  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1859:     -	9D86  28      	        .BYTE   "("
1860:12618+6	9D87  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1861:12624+7	9D88  1600    	        LD      D,0             ; Precedence value
1862:12631+11	9D8A  D5      	EVAL1:  PUSH    DE              ; Save precedence
1863:12642+7	9D8B  0E01    	        LD      C,1
1864:12649+17	9D8D  CD8A94  	        CALL    CHKSTK          ; Check for 1 level of stack
1865:12666+17	9D90  CDFE9D  	        CALL    OPRND           ; Get next expression value
1866:12683+16	9D93  2215B1  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1867:12699+16	9D96  2A15B1  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1868:12715+10	9D99  C1      	        POP     BC              ; Precedence value and operator
1869:12725+4	9D9A  78      	        LD      A,B             ; Get precedence value
1870:12729+7	9D9B  FE78    	        CP      78H             ; "AND" or "OR" ?
1871:12736+10+7	9D9D  D4789D  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1872:12746+7	9DA0  7E      	        LD      A,(HL)          ; Get next operator / function
1873:12753+7	9DA1  1600    	        LD      D,0             ; Clear Last relation
1874:12760+7	9DA3  D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
1875:12767+10	9DA5  DABF9D  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1876:12777+7	9DA8  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1877:12784+10	9DAA  D2BF9D  	        JP      NC,FOPRND       ; Function - Call it
1878:12794+7	9DAD  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1879:12801+4	9DAF  17      	        RLA                     ; <- Test for legal
1880:12805+4	9DB0  AA      	        XOR     D               ; <- combinations of < = >
1881:12809+4	9DB1  BA      	        CP      D               ; <- by combining last token
1882:12813+4	9DB2  57      	        LD      D,A             ; <- with current one
1883:12817+10	9DB3  DAAD94  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1884:12827+16	9DB6  220AB1  	        LD      (CUROPR),HL     ; Save address of current token
1885:12843+17	9DB9  CD0599  	        CALL    GETCHR          ; Get next character
1886:12860+10	9DBC  C3A39D  	        JP      RLTLP           ; Treat the two as one
1887:				
1888:12870+4	9DBF  7A      	FOPRND: LD      A,D             ; < = > found ?
1889:12874+4	9DC0  B7      	        OR      A
1890:12878+10	9DC1  C2E69E  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1891:12888+7	9DC4  7E      	        LD      A,(HL)          ; Get operator token
1892:12895+16	9DC5  220AB1  	        LD      (CUROPR),HL     ; Save operator address
1893:12911+7	9DC8  D6AC    	        SUB     ZPLUS           ; Operator or function?
1894:12918+5+6	9DCA  D8      	        RET     C               ; Neither - Exit
1895:12923+7	9DCB  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1896:12930+5+6	9DCD  D0      	        RET     NC              ; No - Exit
1897:12935+4	9DCE  5F      	        LD      E,A             ; Coded operator
1898:12939+13	9DCF  3AF2B0  	        LD      A,(TYPE)        ; Get data type
1899:12952+4	9DD2  3D      	        DEC     A               ; FF = numeric , 00 = string
1900:12956+4	9DD3  B3      	        OR      E               ; Combine with coded operator
1901:12960+4	9DD4  7B      	        LD      A,E             ; Get coded operator
1902:12964+10	9DD5  CA44A3  	        JP      Z,CONCAT        ; String concatenation
1903:12974+4	9DD8  07      	        RLCA                    ; Times 2
1904:12978+4	9DD9  83      	        ADD     A,E             ; Times 3
1905:12982+4	9DDA  5F      	        LD      E,A             ; To DE (D is 0)
1906:12986+10	9DDB  219F93  	        LD      HL,PRITAB       ; Precedence table
1907:12996+11	9DDE  19      	        ADD     HL,DE           ; To the operator concerned
1908:13007+4	9DDF  78      	        LD      A,B             ; Last operator precedence
1909:13011+7	9DE0  56      	        LD      D,(HL)          ; Get evaluation precedence
1910:13018+4	9DE1  BA      	        CP      D               ; Compare with eval precedence
1911:13022+5+6	9DE2  D0      	        RET     NC              ; Exit if higher precedence
1912:13027+6	9DE3  23      	        INC     HL              ; Point to routine address
1913:13033+17	9DE4  CD789D  	        CALL    TSTNUM          ; Make sure it's a number
1914:				
1915:13050+11	9DE7  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1916:13061+10	9DE8  01969D  	        LD      BC,EVAL3        ; Where to go on prec' break
1917:13071+11	9DEB  C5      	        PUSH    BC              ; Save on stack for return
1918:13082+4	9DEC  43      	        LD      B,E             ; Save operator
1919:13086+4	9DED  4A      	        LD      C,D             ; Save precedence
1920:13090+17	9DEE  CD88A7  	        CALL    STAKFP          ; Move value to stack
1921:13107+4	9DF1  58      	        LD      E,B             ; Restore operator
1922:13111+4	9DF2  51      	        LD      D,C             ; Restore precedence
1923:13115+7	9DF3  4E      	        LD      C,(HL)          ; Get LSB of routine address
1924:13122+6	9DF4  23      	        INC     HL
1925:13128+7	9DF5  46      	        LD      B,(HL)          ; Get MSB of routine address
1926:13135+6	9DF6  23      	        INC     HL
1927:13141+11	9DF7  C5      	        PUSH    BC              ; Save routine address
1928:13152+16	9DF8  2A0AB1  	        LD      HL,(CUROPR)     ; Address of current operator
1929:13168+10	9DFB  C38A9D  	        JP      EVAL1           ; Loop until prec' break
1930:				
1931:13178+4	9DFE  AF      	OPRND:  XOR     A               ; Get operand routine
1932:13182+13	9DFF  32F2B0  	        LD      (TYPE),A        ; Set numeric expected
1933:13195+17	9E02  CD0599  	        CALL    GETCHR          ; Get next character
1934:13212+7	9E05  1E24    	        LD      E,MO            ; ?MO Error
1935:13219+10	9E07  CAC194  	        JP      Z,ERROR         ; No operand - Error
1936:13229+10	9E0A  DA5EA8  	        JP      C,ASCTFP        ; Number - Get value
1937:13239+17	9E0D  CDA699  	        CALL    CHKLTR          ; See if a letter
1938:13256+10	9E10  D2659E  	        JP      NC,CONVAR       ; Letter - Find variable
1939:13266+7	9E13  FE26    	        CP		'&'				; &H = HEX, &B = BINARY
1940:13273+7+5	9E15  2012    	        JR		NZ, NOTAMP
1941:13280+17	9E17  CD0599  	        CALL    GETCHR          ; Get next character
1942:13297+7	9E1A  FE48    	        CP      'H'             ; Hex number indicated? [function added]
1943:13304+10	9E1C  CAA4AC  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
1944:13314+7	9E1F  FE42    	        CP      'B'             ; Binary number indicated? [function added]
1945:13321+10	9E21  CA14AD  	        JP      Z,BINTFP        ; Convert Bin to FPREG
1946:13331+7	9E24  1E02    	        LD      E,SN            ; If neither then a ?SN Error
1947:13338+10	9E26  CAC194  	        JP      Z,ERROR         ; 
1948:13348+7	9E29  FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
1949:13355+10	9E2B  CAFE9D  	        JP      Z,OPRND         ; Yes - Look for operand
1950:13365+7	9E2E  FE2E    	        CP      '.'             ; '.' ?
1951:13372+10	9E30  CA5EA8  	        JP      Z,ASCTFP        ; Yes - Create FP number
1952:13382+7	9E33  FEAD    	        CP      ZMINUS          ; '-' Token ?
1953:13389+10	9E35  CA549E  	        JP      Z,MINUS         ; Yes - Do minus
1954:13399+7	9E38  FE22    	        CP      '"'             ; Literal string ?
1955:13406+10	9E3A  CA0DA2  	        JP      Z,QTSTR         ; Get string terminated by '"'
1956:13416+7	9E3D  FEAA    	        CP      ZNOT            ; "NOT" Token ?
1957:13423+10	9E3F  CA469F  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
1958:13433+7	9E42  FEA7    	        CP      ZFN             ; "FN" Token ?
1959:13440+10	9E44  CA71A1  	        JP      Z,DOFN          ; Yes - Do FN routine
1960:13450+7	9E47  D6B6    	        SUB     ZSGN            ; Is it a function?
1961:13457+10	9E49  D2769E  	        JP      NC,FNOFST       ; Yes - Evaluate function
1962:13467+17	9E4C  CD839D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1963:13484+17	9E4F  CD7B97  	        CALL    CHKSYN          ; Make sure ")" follows
1964:     -	9E52  29      	        .BYTE   ")"
1965:13501+10	9E53  C9      	        RET
1966:				
1967:13511+7	9E54  167D    	MINUS:  LD      D,7DH           ; '-' precedence
1968:13518+17	9E56  CD8A9D  	        CALL    EVAL1           ; Evaluate until prec' break
1969:13535+16	9E59  2A15B1  	        LD      HL,(NXTOPR)     ; Get next operator address
1970:13551+11	9E5C  E5      	        PUSH    HL              ; Save next operator address
1971:13562+17	9E5D  CD80A7  	        CALL    INVSGN          ; Negate value
1972:13579+17	9E60  CD789D  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
1973:13596+10	9E63  E1      	        POP     HL              ; Restore next operator address
1974:13606+10	9E64  C9      	        RET
1975:				
1976:13616+17	9E65  CD6B9F  	CONVAR: CALL    GETVAR          ; Get variable address to DE
1977:13633+11	9E68  E5      	FRMEVL: PUSH    HL              ; Save code string address
1978:13644+4	9E69  EB      	        EX      DE,HL           ; Variable address to HL
1979:13648+16	9E6A  2229B1  	        LD      (FPREG),HL      ; Save address of variable
1980:13664+13	9E6D  3AF2B0  	        LD      A,(TYPE)        ; Get type
1981:13677+4	9E70  B7      	        OR      A               ; Numeric?
1982:13681+10+7	9E71  CC95A7  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1983:13691+10	9E74  E1      	        POP     HL              ; Restore code string address
1984:13701+10	9E75  C9      	        RET
1985:				
1986:13711+7	9E76  0600    	FNOFST: LD      B,0             ; Get address of function
1987:13718+4	9E78  07      	        RLCA                    ; Double function offset
1988:13722+4	9E79  4F      	        LD      C,A             ; BC = Offset in function table
1989:13726+11	9E7A  C5      	        PUSH    BC              ; Save adjusted token value
1990:13737+17	9E7B  CD0599  	        CALL    GETCHR          ; Get next character
1991:13754+4	9E7E  79      	        LD      A,C             ; Get adjusted token value
1992:13758+7	9E7F  FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1993:13765+10	9E81  DA9D9E  	        JP      C,FNVAL         ; No - Do function
1994:13775+17	9E84  CD839D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
1995:13792+17	9E87  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
1996:     -	9E8A  2C      	        .BYTE      ','
1997:13809+17	9E8B  CD799D  	        CALL    TSTSTR          ; Make sure it's a string
1998:13826+4	9E8E  EB      	        EX      DE,HL           ; Save code string address
1999:13830+16	9E8F  2A29B1  	        LD      HL,(FPREG)      ; Get address of string
2000:13846+19	9E92  E3      	        EX      (SP),HL         ; Save address of string
2001:13865+11	9E93  E5      	        PUSH    HL              ; Save adjusted token value
2002:13876+4	9E94  EB      	        EX      DE,HL           ; Restore code string address
2003:13880+17	9E95  CDD6A4  	        CALL    GETINT          ; Get integer 0-255
2004:13897+4	9E98  EB      	        EX      DE,HL           ; Save code string address
2005:13901+19	9E99  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
2006:13920+10	9E9A  C3A59E  	        JP      GOFUNC          ; Jump to string function
2007:				
2008:13930+17	9E9D  CD4C9E  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
2009:13947+19	9EA0  E3      	        EX      (SP),HL         ; HL = Adjusted token value
2010:13966+10	9EA1  11609E  	        LD      DE,RETNUM       ; Return number from function
2011:13976+11	9EA4  D5      	        PUSH    DE              ; Save on stack
2012:13987+10	9EA5  01FE91  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2013:13997+11	9EA8  09      	        ADD     HL,BC           ; Point to right address
2014:14008+7	9EA9  4E      	        LD      C,(HL)          ; Get LSB of address
2015:14015+6	9EAA  23      	        INC     HL              ;
2016:14021+7	9EAB  66      	        LD      H,(HL)          ; Get MSB of address
2017:14028+4	9EAC  69      	        LD      L,C             ; Address to HL
2018:14032+4	9EAD  E9      	        JP      (HL)            ; Jump to function
2019:				
2020:14036+4	9EAE  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
2021:14040+7	9EAF  FEAD    	        CP      ZMINUS          ; '-' token ?
2022:14047+5+6	9EB1  C8      	        RET     Z               ; Yes - Return
2023:14052+7	9EB2  FE2D    	        CP      '-'             ; '-' ASCII ?
2024:14059+5+6	9EB4  C8      	        RET     Z               ; Yes - Return
2025:14064+4	9EB5  14      	        INC     D               ; Inc to flag positive exponent
2026:14068+7	9EB6  FE2B    	        CP      '+'             ; '+' ASCII ?
2027:14075+5+6	9EB8  C8      	        RET     Z               ; Yes - Return
2028:14080+7	9EB9  FEAC    	        CP      ZPLUS           ; '+' token ?
2029:14087+5+6	9EBB  C8      	        RET     Z               ; Yes - Return
2030:14092+6	9EBC  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2031:14098+10	9EBD  C9      	        RET                     ; Return "NZ"
2032:				
2033:     -	9EBE  F6      	POR:    .BYTE      0F6H            ; Flag "OR"
2034:14108+4	9EBF  AF      	PAND:   XOR     A               ; Flag "AND"
2035:14112+11	9EC0  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2036:14123+17	9EC1  CD789D  	        CALL    TSTNUM          ; Make sure it's a number
2037:14140+17	9EC4  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 32767
2038:14157+10	9EC7  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2039:14167+4	9EC8  EB      	        EX      DE,HL           ; <- Get last
2040:14171+10	9EC9  C1      	        POP     BC              ; <-  value
2041:14181+19	9ECA  E3      	        EX      (SP),HL         ; <-  from
2042:14200+4	9ECB  EB      	        EX      DE,HL           ; <-  stack
2043:14204+17	9ECC  CD98A7  	        CALL    FPBCDE          ; Move last value to FPREG
2044:14221+11	9ECF  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2045:14232+17	9ED0  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 32767
2046:14249+10	9ED3  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2047:14259+10	9ED4  C1      	        POP     BC              ; Get value
2048:14269+4	9ED5  79      	        LD      A,C             ; Get LSB
2049:14273+10	9ED6  212FA1  	        LD      HL,ACPASS       ; Address of save AC as current
2050:14283+10	9ED9  C2E19E  	        JP      NZ,POR1         ; Jump if OR
2051:14293+4	9EDC  A3      	        AND     E               ; "AND" LSBs
2052:14297+4	9EDD  4F      	        LD      C,A             ; Save LSB
2053:14301+4	9EDE  78      	        LD      A,B             ; Get MBS
2054:14305+4	9EDF  A2      	        AND     D               ; "AND" MSBs
2055:14309+4	9EE0  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2056:				
2057:14313+4	9EE1  B3      	POR1:   OR      E               ; "OR" LSBs
2058:14317+4	9EE2  4F      	        LD      C,A             ; Save LSB
2059:14321+4	9EE3  78      	        LD      A,B             ; Get MSB
2060:14325+4	9EE4  B2      	        OR      D               ; "OR" MSBs
2061:14329+4	9EE5  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2062:				
2063:14333+10	9EE6  21F89E  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2064:14343+13	9EE9  3AF2B0  	        LD      A,(TYPE)        ; Get data type
2065:14356+4	9EEC  1F      	        RRA                     ; Carry set = string
2066:14360+4	9EED  7A      	        LD      A,D             ; Get last precedence value
2067:14364+4	9EEE  17      	        RLA                     ; Times 2 plus carry
2068:14368+4	9EEF  5F      	        LD      E,A             ; To E
2069:14372+7	9EF0  1664    	        LD      D,64H           ; Relational precedence
2070:14379+4	9EF2  78      	        LD      A,B             ; Get current precedence
2071:14383+4	9EF3  BA      	        CP      D               ; Compare with last
2072:14387+5+6	9EF4  D0      	        RET     NC              ; Eval if last was rel' or log'
2073:14392+10	9EF5  C3E79D  	        JP      STKTHS          ; Stack this one and get next
2074:				
2075:     -	9EF8  FA9E    	CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2076:14402+4	9EFA  79      	CMPLG1: LD      A,C             ; Get data type
2077:14406+4	9EFB  B7      	        OR      A
2078:14410+4	9EFC  1F      	        RRA
2079:14414+10	9EFD  C1      	        POP     BC              ; Get last expression to BCDE
2080:14424+10	9EFE  D1      	        POP     DE
2081:14434+11	9EFF  F5      	        PUSH    AF              ; Save status
2082:14445+17	9F00  CD7A9D  	        CALL    CHKTYP          ; Check that types match
2083:14462+10	9F03  213C9F  	        LD      HL,CMPRES       ; Result to comparison
2084:14472+11	9F06  E5      	        PUSH    HL              ; Save for RETurn
2085:14483+10	9F07  CAD2A7  	        JP      Z,CMPNUM        ; Compare values if numeric
2086:14493+4	9F0A  AF      	        XOR     A               ; Compare two strings
2087:14497+13	9F0B  32F2B0  	        LD      (TYPE),A        ; Set type to numeric
2088:14510+11	9F0E  D5      	        PUSH    DE              ; Save string name
2089:14521+17	9F0F  CD91A3  	        CALL    GSTRCU          ; Get current string
2090:14538+7	9F12  7E      	        LD      A,(HL)          ; Get length of string
2091:14545+6	9F13  23      	        INC     HL
2092:14551+6	9F14  23      	        INC     HL
2093:14557+7	9F15  4E      	        LD      C,(HL)          ; Get LSB of address
2094:14564+6	9F16  23      	        INC     HL
2095:14570+7	9F17  46      	        LD      B,(HL)          ; Get MSB of address
2096:14577+10	9F18  D1      	        POP     DE              ; Restore string name
2097:14587+11	9F19  C5      	        PUSH    BC              ; Save address of string
2098:14598+11	9F1A  F5      	        PUSH    AF              ; Save length of string
2099:14609+17	9F1B  CD95A3  	        CALL    GSTRDE          ; Get second string
2100:14626+17	9F1E  CDA6A7  	        CALL    LOADFP          ; Get address of second string
2101:14643+10	9F21  F1      	        POP     AF              ; Restore length of string 1
2102:14653+4	9F22  57      	        LD      D,A             ; Length to D
2103:14657+10	9F23  E1      	        POP     HL              ; Restore address of string 1
2104:14667+4	9F24  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2105:14671+4	9F25  B2      	        OR      D               ; Bytes of string 1 to do
2106:14675+5+6	9F26  C8      	        RET     Z               ; Exit if all bytes compared
2107:14680+4	9F27  7A      	        LD      A,D             ; Get bytes of string 1 to do
2108:14684+7	9F28  D601    	        SUB     1
2109:14691+5+6	9F2A  D8      	        RET     C               ; Exit if end of string 1
2110:14696+4	9F2B  AF      	        XOR     A
2111:14700+4	9F2C  BB      	        CP      E               ; Bytes of string 2 to do
2112:14704+4	9F2D  3C      	        INC     A
2113:14708+5+6	9F2E  D0      	        RET     NC              ; Exit if end of string 2
2114:14713+4	9F2F  15      	        DEC     D               ; Count bytes in string 1
2115:14717+4	9F30  1D      	        DEC     E               ; Count bytes in string 2
2116:14721+7	9F31  0A      	        LD      A,(BC)          ; Byte in string 2
2117:14728+7	9F32  BE      	        CP      (HL)            ; Compare to byte in string 1
2118:14735+6	9F33  23      	        INC     HL              ; Move up string 1
2119:14741+6	9F34  03      	        INC     BC              ; Move up string 2
2120:14747+10	9F35  CA249F  	        JP      Z,CMPSTR        ; Same - Try next bytes
2121:14757+4	9F38  3F      	        CCF                     ; Flag difference (">" or "<")
2122:14761+10	9F39  C362A7  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2123:				
2124:14771+4	9F3C  3C      	CMPRES: INC     A               ; Increment current value
2125:14775+4	9F3D  8F      	        ADC     A,A             ; Double plus carry
2126:14779+10	9F3E  C1      	        POP     BC              ; Get other value
2127:14789+4	9F3F  A0      	        AND     B               ; Combine them
2128:14793+7	9F40  C6FF    	        ADD     A,-1            ; Carry set if different
2129:14800+4	9F42  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2130:14804+10	9F43  C369A7  	        JP      FLGREL          ; Set current value & continue
2131:				
2132:14814+7	9F46  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2133:14821+17	9F48  CD8A9D  	        CALL    EVAL1           ; Eval until precedence break
2134:14838+17	9F4B  CD789D  	        CALL    TSTNUM          ; Make sure it's a number
2135:14855+17	9F4E  CDBA99  	        CALL    DEINT           ; Get integer -32768 - 32767
2136:14872+4	9F51  7B      	        LD      A,E             ; Get LSB
2137:14876+4	9F52  2F      	        CPL                     ; Invert LSB
2138:14880+4	9F53  4F      	        LD      C,A             ; Save "NOT" of LSB
2139:14884+4	9F54  7A      	        LD      A,D             ; Get MSB
2140:14888+4	9F55  2F      	        CPL                     ; Invert MSB
2141:14892+17	9F56  CD2FA1  	        CALL    ACPASS          ; Save AC as current
2142:14909+10	9F59  C1      	        POP     BC              ; Clean up stack
2143:14919+10	9F5A  C3969D  	        JP      EVAL3           ; Continue evaluation
2144:				
2145:14929+6	9F5D  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2146:14935+17	9F5E  CD0599  	        CALL    GETCHR          ; Get next character
2147:14952+5+6	9F61  C8      	        RET     Z               ; End of DIM statement
2148:14957+17	9F62  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
2149:     -	9F65  2C      	        .BYTE      ','
2150:14974+10	9F66  015D9F  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2151:14984+11	9F69  C5      	        PUSH    BC              ; Save on stack
2152:     -	9F6A  F6      	        .BYTE      0F6H            ; Flag "Create" variable
2153:14995+4	9F6B  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2154:14999+13	9F6C  32F1B0  	        LD      (LCRFLG),A      ; Set locate / create flag
2155:15012+7	9F6F  46      	        LD      B,(HL)          ; Get First byte of name
2156:15019+17	9F70  CDA699  	GTFNAM: CALL    CHKLTR          ; See if a letter
2157:15036+10	9F73  DAAD94  	        JP      C,SNERR         ; ?SN Error if not a letter
2158:15046+4	9F76  AF      	        XOR     A
2159:15050+4	9F77  4F      	        LD      C,A             ; Clear second byte of name
2160:15054+13	9F78  32F2B0  	        LD      (TYPE),A        ; Set type to numeric
2161:15067+17	9F7B  CD0599  	        CALL    GETCHR          ; Get next character
2162:15084+10	9F7E  DA879F  	        JP      C,SVNAM2        ; Numeric - Save in name
2163:15094+17	9F81  CDA699  	        CALL    CHKLTR          ; See if a letter
2164:15111+10	9F84  DA949F  	        JP      C,CHARTY        ; Not a letter - Check type
2165:15121+4	9F87  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2166:15125+17	9F88  CD0599  	ENDNAM: CALL    GETCHR          ; Get next character
2167:15142+10	9F8B  DA889F  	        JP      C,ENDNAM        ; Numeric - Get another
2168:15152+17	9F8E  CDA699  	        CALL    CHKLTR          ; See if a letter
2169:15169+10	9F91  D2889F  	        JP      NC,ENDNAM       ; Letter - Get another
2170:15179+7	9F94  D624    	CHARTY: SUB     '$'             ; String variable?
2171:15186+10	9F96  C2A39F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2172:15196+4	9F99  3C      	        INC     A               ; A = 1 (string type)
2173:15200+13	9F9A  32F2B0  	        LD      (TYPE),A        ; Set type to string
2174:15213+4	9F9D  0F      	        RRCA                    ; A = 80H , Flag for string
2175:15217+4	9F9E  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2176:15221+4	9F9F  4F      	        LD      C,A             ; Resave second byte on name
2177:15225+17	9FA0  CD0599  	        CALL    GETCHR          ; Get next character
2178:15242+13	9FA3  3A10B1  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2179:15255+4	9FA6  3D      	        DEC     A
2180:15259+10	9FA7  CA50A0  	        JP      Z,ARLDSV        ; Yes - Get array name
2181:15269+10	9FAA  F2B39F  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2182:15279+7	9FAD  7E      	        LD      A,(HL)          ; Get byte again
2183:15286+7	9FAE  D628    	        SUB     '('             ; Subscripted variable?
2184:15293+10	9FB0  CA28A0  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2185:				
2186:15303+4	9FB3  AF      	NSCFOR: XOR     A               ; Simple variable
2187:15307+13	9FB4  3210B1  	        LD      (FORFLG),A      ; Clear "FOR" flag
2188:15320+11	9FB7  E5      	        PUSH    HL              ; Save code string address
2189:15331+4	9FB8  50      	        LD      D,B             ; DE = Variable name to find
2190:15335+4	9FB9  59      	        LD      E,C
2191:15339+16	9FBA  2A23B1  	        LD      HL,(FNRGNM)     ; FN argument name
2192:15355+17	9FBD  CD7597  	        CALL    CPDEHL          ; Is it the FN argument?
2193:15372+10	9FC0  1125B1  	        LD      DE,FNARG        ; Point to argument value
2194:15382+10	9FC3  CA98A6  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2195:15392+16	9FC6  2A1DB1  	        LD      HL,(VAREND)     ; End of variables
2196:15408+4	9FC9  EB      	        EX      DE,HL           ; Address of end of search
2197:15412+16	9FCA  2A1BB1  	        LD      HL,(PROGND)     ; Start of variables address
2198:15428+17	9FCD  CD7597  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2199:15445+10	9FD0  CAE69F  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2200:15455+4	9FD3  79      	        LD      A,C             ; Get second byte of name
2201:15459+7	9FD4  96      	        SUB     (HL)            ; Compare with name in list
2202:15466+6	9FD5  23      	        INC     HL              ; Move on to first byte
2203:15472+10	9FD6  C2DB9F  	        JP      NZ,FNTHR        ; Different - Find another
2204:15482+4	9FD9  78      	        LD      A,B             ; Get first byte of name
2205:15486+7	9FDA  96      	        SUB     (HL)            ; Compare with name in list
2206:15493+6	9FDB  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2207:15499+10	9FDC  CA1AA0  	        JP      Z,RETADR        ; Found - Return address
2208:15509+6	9FDF  23      	        INC     HL              ; <- Skip
2209:15515+6	9FE0  23      	        INC     HL              ; <- over
2210:15521+6	9FE1  23      	        INC     HL              ; <- F.P.
2211:15527+6	9FE2  23      	        INC     HL              ; <- value
2212:15533+10	9FE3  C3CD9F  	        JP      FNDVAR          ; Keep looking
2213:				
2214:15543+10	9FE6  E1      	CFEVAL: POP     HL              ; Restore code string address
2215:15553+19	9FE7  E3      	        EX      (SP),HL         ; Get return address
2216:15572+11	9FE8  D5      	        PUSH    DE              ; Save address of variable
2217:15583+10	9FE9  11689E  	        LD      DE,FRMEVL       ; Return address in EVAL
2218:15593+17	9FEC  CD7597  	        CALL    CPDEHL          ; Called from EVAL ?
2219:15610+10	9FEF  D1      	        POP     DE              ; Restore address of variable
2220:15620+10	9FF0  CA1DA0  	        JP      Z,RETNUL        ; Yes - Return null variable
2221:15630+19	9FF3  E3      	        EX      (SP),HL         ; Put back return
2222:15649+11	9FF4  E5      	        PUSH    HL              ; Save code string address
2223:15660+11	9FF5  C5      	        PUSH    BC              ; Save variable name
2224:15671+10	9FF6  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2225:15681+16	9FF9  2A1FB1  	        LD      HL,(ARREND)     ; End of arrays
2226:15697+11	9FFC  E5      	        PUSH    HL              ; Save end of arrays
2227:15708+11	9FFD  09      	        ADD     HL,BC           ; Move up 6 bytes
2228:15719+10	9FFE  C1      	        POP     BC              ; Source address in BC
2229:15729+11	9FFF  E5      	        PUSH    HL              ; Save new end address
2230:15740+17	A000  CD7994  	        CALL    MOVUP           ; Move arrays up
2231:15757+10	A003  E1      	        POP     HL              ; Restore new end address
2232:15767+16	A004  221FB1  	        LD      (ARREND),HL     ; Set new end address
2233:15783+4	A007  60      	        LD      H,B             ; End of variables to HL
2234:15787+4	A008  69      	        LD      L,C
2235:15791+16	A009  221DB1  	        LD      (VAREND),HL     ; Set new end address
2236:				
2237:15807+6	A00C  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2238:15813+10	A00D  3600    	        LD      (HL),0          ; Zero byte in variable
2239:15823+17	A00F  CD7597  	        CALL    CPDEHL          ; Done them all?
2240:15840+10	A012  C20CA0  	        JP      NZ,ZEROLP       ; No - Keep on going
2241:15850+10	A015  D1      	        POP     DE              ; Get variable name
2242:15860+7	A016  73      	        LD      (HL),E          ; Store second character
2243:15867+6	A017  23      	        INC     HL
2244:15873+7	A018  72      	        LD      (HL),D          ; Store first character
2245:15880+6	A019  23      	        INC     HL
2246:15886+4	A01A  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2247:15890+10	A01B  E1      	        POP     HL              ; Restore code string address
2248:15900+10	A01C  C9      	        RET
2249:				
2250:15910+13	A01D  322CB1  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2251:15923+10	A020  214994  	        LD      HL,ZERBYT       ; Also set a null string
2252:15933+16	A023  2229B1  	        LD      (FPREG),HL      ; Save for EVAL
2253:15949+10	A026  E1      	        POP     HL              ; Restore code string address
2254:15959+10	A027  C9      	        RET
2255:				
2256:15969+11	A028  E5      	SBSCPT: PUSH    HL              ; Save code string address
2257:15980+16	A029  2AF1B0  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2258:15996+19	A02C  E3      	        EX      (SP),HL         ; Save and get code string
2259:16015+4	A02D  57      	        LD      D,A             ; Zero number of dimensions
2260:16019+11	A02E  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2261:16030+11	A02F  C5      	        PUSH    BC              ; Save array name
2262:16041+17	A030  CDAE99  	        CALL    FPSINT          ; Get subscript (0-32767)
2263:16058+10	A033  C1      	        POP     BC              ; Restore array name
2264:16068+10	A034  F1      	        POP     AF              ; Get number of dimensions
2265:16078+4	A035  EB      	        EX      DE,HL
2266:16082+19	A036  E3      	        EX      (SP),HL         ; Save subscript value
2267:16101+11	A037  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2268:16112+4	A038  EB      	        EX      DE,HL
2269:16116+4	A039  3C      	        INC     A               ; Count dimensions
2270:16120+4	A03A  57      	        LD      D,A             ; Save in D
2271:16124+7	A03B  7E      	        LD      A,(HL)          ; Get next byte in code string
2272:16131+7	A03C  FE2C    	        CP      ','             ; Comma (more to come)?
2273:16138+10	A03E  CA2EA0  	        JP      Z,SCPTLP        ; Yes - More subscripts
2274:16148+17	A041  CD7B97  	        CALL    CHKSYN          ; Make sure ")" follows
2275:     -	A044  29      	        .BYTE      ")"
2276:16165+16	A045  2215B1  	        LD      (NXTOPR),HL     ; Save code string address
2277:16181+10	A048  E1      	        POP     HL              ; Get LCRFLG and TYPE
2278:16191+16	A049  22F1B0  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2279:16207+7	A04C  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2280:16214+11	A04E  D5      	        PUSH    DE              ; Save number of dimensions (D)
2281:     -	A04F  11      	        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2282:				
2283:16225+11	A050  E5      	ARLDSV: PUSH    HL              ; Save code string address
2284:16236+11	A051  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2285:16247+16	A052  2A1DB1  	        LD      HL,(VAREND)     ; Start of arrays
2286:     -	A055  3E      	        .BYTE      3EH             ; Skip "ADD HL,DE"
2287:16263+11	A056  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2288:16274+4	A057  EB      	        EX      DE,HL
2289:16278+16	A058  2A1FB1  	        LD      HL,(ARREND)     ; End of arrays
2290:16294+4	A05B  EB      	        EX      DE,HL           ; Current array pointer
2291:16298+17	A05C  CD7597  	        CALL    CPDEHL          ; End of arrays found?
2292:16315+10	A05F  CA88A0  	        JP      Z,CREARY        ; Yes - Create array
2293:16325+7	A062  7E      	        LD      A,(HL)          ; Get second byte of name
2294:16332+4	A063  B9      	        CP      C               ; Compare with name given
2295:16336+6	A064  23      	        INC     HL              ; Move on
2296:16342+10	A065  C26AA0  	        JP      NZ,NXTARY       ; Different - Find next array
2297:16352+7	A068  7E      	        LD      A,(HL)          ; Get first byte of name
2298:16359+4	A069  B8      	        CP      B               ; Compare with name given
2299:16363+6	A06A  23      	NXTARY: INC     HL              ; Move on
2300:16369+7	A06B  5E      	        LD      E,(HL)          ; Get LSB of next array address
2301:16376+6	A06C  23      	        INC     HL
2302:16382+7	A06D  56      	        LD      D,(HL)          ; Get MSB of next array address
2303:16389+6	A06E  23      	        INC     HL
2304:16395+10	A06F  C256A0  	        JP      NZ,FNDARY       ; Not found - Keep looking
2305:16405+13	A072  3AF1B0  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2306:16418+4	A075  B7      	        OR      A
2307:16422+10	A076  C2B694  	        JP      NZ,DDERR        ; Create - ?DD Error
2308:16432+10	A079  F1      	        POP     AF              ; Locate - Get number of dim'ns
2309:16442+4	A07A  44      	        LD      B,H             ; BC Points to array dim'ns
2310:16446+4	A07B  4D      	        LD      C,L
2311:16450+10	A07C  CA98A6  	        JP      Z,POPHRT        ; Jump if array load/save
2312:16460+7	A07F  96      	        SUB     (HL)            ; Same number of dimensions?
2313:16467+10	A080  CAE6A0  	        JP      Z,FINDEL        ; Yes - Find element
2314:16477+7	A083  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2315:16484+10	A085  C3C194  	        JP      ERROR           ; Output error
2316:				
2317:16494+10	A088  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2318:16504+10	A08B  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2319:16514+10	A08C  CACF99  	        JP      Z,FCERR         ; Yes - ?FC Error
2320:16524+7	A08F  71      	        LD      (HL),C          ; Save second byte of name
2321:16531+6	A090  23      	        INC     HL
2322:16537+7	A091  70      	        LD      (HL),B          ; Save first byte of name
2323:16544+6	A092  23      	        INC     HL
2324:16550+4	A093  4F      	        LD      C,A             ; Number of dimensions to C
2325:16554+17	A094  CD8A94  	        CALL    CHKSTK          ; Check if enough memory
2326:16571+6	A097  23      	        INC     HL              ; Point to number of dimensions
2327:16577+6	A098  23      	        INC     HL
2328:16583+16	A099  220AB1  	        LD      (CUROPR),HL     ; Save address of pointer
2329:16599+7	A09C  71      	        LD      (HL),C          ; Set number of dimensions
2330:16606+6	A09D  23      	        INC     HL
2331:16612+13	A09E  3AF1B0  	        LD      A,(LCRFLG)      ; Locate of Create?
2332:16625+4	A0A1  17      	        RLA                     ; Carry set = Create
2333:16629+4	A0A2  79      	        LD      A,C             ; Get number of dimensions
2334:16633+10	A0A3  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2335:16643+10	A0A6  D2ABA0  	        JP      NC,DEFSIZ       ; Locate - Set default size
2336:16653+10	A0A9  C1      	        POP     BC              ; Get specified dimension size
2337:16663+6	A0AA  03      	        INC     BC              ; Include zero element
2338:16669+7	A0AB  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2339:16676+6	A0AC  23      	        INC     HL
2340:16682+7	A0AD  70      	        LD      (HL),B          ; Save MSB of dimension size
2341:16689+6	A0AE  23      	        INC     HL
2342:16695+11	A0AF  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2343:16706+11	A0B0  E5      	        PUSH    HL              ; Save address of dim'n size
2344:16717+17	A0B1  CD43A8  	        CALL    MLDEBC          ; Multiply DE by BC to find
2345:16734+4	A0B4  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2346:16738+10	A0B5  E1      	        POP     HL              ; Restore address of dimension
2347:16748+10	A0B6  F1      	        POP     AF              ; Restore number of dimensions
2348:16758+4	A0B7  3D      	        DEC     A               ; Count them
2349:16762+10	A0B8  C2A3A0  	        JP      NZ,CRARLP       ; Do next dimension if more
2350:16772+11	A0BB  F5      	        PUSH    AF              ; Save locate/create flag
2351:16783+4	A0BC  42      	        LD      B,D             ; MSB of memory needed
2352:16787+4	A0BD  4B      	        LD      C,E             ; LSB of memory needed
2353:16791+4	A0BE  EB      	        EX      DE,HL
2354:16795+11	A0BF  19      	        ADD     HL,DE           ; Add bytes to array start
2355:16806+10	A0C0  DAA294  	        JP      C,OMERR         ; Too big - Error
2356:16816+17	A0C3  CD9394  	        CALL    ENFMEM          ; See if enough memory
2357:16833+16	A0C6  221FB1  	        LD      (ARREND),HL     ; Save new end of array
2358:				
2359:16849+6	A0C9  2B      	ZERARY: DEC     HL              ; Back through array data
2360:16855+10	A0CA  3600    	        LD      (HL),0          ; Set array element to zero
2361:16865+17	A0CC  CD7597  	        CALL    CPDEHL          ; All elements zeroed?
2362:16882+10	A0CF  C2C9A0  	        JP      NZ,ZERARY       ; No - Keep on going
2363:16892+6	A0D2  03      	        INC     BC              ; Number of bytes + 1
2364:16898+4	A0D3  57      	        LD      D,A             ; A=0
2365:16902+16	A0D4  2A0AB1  	        LD      HL,(CUROPR)     ; Get address of array
2366:16918+7	A0D7  5E      	        LD      E,(HL)          ; Number of dimensions
2367:16925+4	A0D8  EB      	        EX      DE,HL           ; To HL
2368:16929+11	A0D9  29      	        ADD     HL,HL           ; Two bytes per dimension size
2369:16940+11	A0DA  09      	        ADD     HL,BC           ; Add number of bytes
2370:16951+4	A0DB  EB      	        EX      DE,HL           ; Bytes needed to DE
2371:16955+6	A0DC  2B      	        DEC     HL
2372:16961+6	A0DD  2B      	        DEC     HL
2373:16967+7	A0DE  73      	        LD      (HL),E          ; Save LSB of bytes needed
2374:16974+6	A0DF  23      	        INC     HL
2375:16980+7	A0E0  72      	        LD      (HL),D          ; Save MSB of bytes needed
2376:16987+6	A0E1  23      	        INC     HL
2377:16993+10	A0E2  F1      	        POP     AF              ; Locate / Create?
2378:17003+10	A0E3  DA0AA1  	        JP      C,ENDDIM        ; A is 0 , End if create
2379:17013+4	A0E6  47      	FINDEL: LD      B,A             ; Find array element
2380:17017+4	A0E7  4F      	        LD      C,A
2381:17021+7	A0E8  7E      	        LD      A,(HL)          ; Number of dimensions
2382:17028+6	A0E9  23      	        INC     HL
2383:     -	A0EA  16      	        .BYTE      16H             ; Skip "POP HL"
2384:17034+10	A0EB  E1      	FNDELP: POP     HL              ; Address of next dim' size
2385:17044+7	A0EC  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2386:17051+6	A0ED  23      	        INC     HL
2387:17057+7	A0EE  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2388:17064+6	A0EF  23      	        INC     HL
2389:17070+19	A0F0  E3      	        EX      (SP),HL         ; Save address - Get index
2390:17089+11	A0F1  F5      	        PUSH    AF              ; Save number of dim'ns
2391:17100+17	A0F2  CD7597  	        CALL    CPDEHL          ; Dimension too large?
2392:17117+10	A0F5  D283A0  	        JP      NC,BSERR        ; Yes - ?BS Error
2393:17127+11	A0F8  E5      	        PUSH    HL              ; Save index
2394:17138+17	A0F9  CD43A8  	        CALL    MLDEBC          ; Multiply previous by size
2395:17155+10	A0FC  D1      	        POP     DE              ; Index supplied to DE
2396:17165+11	A0FD  19      	        ADD     HL,DE           ; Add index to pointer
2397:17176+10	A0FE  F1      	        POP     AF              ; Number of dimensions
2398:17186+4	A0FF  3D      	        DEC     A               ; Count them
2399:17190+4	A100  44      	        LD      B,H             ; MSB of pointer
2400:17194+4	A101  4D      	        LD      C,L             ; LSB of pointer
2401:17198+10	A102  C2EBA0  	        JP      NZ,FNDELP       ; More - Keep going
2402:17208+11	A105  29      	        ADD     HL,HL           ; 4 Bytes per element
2403:17219+11	A106  29      	        ADD     HL,HL
2404:17230+10	A107  C1      	        POP     BC              ; Start of array
2405:17240+11	A108  09      	        ADD     HL,BC           ; Point to element
2406:17251+4	A109  EB      	        EX      DE,HL           ; Address of element to DE
2407:17255+16	A10A  2A15B1  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2408:17271+10	A10D  C9      	        RET
2409:				
2410:17281+16	A10E  2A1FB1  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2411:17297+4	A111  EB      	        EX      DE,HL           ; To DE
2412:17301+10	A112  210000  	        LD      HL,0            ; End of free memory
2413:17311+11	A115  39      	        ADD     HL,SP           ; Current stack value
2414:17322+13	A116  3AF2B0  	        LD      A,(TYPE)        ; Dummy argument type
2415:17335+4	A119  B7      	        OR      A
2416:17339+10	A11A  CA2AA1  	        JP      Z,FRENUM        ; Numeric - Free variable space
2417:17349+17	A11D  CD91A3  	        CALL    GSTRCU          ; Current string to pool
2418:17366+17	A120  CD91A2  	        CALL    GARBGE          ; Garbage collection
2419:17383+16	A123  2A9FB0  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2420:17399+4	A126  EB      	        EX      DE,HL           ; To DE
2421:17403+16	A127  2A08B1  	        LD      HL,(STRBOT)     ; Bottom of string space
2422:17419+4	A12A  7D      	FRENUM: LD      A,L             ; Get LSB of end
2423:17423+4	A12B  93      	        SUB     E               ; Subtract LSB of beginning
2424:17427+4	A12C  4F      	        LD      C,A             ; Save difference if C
2425:17431+4	A12D  7C      	        LD      A,H             ; Get MSB of end
2426:17435+4	A12E  9A      	        SBC     A,D             ; Subtract MSB of beginning
2427:17439+4	A12F  41      	ACPASS: LD      B,C             ; Return integer AC
2428:17443+4	A130  50      	ABPASS: LD      D,B             ; Return integer AB
2429:17447+7	A131  1E00    	        LD      E,0
2430:17454+10	A133  21F2B0  	        LD      HL,TYPE         ; Point to type
2431:17464+7	A136  73      	        LD      (HL),E          ; Set type to numeric
2432:17471+7	A137  0690    	        LD      B,80H+16        ; 16 bit integer
2433:17478+10	A139  C36EA7  	        JP      RETINT          ; Return the integr
2434:				
2435:17488+13	A13C  3AF0B0  	POS:    LD      A,(CURPOS)      ; Get cursor position
2436:17501+4	A13F  47      	PASSA:  LD      B,A             ; Put A into AB
2437:17505+4	A140  AF      	        XOR     A               ; Zero A
2438:17509+10	A141  C330A1  	        JP      ABPASS          ; Return integer AB
2439:				
2440:17519+17	A144  CDC7A1  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2441:17536+17	A147  CDB9A1  	        CALL    IDTEST          ; Test for illegal direct
2442:17553+10	A14A  019F9A  	        LD      BC,DATA         ; To get next statement
2443:17563+11	A14D  C5      	        PUSH    BC              ; Save address for RETurn
2444:17574+11	A14E  D5      	        PUSH    DE              ; Save address of function ptr
2445:17585+17	A14F  CD7B97  	        CALL    CHKSYN          ; Make sure "(" follows
2446:     -	A152  28      	        .BYTE      "("
2447:17602+17	A153  CD6B9F  	        CALL    GETVAR          ; Get argument variable name
2448:17619+11	A156  E5      	        PUSH    HL              ; Save code string address
2449:17630+4	A157  EB      	        EX      DE,HL           ; Argument address to HL
2450:17634+6	A158  2B      	        DEC     HL
2451:17640+7	A159  56      	        LD      D,(HL)          ; Get first byte of arg name
2452:17647+6	A15A  2B      	        DEC     HL
2453:17653+7	A15B  5E      	        LD      E,(HL)          ; Get second byte of arg name
2454:17660+10	A15C  E1      	        POP     HL              ; Restore code string address
2455:17670+17	A15D  CD789D  	        CALL    TSTNUM          ; Make sure numeric argument
2456:17687+17	A160  CD7B97  	        CALL    CHKSYN          ; Make sure ")" follows
2457:     -	A163  29      	        .BYTE      ")"
2458:17704+17	A164  CD7B97  	        CALL    CHKSYN          ; Make sure "=" follows
2459:     -	A167  B4      	        .BYTE      ZEQUAL          ; "=" token
2460:17721+4	A168  44      	        LD      B,H             ; Code string address to BC
2461:17725+4	A169  4D      	        LD      C,L
2462:17729+19	A16A  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2463:17748+7	A16B  71      	        LD      (HL),C          ; Save LSB of FN code string
2464:17755+6	A16C  23      	        INC     HL
2465:17761+7	A16D  70      	        LD      (HL),B          ; Save MSB of FN code string
2466:17768+10	A16E  C306A2  	        JP      SVSTAD          ; Save address and do function
2467:				
2468:17778+17	A171  CDC7A1  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2469:17795+11	A174  D5      	        PUSH    DE              ; Save function pointer address
2470:17806+17	A175  CD4C9E  	        CALL    EVLPAR          ; Evaluate expression in "()"
2471:17823+17	A178  CD789D  	        CALL    TSTNUM          ; Make sure numeric result
2472:17840+19	A17B  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2473:17859+7	A17C  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2474:17866+6	A17D  23      	        INC     HL
2475:17872+7	A17E  56      	        LD      D,(HL)          ; Get MSB of FN code string
2476:17879+6	A17F  23      	        INC     HL
2477:17885+4	A180  7A      	        LD      A,D             ; And function DEFined?
2478:17889+4	A181  B3      	        OR      E
2479:17893+10	A182  CAB994  	        JP      Z,UFERR         ; No - ?UF Error
2480:17903+7	A185  7E      	        LD      A,(HL)          ; Get LSB of argument address
2481:17910+6	A186  23      	        INC     HL
2482:17916+7	A187  66      	        LD      H,(HL)          ; Get MSB of argument address
2483:17923+4	A188  6F      	        LD      L,A             ; HL = Arg variable address
2484:17927+11	A189  E5      	        PUSH    HL              ; Save it
2485:17938+16	A18A  2A23B1  	        LD      HL,(FNRGNM)     ; Get old argument name
2486:17954+19	A18D  E3      	        EX      (SP),HL ;       ; Save old , Get new
2487:17973+16	A18E  2223B1  	        LD      (FNRGNM),HL     ; Set new argument name
2488:17989+16	A191  2A27B1  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2489:18005+11	A194  E5      	        PUSH    HL              ; Save it
2490:18016+16	A195  2A25B1  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2491:18032+11	A198  E5      	        PUSH    HL              ; Save it
2492:18043+10	A199  2125B1  	        LD      HL,FNARG        ; HL = Value of argument
2493:18053+11	A19C  D5      	        PUSH    DE              ; Save FN code string address
2494:18064+17	A19D  CDAFA7  	        CALL    FPTHL           ; Move FPREG to argument
2495:18081+10	A1A0  E1      	        POP     HL              ; Get FN code string address
2496:18091+17	A1A1  CD759D  	        CALL    GETNUM          ; Get value from function
2497:18108+6	A1A4  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2498:18114+17	A1A5  CD0599  	        CALL    GETCHR          ; Get next character
2499:18131+10	A1A8  C2AD94  	        JP      NZ,SNERR        ; Bad character in FN - Error
2500:18141+10	A1AB  E1      	        POP     HL              ; Get MSB,EXP of old arg
2501:18151+16	A1AC  2225B1  	        LD      (FNARG),HL      ; Restore it
2502:18167+10	A1AF  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2503:18177+16	A1B0  2227B1  	        LD      (FNARG+2),HL    ; Restore it
2504:18193+10	A1B3  E1      	        POP     HL              ; Get name of old arg
2505:18203+16	A1B4  2223B1  	        LD      (FNRGNM),HL     ; Restore it
2506:18219+10	A1B7  E1      	        POP     HL              ; Restore code string address
2507:18229+10	A1B8  C9      	        RET
2508:				
2509:18239+11	A1B9  E5      	IDTEST: PUSH    HL              ; Save code string address
2510:18250+16	A1BA  2AA1B0  	        LD      HL,(LINEAT)     ; Get current line number
2511:18266+6	A1BD  23      	        INC     HL              ; -1 means direct statement
2512:18272+4	A1BE  7C      	        LD      A,H
2513:18276+4	A1BF  B5      	        OR      L
2514:18280+10	A1C0  E1      	        POP     HL              ; Restore code string address
2515:18290+5+6	A1C1  C0      	        RET     NZ              ; Return if in program
2516:18295+7	A1C2  1E16    	        LD      E,ID            ; ?ID Error
2517:18302+10	A1C4  C3C194  	        JP      ERROR
2518:				
2519:18312+17	A1C7  CD7B97  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2520:     -	A1CA  A7      	        .BYTE      ZFN             ; "FN" token
2521:18329+7	A1CB  3E80    	        LD      A,80H
2522:18336+13	A1CD  3210B1  	        LD      (FORFLG),A      ; Flag FN name to find
2523:18349+7	A1D0  B6      	        OR      (HL)            ; FN name has bit 7 set
2524:18356+4	A1D1  47      	        LD      B,A             ; in first byte of name
2525:18360+17	A1D2  CD709F  	        CALL    GTFNAM          ; Get FN name
2526:18377+10	A1D5  C3789D  	        JP      TSTNUM          ; Make sure numeric function
2527:				
2528:18387+17	A1D8  CD789D  	STR:    CALL    TSTNUM          ; Make sure it's a number
2529:18404+17	A1DB  CDFCA8  	        CALL    NUMASC          ; Turn number into text
2530:18421+17	A1DE  CD0CA2  	STR1:   CALL    CRTST           ; Create string entry for it
2531:18438+17	A1E1  CD91A3  	        CALL    GSTRCU          ; Current string to pool
2532:18455+10	A1E4  01ECA3  	        LD      BC,TOPOOL       ; Save in string pool
2533:18465+11	A1E7  C5      	        PUSH    BC              ; Save address on stack
2534:				
2535:18476+7	A1E8  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2536:18483+6	A1E9  23      	        INC     HL
2537:18489+6	A1EA  23      	        INC     HL
2538:18495+11	A1EB  E5      	        PUSH    HL              ; Save pointer to string
2539:18506+17	A1EC  CD67A2  	        CALL    TESTR           ; See if enough string space
2540:18523+10	A1EF  E1      	        POP     HL              ; Restore pointer to string
2541:18533+7	A1F0  4E      	        LD      C,(HL)          ; Get LSB of address
2542:18540+6	A1F1  23      	        INC     HL
2543:18546+7	A1F2  46      	        LD      B,(HL)          ; Get MSB of address
2544:18553+17	A1F3  CD00A2  	        CALL    CRTMST          ; Create string entry
2545:18570+11	A1F6  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2546:18581+4	A1F7  6F      	        LD      L,A             ; Length of string
2547:18585+17	A1F8  CD84A3  	        CALL    TOSTRA          ; Move to string area
2548:18602+10	A1FB  D1      	        POP     DE              ; Restore pointer to MSB
2549:18612+10	A1FC  C9      	        RET
2550:				
2551:18622+17	A1FD  CD67A2  	MKTMST: CALL    TESTR           ; See if enough string space
2552:18639+10	A200  2104B1  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2553:18649+11	A203  E5      	        PUSH    HL              ; Save it
2554:18660+7	A204  77      	        LD      (HL),A          ; Save length of string
2555:18667+6	A205  23      	        INC     HL
2556:18673+6	A206  23      	SVSTAD: INC     HL
2557:18679+7	A207  73      	        LD      (HL),E          ; Save LSB of address
2558:18686+6	A208  23      	        INC     HL
2559:18692+7	A209  72      	        LD      (HL),D          ; Save MSB of address
2560:18699+10	A20A  E1      	        POP     HL              ; Restore pointer
2561:18709+10	A20B  C9      	        RET
2562:				
2563:18719+6	A20C  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2564:18725+7	A20D  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2565:18732+4	A20F  50      	        LD      D,B             ; Quote to D
2566:18736+11	A210  E5      	DTSTR:  PUSH    HL              ; Save start
2567:18747+7	A211  0EFF    	        LD      C,-1            ; Set counter to -1
2568:18754+6	A213  23      	QTSTLP: INC     HL              ; Move on
2569:18760+7	A214  7E      	        LD      A,(HL)          ; Get byte
2570:18767+4	A215  0C      	        INC     C               ; Count bytes
2571:18771+4	A216  B7      	        OR      A               ; End of line?
2572:18775+10	A217  CA22A2  	        JP      Z,CRTSTE        ; Yes - Create string entry
2573:18785+4	A21A  BA      	        CP      D               ; Terminator D found?
2574:18789+10	A21B  CA22A2  	        JP      Z,CRTSTE        ; Yes - Create string entry
2575:18799+4	A21E  B8      	        CP      B               ; Terminator B found?
2576:18803+10	A21F  C213A2  	        JP      NZ,QTSTLP       ; No - Keep looking
2577:18813+7	A222  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2578:18820+10+7	A224  CC0599  	        CALL    Z,GETCHR        ; Yes - Get next character
2579:18830+19	A227  E3      	        EX      (SP),HL         ; Starting quote
2580:18849+6	A228  23      	        INC     HL              ; First byte of string
2581:18855+4	A229  EB      	        EX      DE,HL           ; To DE
2582:18859+4	A22A  79      	        LD      A,C             ; Get length
2583:18863+17	A22B  CD00A2  	        CALL    CRTMST          ; Create string entry
2584:18880+10	A22E  1104B1  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2585:18890+16	A231  2AF6B0  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2586:18906+16	A234  2229B1  	        LD      (FPREG),HL      ; Save address of string ptr
2587:18922+7	A237  3E01    	        LD      A,1
2588:18929+13	A239  32F2B0  	        LD      (TYPE),A        ; Set type to string
2589:18942+17	A23C  CDB2A7  	        CALL    DETHL4          ; Move string to pool
2590:18959+17	A23F  CD7597  	        CALL    CPDEHL          ; Out of string pool?
2591:18976+16	A242  22F6B0  	        LD      (TMSTPT),HL     ; Save new pointer
2592:18992+10	A245  E1      	        POP     HL              ; Restore code string address
2593:19002+7	A246  7E      	        LD      A,(HL)          ; Get next code byte
2594:19009+5+6	A247  C0      	        RET     NZ              ; Return if pool OK
2595:19014+7	A248  1E1E    	        LD      E,ST            ; ?ST Error
2596:19021+10	A24A  C3C194  	        JP      ERROR           ; String pool overflow
2597:				
2598:19031+6	A24D  23      	PRNUMS: INC     HL              ; Skip leading space
2599:19037+17	A24E  CD0CA2  	PRS:    CALL    CRTST           ; Create string entry for it
2600:19054+17	A251  CD91A3  	PRS1:   CALL    GSTRCU          ; Current string to pool
2601:19071+17	A254  CDA6A7  	        CALL    LOADFP          ; Move string block to BCDE
2602:19088+4	A257  1C      	        INC     E               ; Length + 1
2603:19092+4	A258  1D      	PRSLP:  DEC     E               ; Count characters
2604:19096+5+6	A259  C8      	        RET     Z               ; End of string
2605:19101+7	A25A  0A      	        LD      A,(BC)          ; Get byte to output
2606:19108+17	A25B  CD8697  	        CALL    OUTC            ; Output character in A
2607:19125+7	A25E  FE0D    	        CP      CR              ; Return?
2608:19132+10+7	A260  CCBA9B  	        CALL    Z,DONULL        ; Yes - Do nulls
2609:19142+6	A263  03      	        INC     BC              ; Next byte in string
2610:19148+10	A264  C358A2  	        JP      PRSLP           ; More characters to output
2611:				
2612:19158+4	A267  B7      	TESTR:  OR      A               ; Test if enough room
2613:     -	A268  0E      	        .BYTE      0EH             ; No garbage collection done
2614:19162+10	A269  F1      	GRBDON: POP     AF              ; Garbage collection done
2615:19172+11	A26A  F5      	        PUSH    AF              ; Save status
2616:19183+16	A26B  2A9FB0  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2617:19199+4	A26E  EB      	        EX      DE,HL           ; To DE
2618:19203+16	A26F  2A08B1  	        LD      HL,(STRBOT)     ; Bottom of string area
2619:19219+4	A272  2F      	        CPL                     ; Negate length (Top down)
2620:19223+4	A273  4F      	        LD      C,A             ; -Length to BC
2621:19227+7	A274  06FF    	        LD      B,-1            ; BC = -ve length of string
2622:19234+11	A276  09      	        ADD     HL,BC           ; Add to bottom of space in use
2623:19245+6	A277  23      	        INC     HL              ; Plus one for 2's complement
2624:19251+17	A278  CD7597  	        CALL    CPDEHL          ; Below string RAM area?
2625:19268+10	A27B  DA85A2  	        JP      C,TESTOS        ; Tidy up if not done else err
2626:19278+16	A27E  2208B1  	        LD      (STRBOT),HL     ; Save new bottom of area
2627:19294+6	A281  23      	        INC     HL              ; Point to first byte of string
2628:19300+4	A282  EB      	        EX      DE,HL           ; Address to DE
2629:19304+10	A283  F1      	POPAF:  POP     AF              ; Throw away status push
2630:19314+10	A284  C9      	        RET
2631:				
2632:19324+10	A285  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2633:19334+7	A286  1E1A    	        LD      E,OS            ; ?OS Error
2634:19341+10	A288  CAC194  	        JP      Z,ERROR         ; Yes - Not enough string apace
2635:19351+4	A28B  BF      	        CP      A               ; Flag garbage collect done
2636:19355+11	A28C  F5      	        PUSH    AF              ; Save status
2637:19366+10	A28D  0169A2  	        LD      BC,GRBDON       ; Garbage collection done
2638:19376+11	A290  C5      	        PUSH    BC              ; Save for RETurn
2639:19387+16	A291  2AF4B0  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2640:19403+16	A294  2208B1  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2641:19419+10	A297  210000  	        LD      HL,0
2642:19429+11	A29A  E5      	        PUSH    HL              ; Flag no string found
2643:19440+16	A29B  2A9FB0  	        LD      HL,(STRSPC)     ; Get bottom of string space
2644:19456+11	A29E  E5      	        PUSH    HL              ; Save bottom of string space
2645:19467+10	A29F  21F8B0  	        LD      HL,TMSTPL       ; Temporary string pool
2646:19477+4	A2A2  EB      	GRBLP:  EX      DE,HL
2647:19481+16	A2A3  2AF6B0  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2648:19497+4	A2A6  EB      	        EX      DE,HL
2649:19501+17	A2A7  CD7597  	        CALL    CPDEHL          ; Temporary string pool done?
2650:19518+10	A2AA  01A2A2  	        LD      BC,GRBLP        ; Loop until string pool done
2651:19528+10	A2AD  C2F6A2  	        JP      NZ,STPOOL       ; No - See if in string area
2652:19538+16	A2B0  2A1BB1  	        LD      HL,(PROGND)     ; Start of simple variables
2653:19554+4	A2B3  EB      	SMPVAR: EX      DE,HL
2654:19558+16	A2B4  2A1DB1  	        LD      HL,(VAREND)     ; End of simple variables
2655:19574+4	A2B7  EB      	        EX      DE,HL
2656:19578+17	A2B8  CD7597  	        CALL    CPDEHL          ; All simple strings done?
2657:19595+10	A2BB  CAC9A2  	        JP      Z,ARRLP         ; Yes - Do string arrays
2658:19605+7	A2BE  7E      	        LD      A,(HL)          ; Get type of variable
2659:19612+6	A2BF  23      	        INC     HL
2660:19618+6	A2C0  23      	        INC     HL
2661:19624+4	A2C1  B7      	        OR      A               ; "S" flag set if string
2662:19628+17	A2C2  CDF9A2  	        CALL    STRADD          ; See if string in string area
2663:19645+10	A2C5  C3B3A2  	        JP      SMPVAR          ; Loop until simple ones done
2664:				
2665:19655+10	A2C8  C1      	GNXARY: POP     BC              ; Scrap address of this array
2666:19665+4	A2C9  EB      	ARRLP:  EX      DE,HL
2667:19669+16	A2CA  2A1FB1  	        LD      HL,(ARREND)     ; End of string arrays
2668:19685+4	A2CD  EB      	        EX      DE,HL
2669:19689+17	A2CE  CD7597  	        CALL    CPDEHL          ; All string arrays done?
2670:19706+10	A2D1  CA1FA3  	        JP      Z,SCNEND        ; Yes - Move string if found
2671:19716+17	A2D4  CDA6A7  	        CALL    LOADFP          ; Get array name to BCDE
2672:19733+4	A2D7  7B      	        LD      A,E             ; Get type of array     
2673:19737+11	A2D8  E5      	        PUSH    HL              ; Save address of num of dim'ns
2674:19748+11	A2D9  09      	        ADD     HL,BC           ; Start of next array
2675:19759+4	A2DA  B7      	        OR      A               ; Test type of array
2676:19763+10	A2DB  F2C8A2  	        JP      P,GNXARY        ; Numeric array - Ignore it
2677:19773+16	A2DE  220AB1  	        LD      (CUROPR),HL     ; Save address of next array
2678:19789+10	A2E1  E1      	        POP     HL              ; Get address of num of dim'ns
2679:19799+7	A2E2  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2680:19806+7	A2E3  0600    	        LD      B,0
2681:19813+11	A2E5  09      	        ADD     HL,BC           ; Two bytes per dimension size
2682:19824+11	A2E6  09      	        ADD     HL,BC
2683:19835+6	A2E7  23      	        INC     HL              ; Plus one for number of dim'ns
2684:19841+4	A2E8  EB      	GRBARY: EX      DE,HL
2685:19845+16	A2E9  2A0AB1  	        LD      HL,(CUROPR)     ; Get address of next array
2686:19861+4	A2EC  EB      	        EX      DE,HL
2687:19865+17	A2ED  CD7597  	        CALL    CPDEHL          ; Is this array finished?
2688:19882+10	A2F0  CAC9A2  	        JP      Z,ARRLP         ; Yes - Get next one
2689:19892+10	A2F3  01E8A2  	        LD      BC,GRBARY       ; Loop until array all done
2690:19902+11	A2F6  C5      	STPOOL: PUSH    BC              ; Save return address
2691:19913+7	A2F7  F680    	        OR      80H             ; Flag string type
2692:19920+7	A2F9  7E      	STRADD: LD      A,(HL)          ; Get string length
2693:19927+6	A2FA  23      	        INC     HL
2694:19933+6	A2FB  23      	        INC     HL
2695:19939+7	A2FC  5E      	        LD      E,(HL)          ; Get LSB of string address
2696:19946+6	A2FD  23      	        INC     HL
2697:19952+7	A2FE  56      	        LD      D,(HL)          ; Get MSB of string address
2698:19959+6	A2FF  23      	        INC     HL
2699:19965+5+6	A300  F0      	        RET     P               ; Not a string - Return
2700:19970+4	A301  B7      	        OR      A               ; Set flags on string length
2701:19974+5+6	A302  C8      	        RET     Z               ; Null string - Return
2702:19979+4	A303  44      	        LD      B,H             ; Save variable pointer
2703:19983+4	A304  4D      	        LD      C,L
2704:19987+16	A305  2A08B1  	        LD      HL,(STRBOT)     ; Bottom of new area
2705:20003+17	A308  CD7597  	        CALL    CPDEHL          ; String been done?
2706:20020+4	A30B  60      	        LD      H,B             ; Restore variable pointer
2707:20024+4	A30C  69      	        LD      L,C
2708:20028+5+6	A30D  D8      	        RET     C               ; String done - Ignore
2709:20033+10	A30E  E1      	        POP     HL              ; Return address
2710:20043+19	A30F  E3      	        EX      (SP),HL         ; Lowest available string area
2711:20062+17	A310  CD7597  	        CALL    CPDEHL          ; String within string area?
2712:20079+19	A313  E3      	        EX      (SP),HL         ; Lowest available string area
2713:20098+11	A314  E5      	        PUSH    HL              ; Re-save return address
2714:20109+4	A315  60      	        LD      H,B             ; Restore variable pointer
2715:20113+4	A316  69      	        LD      L,C
2716:20117+5+6	A317  D0      	        RET     NC              ; Outside string area - Ignore
2717:20122+10	A318  C1      	        POP     BC              ; Get return , Throw 2 away
2718:20132+10	A319  F1      	        POP     AF              ; 
2719:20142+10	A31A  F1      	        POP     AF              ; 
2720:20152+11	A31B  E5      	        PUSH    HL              ; Save variable pointer
2721:20163+11	A31C  D5      	        PUSH    DE              ; Save address of current
2722:20174+11	A31D  C5      	        PUSH    BC              ; Put back return address
2723:20185+10	A31E  C9      	        RET                     ; Go to it
2724:				
2725:20195+10	A31F  D1      	SCNEND: POP     DE              ; Addresses of strings
2726:20205+10	A320  E1      	        POP     HL              ; 
2727:20215+4	A321  7D      	        LD      A,L             ; HL = 0 if no more to do
2728:20219+4	A322  B4      	        OR      H
2729:20223+5+6	A323  C8      	        RET     Z               ; No more to do - Return
2730:20228+6	A324  2B      	        DEC     HL
2731:20234+7	A325  46      	        LD      B,(HL)          ; MSB of address of string
2732:20241+6	A326  2B      	        DEC     HL
2733:20247+7	A327  4E      	        LD      C,(HL)          ; LSB of address of string
2734:20254+11	A328  E5      	        PUSH    HL              ; Save variable address
2735:20265+6	A329  2B      	        DEC     HL
2736:20271+6	A32A  2B      	        DEC     HL
2737:20277+7	A32B  6E      	        LD      L,(HL)          ; HL = Length of string
2738:20284+7	A32C  2600    	        LD      H,0
2739:20291+11	A32E  09      	        ADD     HL,BC           ; Address of end of string+1
2740:20302+4	A32F  50      	        LD      D,B             ; String address to DE
2741:20306+4	A330  59      	        LD      E,C
2742:20310+6	A331  2B      	        DEC     HL              ; Last byte in string
2743:20316+4	A332  44      	        LD      B,H             ; Address to BC
2744:20320+4	A333  4D      	        LD      C,L
2745:20324+16	A334  2A08B1  	        LD      HL,(STRBOT)     ; Current bottom of string area
2746:20340+17	A337  CD7C94  	        CALL    MOVSTR          ; Move string to new address
2747:20357+10	A33A  E1      	        POP     HL              ; Restore variable address
2748:20367+7	A33B  71      	        LD      (HL),C          ; Save new LSB of address
2749:20374+6	A33C  23      	        INC     HL
2750:20380+7	A33D  70      	        LD      (HL),B          ; Save new MSB of address
2751:20387+4	A33E  69      	        LD      L,C             ; Next string area+1 to HL
2752:20391+4	A33F  60      	        LD      H,B
2753:20395+6	A340  2B      	        DEC     HL              ; Next string area address
2754:20401+10	A341  C394A2  	        JP      GARBLP          ; Look for more strings
2755:				
2756:20411+11	A344  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2757:20422+11	A345  E5      	        PUSH    HL              ; 
2758:20433+16	A346  2A29B1  	        LD      HL,(FPREG)      ; Get first string
2759:20449+19	A349  E3      	        EX      (SP),HL         ; Save first string
2760:20468+17	A34A  CDFE9D  	        CALL    OPRND           ; Get second string
2761:20485+19	A34D  E3      	        EX      (SP),HL         ; Restore first string
2762:20504+17	A34E  CD799D  	        CALL    TSTSTR          ; Make sure it's a string
2763:20521+7	A351  7E      	        LD      A,(HL)          ; Get length of second string
2764:20528+11	A352  E5      	        PUSH    HL              ; Save first string
2765:20539+16	A353  2A29B1  	        LD      HL,(FPREG)      ; Get second string
2766:20555+11	A356  E5      	        PUSH    HL              ; Save second string
2767:20566+7	A357  86      	        ADD     A,(HL)          ; Add length of second string
2768:20573+7	A358  1E1C    	        LD      E,LS            ; ?LS Error
2769:20580+10	A35A  DAC194  	        JP      C,ERROR         ; String too long - Error
2770:20590+17	A35D  CDFDA1  	        CALL    MKTMST          ; Make temporary string
2771:20607+10	A360  D1      	        POP     DE              ; Get second string to DE
2772:20617+17	A361  CD95A3  	        CALL    GSTRDE          ; Move to string pool if needed
2773:20634+19	A364  E3      	        EX      (SP),HL         ; Get first string
2774:20653+17	A365  CD94A3  	        CALL    GSTRHL          ; Move to string pool if needed
2775:20670+11	A368  E5      	        PUSH    HL              ; Save first string
2776:20681+16	A369  2A06B1  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2777:20697+4	A36C  EB      	        EX      DE,HL           ; To DE
2778:20701+17	A36D  CD7BA3  	        CALL    SSTSA           ; First string to string area
2779:20718+17	A370  CD7BA3  	        CALL    SSTSA           ; Second string to string area
2780:20735+10	A373  21939D  	        LD      HL,EVAL2        ; Return to evaluation loop
2781:20745+19	A376  E3      	        EX      (SP),HL         ; Save return,get code string
2782:20764+11	A377  E5      	        PUSH    HL              ; Save code string address
2783:20775+10	A378  C32EA2  	        JP      TSTOPL          ; To temporary string to pool
2784:				
2785:20785+10	A37B  E1      	SSTSA:  POP     HL              ; Return address
2786:20795+19	A37C  E3      	        EX      (SP),HL         ; Get string block,save return
2787:20814+7	A37D  7E      	        LD      A,(HL)          ; Get length of string
2788:20821+6	A37E  23      	        INC     HL
2789:20827+6	A37F  23      	        INC     HL
2790:20833+7	A380  4E      	        LD      C,(HL)          ; Get LSB of string address
2791:20840+6	A381  23      	        INC     HL
2792:20846+7	A382  46      	        LD      B,(HL)          ; Get MSB of string address
2793:20853+4	A383  6F      	        LD      L,A             ; Length to L
2794:20857+4	A384  2C      	TOSTRA: INC     L               ; INC - DECed after
2795:20861+4	A385  2D      	TSALP:  DEC     L               ; Count bytes moved
2796:20865+5+6	A386  C8      	        RET     Z               ; End of string - Return
2797:20870+7	A387  0A      	        LD      A,(BC)          ; Get source
2798:20877+7	A388  12      	        LD      (DE),A          ; Save destination
2799:20884+6	A389  03      	        INC     BC              ; Next source
2800:20890+6	A38A  13      	        INC     DE              ; Next destination
2801:20896+10	A38B  C385A3  	        JP      TSALP           ; Loop until string moved
2802:				
2803:20906+17	A38E  CD799D  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2804:20923+16	A391  2A29B1  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2805:20939+4	A394  EB      	GSTRHL: EX      DE,HL           ; Save DE
2806:20943+17	A395  CDAFA3  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2807:20960+4	A398  EB      	        EX      DE,HL           ; Restore DE
2808:20964+5+6	A399  C0      	        RET     NZ              ; No - Return
2809:20969+11	A39A  D5      	        PUSH    DE              ; Save string
2810:20980+4	A39B  50      	        LD      D,B             ; String block address to DE
2811:20984+4	A39C  59      	        LD      E,C
2812:20988+6	A39D  1B      	        DEC     DE              ; Point to length
2813:20994+7	A39E  4E      	        LD      C,(HL)          ; Get string length
2814:21001+16	A39F  2A08B1  	        LD      HL,(STRBOT)     ; Current bottom of string area
2815:21017+17	A3A2  CD7597  	        CALL    CPDEHL          ; Last one in string area?
2816:21034+10	A3A5  C2ADA3  	        JP      NZ,POPHL        ; No - Return
2817:21044+4	A3A8  47      	        LD      B,A             ; Clear B (A=0)
2818:21048+11	A3A9  09      	        ADD     HL,BC           ; Remove string from str' area
2819:21059+16	A3AA  2208B1  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2820:21075+10	A3AD  E1      	POPHL:  POP     HL              ; Restore string
2821:21085+10	A3AE  C9      	        RET
2822:				
2823:21095+16	A3AF  2AF6B0  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2824:21111+6	A3B2  2B      	        DEC     HL              ; Back
2825:21117+7	A3B3  46      	        LD      B,(HL)          ; Get MSB of address
2826:21124+6	A3B4  2B      	        DEC     HL              ; Back
2827:21130+7	A3B5  4E      	        LD      C,(HL)          ; Get LSB of address
2828:21137+6	A3B6  2B      	        DEC     HL              ; Back
2829:21143+6	A3B7  2B      	        DEC     HL              ; Back
2830:21149+17	A3B8  CD7597  	        CALL    CPDEHL          ; String last in string pool?
2831:21166+5+6	A3BB  C0      	        RET     NZ              ; Yes - Leave it
2832:21171+16	A3BC  22F6B0  	        LD      (TMSTPT),HL     ; Save new string pool top
2833:21187+10	A3BF  C9      	        RET
2834:				
2835:21197+10	A3C0  013FA1  	LEN:    LD      BC,PASSA        ; To return integer A
2836:21207+11	A3C3  C5      	        PUSH    BC              ; Save address
2837:21218+17	A3C4  CD8EA3  	GETLEN: CALL    GETSTR          ; Get string and its length
2838:21235+4	A3C7  AF      	        XOR     A
2839:21239+4	A3C8  57      	        LD      D,A             ; Clear D
2840:21243+13	A3C9  32F2B0  	        LD      (TYPE),A        ; Set type to numeric
2841:21256+7	A3CC  7E      	        LD      A,(HL)          ; Get length of string
2842:21263+4	A3CD  B7      	        OR      A               ; Set status flags
2843:21267+10	A3CE  C9      	        RET
2844:				
2845:21277+10	A3CF  013FA1  	ASC:    LD      BC,PASSA        ; To return integer A
2846:21287+11	A3D2  C5      	        PUSH    BC              ; Save address
2847:21298+17	A3D3  CDC4A3  	GTFLNM: CALL    GETLEN          ; Get length of string
2848:21315+10	A3D6  CACF99  	        JP      Z,FCERR         ; Null string - Error
2849:21325+6	A3D9  23      	        INC     HL
2850:21331+6	A3DA  23      	        INC     HL
2851:21337+7	A3DB  5E      	        LD      E,(HL)          ; Get LSB of address
2852:21344+6	A3DC  23      	        INC     HL
2853:21350+7	A3DD  56      	        LD      D,(HL)          ; Get MSB of address
2854:21357+7	A3DE  1A      	        LD      A,(DE)          ; Get first byte of string
2855:21364+10	A3DF  C9      	        RET
2856:				
2857:21374+7	A3E0  3E01    	CHR:    LD      A,1             ; One character string
2858:21381+17	A3E2  CDFDA1  	        CALL    MKTMST          ; Make a temporary string
2859:21398+17	A3E5  CDD9A4  	        CALL    MAKINT          ; Make it integer A
2860:21415+16	A3E8  2A06B1  	        LD      HL,(TMPSTR+2)   ; Get address of string
2861:21431+7	A3EB  73      	        LD      (HL),E          ; Save character
2862:21438+10	A3EC  C1      	TOPOOL: POP     BC              ; Clean up stack
2863:21448+10	A3ED  C32EA2  	        JP      TSTOPL          ; Temporary string to pool
2864:				
2865:21458+17	A3F0  CD89A4  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2866:21475+4	A3F3  AF      	        XOR     A               ; Start at first byte in string
2867:21479+19	A3F4  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2868:21498+4	A3F5  4F      	        LD      C,A             ; Starting position in string
2869:21502+11	A3F6  E5      	MID1:   PUSH    HL              ; Save string block address
2870:21513+7	A3F7  7E      	        LD      A,(HL)          ; Get length of string
2871:21520+4	A3F8  B8      	        CP      B               ; Compare with number given
2872:21524+10	A3F9  DAFEA3  	        JP      C,ALLFOL        ; All following bytes required
2873:21534+4	A3FC  78      	        LD      A,B             ; Get new length
2874:     -	A3FD  11      	        .BYTE      11H             ; Skip "LD C,0"
2875:21538+7	A3FE  0E00    	ALLFOL: LD      C,0             ; First byte of string
2876:21545+11	A400  C5      	        PUSH    BC              ; Save position in string
2877:21556+17	A401  CD67A2  	        CALL    TESTR           ; See if enough string space
2878:21573+10	A404  C1      	        POP     BC              ; Get position in string
2879:21583+10	A405  E1      	        POP     HL              ; Restore string block address
2880:21593+11	A406  E5      	        PUSH    HL              ; And re-save it
2881:21604+6	A407  23      	        INC     HL
2882:21610+6	A408  23      	        INC     HL
2883:21616+7	A409  46      	        LD      B,(HL)          ; Get LSB of address
2884:21623+6	A40A  23      	        INC     HL
2885:21629+7	A40B  66      	        LD      H,(HL)          ; Get MSB of address
2886:21636+4	A40C  68      	        LD      L,B             ; HL = address of string
2887:21640+7	A40D  0600    	        LD      B,0             ; BC = starting address
2888:21647+11	A40F  09      	        ADD     HL,BC           ; Point to that byte
2889:21658+4	A410  44      	        LD      B,H             ; BC = source string
2890:21662+4	A411  4D      	        LD      C,L
2891:21666+17	A412  CD00A2  	        CALL    CRTMST          ; Create a string entry
2892:21683+4	A415  6F      	        LD      L,A             ; Length of new string
2893:21687+17	A416  CD84A3  	        CALL    TOSTRA          ; Move string to string area
2894:21704+10	A419  D1      	        POP     DE              ; Clear stack
2895:21714+17	A41A  CD95A3  	        CALL    GSTRDE          ; Move to string pool if needed
2896:21731+10	A41D  C32EA2  	        JP      TSTOPL          ; Temporary string to pool
2897:				
2898:21741+17	A420  CD89A4  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2899:21758+10	A423  D1      	        POP     DE              ; Get string length
2900:21768+11	A424  D5      	        PUSH    DE              ; And re-save
2901:21779+7	A425  1A      	        LD      A,(DE)          ; Get length
2902:21786+4	A426  90      	        SUB     B               ; Move back N bytes
2903:21790+10	A427  C3F4A3  	        JP      RIGHT1          ; Go and get sub-string
2904:				
2905:21800+4	A42A  EB      	MID:    EX      DE,HL           ; Get code string address
2906:21804+7	A42B  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2907:21811+17	A42C  CD8EA4  	        CALL    MIDNUM          ; Get number supplied
2908:21828+4	A42F  04      	        INC     B               ; Is it character zero?
2909:21832+4	A430  05      	        DEC     B
2910:21836+10	A431  CACF99  	        JP      Z,FCERR         ; Yes - Error
2911:21846+11	A434  C5      	        PUSH    BC              ; Save starting position
2912:21857+7	A435  1EFF    	        LD      E,255           ; All of string
2913:21864+7	A437  FE29    	        CP      ')'             ; Any length given?
2914:21871+10	A439  CA43A4  	        JP      Z,RSTSTR        ; No - Rest of string
2915:21881+17	A43C  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
2916:     -	A43F  2C      	        .BYTE      ','
2917:21898+17	A440  CDD6A4  	        CALL    GETINT          ; Get integer 0-255
2918:21915+17	A443  CD7B97  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2919:     -	A446  29      	        .BYTE      ")"
2920:21932+10	A447  F1      	        POP     AF              ; Restore starting position
2921:21942+19	A448  E3      	        EX      (SP),HL         ; Get string,8ave code string
2922:21961+10	A449  01F6A3  	        LD      BC,MID1         ; Continuation of MID$ routine
2923:21971+11	A44C  C5      	        PUSH    BC              ; Save for return
2924:21982+4	A44D  3D      	        DEC     A               ; Starting position-1
2925:21986+7	A44E  BE      	        CP      (HL)            ; Compare with length
2926:21993+7	A44F  0600    	        LD      B,0             ; Zero bytes length
2927:22000+5+6	A451  D0      	        RET     NC              ; Null string if start past end
2928:22005+4	A452  4F      	        LD      C,A             ; Save starting position-1
2929:22009+7	A453  7E      	        LD      A,(HL)          ; Get length of string
2930:22016+4	A454  91      	        SUB     C               ; Subtract start
2931:22020+4	A455  BB      	        CP      E               ; Enough string for it?
2932:22024+4	A456  47      	        LD      B,A             ; Save maximum length available
2933:22028+5+6	A457  D8      	        RET     C               ; Truncate string if needed
2934:22033+4	A458  43      	        LD      B,E             ; Set specified length
2935:22037+10	A459  C9      	        RET                     ; Go and create string
2936:				
2937:22047+17	A45A  CDC4A3  	VAL:    CALL    GETLEN          ; Get length of string
2938:22064+10	A45D  CA77A5  	        JP      Z,RESZER        ; Result zero
2939:22074+4	A460  5F      	        LD      E,A             ; Save length
2940:22078+6	A461  23      	        INC     HL
2941:22084+6	A462  23      	        INC     HL
2942:22090+7	A463  7E      	        LD      A,(HL)          ; Get LSB of address
2943:22097+6	A464  23      	        INC     HL
2944:22103+7	A465  66      	        LD      H,(HL)          ; Get MSB of address
2945:22110+4	A466  6F      	        LD      L,A             ; HL = String address
2946:22114+11	A467  E5      	        PUSH    HL              ; Save string address
2947:22125+11	A468  19      	        ADD     HL,DE
2948:22136+7	A469  46      	        LD      B,(HL)          ; Get end of string+1 byte
2949:22143+7	A46A  72      	        LD      (HL),D          ; Zero it to terminate
2950:22150+19	A46B  E3      	        EX      (SP),HL         ; Save string end,get start
2951:22169+11	A46C  C5      	        PUSH    BC              ; Save end+1 byte
2952:22180+7	A46D  7E      	        LD      A,(HL)          ; Get starting byte
2953:22187+7	A46E  FE24    	    CP	'$'		; Hex number indicated? [function added]
2954:22194+10	A470  C278A4  	    JP	NZ,VAL1
2955:22204+17	A473  CDA4AC  	    CALL	HEXTFP		; Convert Hex to FPREG
2956:22221+12	A476  180D    	    JR	VAL3
2957:22233+7	A478  FE25    	VAL1:	CP	'%'		; Binary number indicated? [function added]
2958:22240+10	A47A  C282A4  	    JP	NZ,VAL2
2959:22250+17	A47D  CD14AD  	    CALL	BINTFP		; Convert Bin to FPREG
2960:22267+12	A480  1803    	    JR	VAL3
2961:22279+17	A482  CD5EA8  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2962:22296+10	A485  C1      	VAL3:   POP     BC              ; Restore end+1 byte
2963:22306+10	A486  E1      	        POP     HL              ; Restore end+1 address
2964:22316+7	A487  70      	        LD      (HL),B          ; Put back original byte
2965:22323+10	A488  C9      	        RET
2966:				
2967:22333+4	A489  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
2968:22337+17	A48A  CD7B97  	        CALL    CHKSYN          ; Make sure ")" follows
2969:     -	A48D  29      	        .BYTE      ")"
2970:22354+10	A48E  C1      	MIDNUM: POP     BC              ; Get return address
2971:22364+10	A48F  D1      	        POP     DE              ; Get number supplied
2972:22374+11	A490  C5      	        PUSH    BC              ; Re-save return address
2973:22385+4	A491  43      	        LD      B,E             ; Number to B
2974:22389+10	A492  C9      	        RET
2975:				
2976:22399+17	A493  CDD9A4  	INP:    CALL    MAKINT          ; Make it integer A
2977:22416+13	A496  3284B0  	        LD      (INPORT),A      ; Set input port
2978:22429+17	A499  CD83B0  	        CALL    INPSUB          ; Get input from port
2979:22446+10	A49C  C33FA1  	        JP      PASSA           ; Return integer A
2980:				
2981:22456+17	A49F  CDC3A4  	POUT:   CALL    SETIO           ; Set up port number
2982:22473+10	A4A2  C34BB0  	        JP      OUTSUB          ; Output data and return
2983:				
2984:22483+17	A4A5  CDC3A4  	WAIT:   CALL    SETIO           ; Set up port number
2985:22500+11	A4A8  F5      	        PUSH    AF              ; Save AND mask
2986:22511+7	A4A9  1E00    	        LD      E,0             ; Assume zero if none given
2987:22518+6	A4AB  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2988:22524+17	A4AC  CD0599  	        CALL    GETCHR          ; Get next character
2989:22541+10	A4AF  CAB9A4  	        JP      Z,NOXOR         ; No XOR byte given
2990:22551+17	A4B2  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
2991:     -	A4B5  2C      	        .BYTE      ','
2992:22568+17	A4B6  CDD6A4  	        CALL    GETINT          ; Get integer 0-255 to XOR with
2993:22585+10	A4B9  C1      	NOXOR:  POP     BC              ; Restore AND mask
2994:22595+17	A4BA  CD83B0  	WAITLP: CALL    INPSUB          ; Get input
2995:22612+4	A4BD  AB      	        XOR     E               ; Flip selected bits
2996:22616+4	A4BE  A0      	        AND     B               ; Result non-zero?
2997:22620+10	A4BF  CABAA4  	        JP      Z,WAITLP        ; No = keep waiting
2998:22630+10	A4C2  C9      	        RET
2999:				
3000:22640+17	A4C3  CDD6A4  	SETIO:  CALL    GETINT          ; Get integer 0-255
3001:22657+13	A4C6  3284B0  	        LD      (INPORT),A      ; Set input port
3002:22670+13	A4C9  324CB0  	        LD      (OTPORT),A      ; Set output port
3003:22683+17	A4CC  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
3004:     -	A4CF  2C      	        .BYTE      ','
3005:22700+10	A4D0  C3D6A4  	        JP      GETINT          ; Get integer 0-255 and return
3006:				
3007:22710+17	A4D3  CD0599  	FNDNUM: CALL    GETCHR          ; Get next character
3008:22727+17	A4D6  CD759D  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3009:22744+17	A4D9  CDB499  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3010:22761+4	A4DC  7A      	        LD      A,D             ; Get MSB of number
3011:22765+4	A4DD  B7      	        OR      A               ; Zero?
3012:22769+10	A4DE  C2CF99  	        JP      NZ,FCERR        ; No - Error
3013:22779+6	A4E1  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3014:22785+17	A4E2  CD0599  	        CALL    GETCHR          ; Get next character
3015:22802+4	A4E5  7B      	        LD      A,E             ; Get number to A
3016:22806+10	A4E6  C9      	        RET
3017:				
3018:22816+17	A4E7  CDBA99  	PEEK:   CALL    DEINT           ; Get memory address
3019:22833+7	A4EA  1A      	        LD      A,(DE)          ; Get byte in memory
3020:22840+10	A4EB  C33FA1  	        JP      PASSA           ; Return integer A
3021:				
3022:22850+17	A4EE  CD759D  	POKE:   CALL    GETNUM          ; Get memory address
3023:22867+17	A4F1  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 3276
3024:22884+11	A4F4  D5      	        PUSH    DE              ; Save memory address
3025:22895+17	A4F5  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
3026:     -	A4F8  2C      	        .BYTE      ','
3027:22912+17	A4F9  CDD6A4  	        CALL    GETINT          ; Get integer 0-255
3028:22929+10	A4FC  D1      	        POP     DE              ; Restore memory address
3029:22939+7	A4FD  12      	        LD      (DE),A          ; Load it into memory
3030:22946+10	A4FE  C9      	        RET
3031:				
3032:22956+10	A4FF  21D5A9  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3033:22966+17	A502  CDA6A7  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3034:22983+10	A505  C311A5  	        JP      FPADD           ; Add BCDE to FPREG
3035:				
3036:22993+17	A508  CDA6A7  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3037:     -	A50B  21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
3038:23010+10	A50C  C1      	PSUB:   POP     BC              ; Get FP number from stack
3039:23020+10	A50D  D1      	        POP     DE
3040:23030+17	A50E  CD80A7  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3041:23047+4	A511  78      	FPADD:  LD      A,B             ; Get FP exponent
3042:23051+4	A512  B7      	        OR      A               ; Is number zero?
3043:23055+5+6	A513  C8      	        RET     Z               ; Yes - Nothing to add
3044:23060+13	A514  3A2CB1  	        LD      A,(FPEXP)       ; Get FPREG exponent
3045:23073+4	A517  B7      	        OR      A               ; Is this number zero?
3046:23077+10	A518  CA98A7  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3047:23087+4	A51B  90      	        SUB     B               ; BCDE number larger?
3048:23091+10	A51C  D22BA5  	        JP      NC,NOSWAP       ; No - Don't swap them
3049:23101+4	A51F  2F      	        CPL                     ; Two's complement
3050:23105+4	A520  3C      	        INC     A               ;  FP exponent
3051:23109+4	A521  EB      	        EX      DE,HL
3052:23113+17	A522  CD88A7  	        CALL    STAKFP          ; Put FPREG on stack
3053:23130+4	A525  EB      	        EX      DE,HL
3054:23134+17	A526  CD98A7  	        CALL    FPBCDE          ; Move BCDE to FPREG
3055:23151+10	A529  C1      	        POP     BC              ; Restore number from stack
3056:23161+10	A52A  D1      	        POP     DE
3057:23171+7	A52B  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3058:23178+5+6	A52D  D0      	        RET     NC              ; Yes - First number is result
3059:23183+11	A52E  F5      	        PUSH    AF              ; Save number of bits to scale
3060:23194+17	A52F  CDBDA7  	        CALL    SIGNS           ; Set MSBs & sign of result
3061:23211+4	A532  67      	        LD      H,A             ; Save sign of result
3062:23215+10	A533  F1      	        POP     AF              ; Restore scaling factor
3063:23225+17	A534  CDD6A5  	        CALL    SCALE           ; Scale BCDE to same exponent
3064:23242+4	A537  B4      	        OR      H               ; Result to be positive?
3065:23246+10	A538  2129B1  	        LD      HL,FPREG        ; Point to FPREG
3066:23256+10	A53B  F251A5  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3067:23266+17	A53E  CDB6A5  	        CALL    PLUCDE          ; Add FPREG to CDE
3068:23283+10	A541  D297A5  	        JP      NC,RONDUP       ; No overflow - Round it up
3069:23293+6	A544  23      	        INC     HL              ; Point to exponent
3070:23299+11	A545  34      	        INC     (HL)            ; Increment it
3071:23310+10	A546  CABC94  	        JP      Z,OVERR         ; Number overflowed - Error
3072:23320+7	A549  2E01    	        LD      L,1             ; 1 bit to shift right
3073:23327+17	A54B  CDECA5  	        CALL    SHRT1           ; Shift result right
3074:23344+10	A54E  C397A5  	        JP      RONDUP          ; Round it up
3075:				
3076:23354+4	A551  AF      	MINCDE: XOR     A               ; Clear A and carry
3077:23358+4	A552  90      	        SUB     B               ; Negate exponent
3078:23362+4	A553  47      	        LD      B,A             ; Re-save exponent
3079:23366+7	A554  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3080:23373+4	A555  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3081:23377+4	A556  5F      	        LD      E,A             ; Save LSB of BCDE
3082:23381+6	A557  23      	        INC     HL
3083:23387+7	A558  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3084:23394+4	A559  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3085:23398+4	A55A  57      	        LD      D,A             ; Save NMSB of BCDE
3086:23402+6	A55B  23      	        INC     HL
3087:23408+7	A55C  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3088:23415+4	A55D  99      	        SBC     A,C             ; Subtract MSB of BCDE
3089:23419+4	A55E  4F      	        LD      C,A             ; Save MSB of BCDE
3090:23423+10+7	A55F  DCC2A5  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3091:				
3092:23433+4	A562  68      	BNORM:  LD      L,B             ; L = Exponent
3093:23437+4	A563  63      	        LD      H,E             ; H = LSB
3094:23441+4	A564  AF      	        XOR     A
3095:23445+4	A565  47      	BNRMLP: LD      B,A             ; Save bit count
3096:23449+4	A566  79      	        LD      A,C             ; Get MSB
3097:23453+4	A567  B7      	        OR      A               ; Is it zero?
3098:23457+10	A568  C284A5  	        JP      NZ,PNORM        ; No - Do it bit at a time
3099:23467+4	A56B  4A      	        LD      C,D             ; MSB = NMSB
3100:23471+4	A56C  54      	        LD      D,H             ; NMSB= LSB
3101:23475+4	A56D  65      	        LD      H,L             ; LSB = VLSB
3102:23479+4	A56E  6F      	        LD      L,A             ; VLSB= 0
3103:23483+4	A56F  78      	        LD      A,B             ; Get exponent
3104:23487+7	A570  D608    	        SUB     8               ; Count 8 bits
3105:23494+7	A572  FEE0    	        CP      -24-8           ; Was number zero?
3106:23501+10	A574  C265A5  	        JP      NZ,BNRMLP       ; No - Keep normalising
3107:23511+4	A577  AF      	RESZER: XOR     A               ; Result is zero
3108:23515+13	A578  322CB1  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3109:23528+10	A57B  C9      	        RET
3110:				
3111:23538+4	A57C  05      	NORMAL: DEC     B               ; Count bits
3112:23542+11	A57D  29      	        ADD     HL,HL           ; Shift HL left
3113:23553+4	A57E  7A      	        LD      A,D             ; Get NMSB
3114:23557+4	A57F  17      	        RLA                     ; Shift left with last bit
3115:23561+4	A580  57      	        LD      D,A             ; Save NMSB
3116:23565+4	A581  79      	        LD      A,C             ; Get MSB
3117:23569+4	A582  8F      	        ADC     A,A             ; Shift left with last bit
3118:23573+4	A583  4F      	        LD      C,A             ; Save MSB
3119:23577+10	A584  F27CA5  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3120:23587+4	A587  78      	        LD      A,B             ; Number of bits shifted
3121:23591+4	A588  5C      	        LD      E,H             ; Save HL in EB
3122:23595+4	A589  45      	        LD      B,L
3123:23599+4	A58A  B7      	        OR      A               ; Any shifting done?
3124:23603+10	A58B  CA97A5  	        JP      Z,RONDUP        ; No - Round it up
3125:23613+10	A58E  212CB1  	        LD      HL,FPEXP        ; Point to exponent
3126:23623+7	A591  86      	        ADD     A,(HL)          ; Add shifted bits
3127:23630+7	A592  77      	        LD      (HL),A          ; Re-save exponent
3128:23637+10	A593  D277A5  	        JP      NC,RESZER       ; Underflow - Result is zero
3129:23647+5+6	A596  C8      	        RET     Z               ; Result is zero
3130:23652+4	A597  78      	RONDUP: LD      A,B             ; Get VLSB of number
3131:23656+10	A598  212CB1  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3132:23666+4	A59B  B7      	        OR      A               ; Any rounding?
3133:23670+10+7	A59C  FCA9A5  	        CALL    M,FPROND        ; Yes - Round number up
3134:23680+7	A59F  46      	        LD      B,(HL)          ; B = Exponent
3135:23687+6	A5A0  23      	        INC     HL
3136:23693+7	A5A1  7E      	        LD      A,(HL)          ; Get sign of result
3137:23700+7	A5A2  E680    	        AND     10000000B       ; Only bit 7 needed
3138:23707+4	A5A4  A9      	        XOR     C               ; Set correct sign
3139:23711+4	A5A5  4F      	        LD      C,A             ; Save correct sign in number
3140:23715+10	A5A6  C398A7  	        JP      FPBCDE          ; Move BCDE to FPREG
3141:				
3142:23725+4	A5A9  1C      	FPROND: INC     E               ; Round LSB
3143:23729+5+6	A5AA  C0      	        RET     NZ              ; Return if ok
3144:23734+4	A5AB  14      	        INC     D               ; Round NMSB
3145:23738+5+6	A5AC  C0      	        RET     NZ              ; Return if ok
3146:23743+4	A5AD  0C      	        INC     C               ; Round MSB
3147:23747+5+6	A5AE  C0      	        RET     NZ              ; Return if ok
3148:23752+7	A5AF  0E80    	        LD      C,80H           ; Set normal value
3149:23759+11	A5B1  34      	        INC     (HL)            ; Increment exponent
3150:23770+5+6	A5B2  C0      	        RET     NZ              ; Return if ok
3151:23775+10	A5B3  C3BC94  	        JP      OVERR           ; Overflow error
3152:				
3153:23785+7	A5B6  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3154:23792+4	A5B7  83      	        ADD     A,E             ; Add LSB of BCDE
3155:23796+4	A5B8  5F      	        LD      E,A             ; Save LSB of BCDE
3156:23800+6	A5B9  23      	        INC     HL
3157:23806+7	A5BA  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3158:23813+4	A5BB  8A      	        ADC     A,D             ; Add NMSB of BCDE
3159:23817+4	A5BC  57      	        LD      D,A             ; Save NMSB of BCDE
3160:23821+6	A5BD  23      	        INC     HL
3161:23827+7	A5BE  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3162:23834+4	A5BF  89      	        ADC     A,C             ; Add MSB of BCDE
3163:23838+4	A5C0  4F      	        LD      C,A             ; Save MSB of BCDE
3164:23842+10	A5C1  C9      	        RET
3165:				
3166:23852+10	A5C2  212DB1  	COMPL:  LD      HL,SGNRES       ; Sign of result
3167:23862+7	A5C5  7E      	        LD      A,(HL)          ; Get sign of result
3168:23869+4	A5C6  2F      	        CPL                     ; Negate it
3169:23873+7	A5C7  77      	        LD      (HL),A          ; Put it back
3170:23880+4	A5C8  AF      	        XOR     A
3171:23884+4	A5C9  6F      	        LD      L,A             ; Set L to zero
3172:23888+4	A5CA  90      	        SUB     B               ; Negate exponent,set carry
3173:23892+4	A5CB  47      	        LD      B,A             ; Re-save exponent
3174:23896+4	A5CC  7D      	        LD      A,L             ; Load zero
3175:23900+4	A5CD  9B      	        SBC     A,E             ; Negate LSB
3176:23904+4	A5CE  5F      	        LD      E,A             ; Re-save LSB
3177:23908+4	A5CF  7D      	        LD      A,L             ; Load zero
3178:23912+4	A5D0  9A      	        SBC     A,D             ; Negate NMSB
3179:23916+4	A5D1  57      	        LD      D,A             ; Re-save NMSB
3180:23920+4	A5D2  7D      	        LD      A,L             ; Load zero
3181:23924+4	A5D3  99      	        SBC     A,C             ; Negate MSB
3182:23928+4	A5D4  4F      	        LD      C,A             ; Re-save MSB
3183:23932+10	A5D5  C9      	        RET
3184:				
3185:23942+7	A5D6  0600    	SCALE:  LD      B,0             ; Clear underflow
3186:23949+7	A5D8  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3187:23956+10	A5DA  DAE5A5  	        JP      C,SHRITE        ; No - Shift right A bits
3188:23966+4	A5DD  43      	        LD      B,E             ; <- Shift
3189:23970+4	A5DE  5A      	        LD      E,D             ; <- right
3190:23974+4	A5DF  51      	        LD      D,C             ; <- eight
3191:23978+7	A5E0  0E00    	        LD      C,0             ; <- bits
3192:23985+10	A5E2  C3D8A5  	        JP      SCALLP          ; More bits to shift
3193:				
3194:23995+7	A5E5  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3195:24002+4	A5E7  6F      	        LD      L,A             ; Save bits to shift
3196:24006+4	A5E8  AF      	SHRLP:  XOR     A               ; Flag for all done
3197:24010+4	A5E9  2D      	        DEC     L               ; All shifting done?
3198:24014+5+6	A5EA  C8      	        RET     Z               ; Yes - Return
3199:24019+4	A5EB  79      	        LD      A,C             ; Get MSB
3200:24023+4	A5EC  1F      	SHRT1:  RRA                     ; Shift it right
3201:24027+4	A5ED  4F      	        LD      C,A             ; Re-save
3202:24031+4	A5EE  7A      	        LD      A,D             ; Get NMSB
3203:24035+4	A5EF  1F      	        RRA                     ; Shift right with last bit
3204:24039+4	A5F0  57      	        LD      D,A             ; Re-save it
3205:24043+4	A5F1  7B      	        LD      A,E             ; Get LSB
3206:24047+4	A5F2  1F      	        RRA                     ; Shift right with last bit
3207:24051+4	A5F3  5F      	        LD      E,A             ; Re-save it
3208:24055+4	A5F4  78      	        LD      A,B             ; Get underflow
3209:24059+4	A5F5  1F      	        RRA                     ; Shift right with last bit
3210:24063+4	A5F6  47      	        LD      B,A             ; Re-save underflow
3211:24067+10	A5F7  C3E8A5  	        JP      SHRLP           ; More bits to do
3212:				
3213:     -	A5FA  00000081	UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3214:				
3215:     -	A5FE  03      	LOGTAB: .BYTE      3                       ; Table used by LOG
3216:     -	A5FF  AA561980	        .BYTE      0AAH,056H,019H,080H     ; 0.59898
3217:     -	A603  F1227680	        .BYTE      0F1H,022H,076H,080H     ; 0.96147
3218:     -	A607  45AA3882	        .BYTE      045H,0AAH,038H,082H     ; 2.88539
3219:				
3220:24077+17	A60B  CD57A7  	LOG:    CALL    TSTSGN          ; Test sign of value
3221:24094+4	A60E  B7      	        OR      A
3222:24098+10	A60F  EACF99  	        JP      PE,FCERR        ; ?FC Error if <= zero
3223:24108+10	A612  212CB1  	        LD      HL,FPEXP        ; Point to exponent
3224:24118+7	A615  7E      	        LD      A,(HL)          ; Get exponent
3225:24125+10	A616  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3226:24135+10	A619  11F304  	        LD      DE,04F3H
3227:24145+4	A61C  90      	        SUB     B               ; Scale value to be < 1
3228:24149+11	A61D  F5      	        PUSH    AF              ; Save scale factor
3229:24160+7	A61E  70      	        LD      (HL),B          ; Save new exponent
3230:24167+11	A61F  D5      	        PUSH    DE              ; Save SQR(1/2)
3231:24178+11	A620  C5      	        PUSH    BC
3232:24189+17	A621  CD11A5  	        CALL    FPADD           ; Add SQR(1/2) to value
3233:24206+10	A624  C1      	        POP     BC              ; Restore SQR(1/2)
3234:24216+10	A625  D1      	        POP     DE
3235:24226+4	A626  04      	        INC     B               ; Make it SQR(2)
3236:24230+17	A627  CDADA6  	        CALL    DVBCDE          ; Divide by SQR(2)
3237:24247+10	A62A  21FAA5  	        LD      HL,UNITY        ; Point to 1.
3238:24257+17	A62D  CD08A5  	        CALL    SUBPHL          ; Subtract FPREG from 1
3239:24274+10	A630  21FEA5  	        LD      HL,LOGTAB       ; Coefficient table
3240:24284+17	A633  CD9FAA  	        CALL    SUMSER          ; Evaluate sum of series
3241:24301+10	A636  018080  	        LD      BC,8080H        ; BCDE = -0.5
3242:24311+10	A639  110000  	        LD      DE,0000H
3243:24321+17	A63C  CD11A5  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3244:24338+10	A63F  F1      	        POP     AF              ; Restore scale factor
3245:24348+17	A640  CDD2A8  	        CALL    RSCALE          ; Re-scale number
3246:24365+10	A643  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3247:24375+10	A646  111872  	        LD      DE,7218H
3248:     -	A649  21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
3249:				
3250:24385+10	A64A  C1      	MULT:   POP     BC              ; Get number from stack
3251:24395+10	A64B  D1      	        POP     DE
3252:24405+17	A64C  CD57A7  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3253:24422+5+6	A64F  C8      	        RET     Z               ; Return zero if zero
3254:24427+7	A650  2E00    	        LD      L,0             ; Flag add exponents
3255:24434+17	A652  CD15A7  	        CALL    ADDEXP          ; Add exponents
3256:24451+4	A655  79      	        LD      A,C             ; Get MSB of multiplier
3257:24455+13	A656  323BB1  	        LD      (MULVAL),A      ; Save MSB of multiplier
3258:24468+4	A659  EB      	        EX      DE,HL
3259:24472+16	A65A  223CB1  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3260:24488+10	A65D  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3261:24498+4	A660  50      	        LD      D,B
3262:24502+4	A661  58      	        LD      E,B
3263:24506+10	A662  2162A5  	        LD      HL,BNORM        ; Address of normalise
3264:24516+11	A665  E5      	        PUSH    HL              ; Save for return
3265:24527+10	A666  216EA6  	        LD      HL,MULT8        ; Address of 8 bit multiply
3266:24537+11	A669  E5      	        PUSH    HL              ; Save for NMSB,MSB
3267:24548+11	A66A  E5      	        PUSH    HL              ; 
3268:24559+10	A66B  2129B1  	        LD      HL,FPREG        ; Point to number
3269:24569+7	A66E  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3270:24576+6	A66F  23      	        INC     HL              ; Point to NMSB
3271:24582+4	A670  B7      	        OR      A               ; Test LSB
3272:24586+10	A671  CA9AA6  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3273:24596+11	A674  E5      	        PUSH    HL              ; Save address of number
3274:24607+7	A675  2E08    	        LD      L,8             ; 8 bits to multiply by
3275:24614+4	A677  1F      	MUL8LP: RRA                     ; Shift LSB right
3276:24618+4	A678  67      	        LD      H,A             ; Save LSB
3277:24622+4	A679  79      	        LD      A,C             ; Get MSB
3278:24626+10	A67A  D288A6  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3279:24636+11	A67D  E5      	        PUSH    HL              ; Save LSB and count
3280:24647+16	A67E  2A3CB1  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3281:24663+11	A681  19      	        ADD     HL,DE           ; Add NMSB and LSB
3282:24674+4	A682  EB      	        EX      DE,HL           ; Leave sum in DE
3283:24678+10	A683  E1      	        POP     HL              ; Restore MSB and count
3284:24688+13	A684  3A3BB1  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3285:24701+4	A687  89      	        ADC     A,C             ; Add MSB
3286:24705+4	A688  1F      	NOMADD: RRA                     ; Shift MSB right
3287:24709+4	A689  4F      	        LD      C,A             ; Re-save MSB
3288:24713+4	A68A  7A      	        LD      A,D             ; Get NMSB
3289:24717+4	A68B  1F      	        RRA                     ; Shift NMSB right
3290:24721+4	A68C  57      	        LD      D,A             ; Re-save NMSB
3291:24725+4	A68D  7B      	        LD      A,E             ; Get LSB
3292:24729+4	A68E  1F      	        RRA                     ; Shift LSB right
3293:24733+4	A68F  5F      	        LD      E,A             ; Re-save LSB
3294:24737+4	A690  78      	        LD      A,B             ; Get VLSB
3295:24741+4	A691  1F      	        RRA                     ; Shift VLSB right
3296:24745+4	A692  47      	        LD      B,A             ; Re-save VLSB
3297:24749+4	A693  2D      	        DEC     L               ; Count bits multiplied
3298:24753+4	A694  7C      	        LD      A,H             ; Get LSB of multiplier
3299:24757+10	A695  C277A6  	        JP      NZ,MUL8LP       ; More - Do it
3300:24767+10	A698  E1      	POPHRT: POP     HL              ; Restore address of number
3301:24777+10	A699  C9      	        RET
3302:				
3303:24787+4	A69A  43      	BYTSFT: LD      B,E             ; Shift partial product left
3304:24791+4	A69B  5A      	        LD      E,D
3305:24795+4	A69C  51      	        LD      D,C
3306:24799+4	A69D  4F      	        LD      C,A
3307:24803+10	A69E  C9      	        RET
3308:				
3309:24813+17	A69F  CD88A7  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
3310:24830+10	A6A2  012084  	        LD      BC,8420H        ; BCDE = 10.
3311:24840+10	A6A5  110000  	        LD      DE,0000H
3312:24850+17	A6A8  CD98A7  	        CALL    FPBCDE          ; Move 10 to FPREG
3313:				
3314:24867+10	A6AB  C1      	DIV:    POP     BC              ; Get number from stack
3315:24877+10	A6AC  D1      	        POP     DE
3316:24887+17	A6AD  CD57A7  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3317:24904+10	A6B0  CAB094  	        JP      Z,DZERR         ; Error if division by zero
3318:24914+7	A6B3  2EFF    	        LD      L,-1            ; Flag subtract exponents
3319:24921+17	A6B5  CD15A7  	        CALL    ADDEXP          ; Subtract exponents
3320:24938+11	A6B8  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3321:24949+11	A6B9  34      	        INC     (HL)
3322:24960+6	A6BA  2B      	        DEC     HL              ; Point to MSB
3323:24966+7	A6BB  7E      	        LD      A,(HL)          ; Get MSB of dividend
3324:24973+13	A6BC  3257B0  	        LD      (DIV3),A        ; Save for subtraction
3325:24986+6	A6BF  2B      	        DEC     HL
3326:24992+7	A6C0  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3327:24999+13	A6C1  3253B0  	        LD      (DIV2),A        ; Save for subtraction
3328:25012+6	A6C4  2B      	        DEC     HL
3329:25018+7	A6C5  7E      	        LD      A,(HL)          ; Get MSB of dividend
3330:25025+13	A6C6  324FB0  	        LD      (DIV1),A        ; Save for subtraction
3331:25038+4	A6C9  41      	        LD      B,C             ; Get MSB
3332:25042+4	A6CA  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3333:25046+4	A6CB  AF      	        XOR     A
3334:25050+4	A6CC  4F      	        LD      C,A             ; Clear MSB of quotient
3335:25054+4	A6CD  57      	        LD      D,A             ; Clear NMSB of quotient
3336:25058+4	A6CE  5F      	        LD      E,A             ; Clear LSB of quotient
3337:25062+13	A6CF  325AB0  	        LD      (DIV4),A        ; Clear overflow count
3338:25075+11	A6D2  E5      	DIVLP:  PUSH    HL              ; Save divisor
3339:25086+11	A6D3  C5      	        PUSH    BC
3340:25097+4	A6D4  7D      	        LD      A,L             ; Get LSB of number
3341:25101+17	A6D5  CD4EB0  	        CALL    DIVSUP          ; Subt' divisor from dividend
3342:25118+7	A6D8  DE00    	        SBC     A,0             ; Count for overflows
3343:25125+4	A6DA  3F      	        CCF
3344:25129+10	A6DB  D2E5A6  	        JP      NC,RESDIV       ; Restore divisor if borrow
3345:25139+13	A6DE  325AB0  	        LD      (DIV4),A        ; Re-save overflow count
3346:25152+10	A6E1  F1      	        POP     AF              ; Scrap divisor
3347:25162+10	A6E2  F1      	        POP     AF
3348:25172+4	A6E3  37      	        SCF                     ; Set carry to
3349:     -	A6E4  D2      	        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3350:				
3351:25176+10	A6E5  C1      	RESDIV: POP     BC              ; Restore divisor
3352:25186+10	A6E6  E1      	        POP     HL
3353:25196+4	A6E7  79      	        LD      A,C             ; Get MSB of quotient
3354:25200+4	A6E8  3C      	        INC     A
3355:25204+4	A6E9  3D      	        DEC     A
3356:25208+4	A6EA  1F      	        RRA                     ; Bit 0 to bit 7
3357:25212+10	A6EB  FA98A5  	        JP      M,RONDB         ; Done - Normalise result
3358:25222+4	A6EE  17      	        RLA                     ; Restore carry
3359:25226+4	A6EF  7B      	        LD      A,E             ; Get LSB of quotient
3360:25230+4	A6F0  17      	        RLA                     ; Double it
3361:25234+4	A6F1  5F      	        LD      E,A             ; Put it back
3362:25238+4	A6F2  7A      	        LD      A,D             ; Get NMSB of quotient
3363:25242+4	A6F3  17      	        RLA                     ; Double it
3364:25246+4	A6F4  57      	        LD      D,A             ; Put it back
3365:25250+4	A6F5  79      	        LD      A,C             ; Get MSB of quotient
3366:25254+4	A6F6  17      	        RLA                     ; Double it
3367:25258+4	A6F7  4F      	        LD      C,A             ; Put it back
3368:25262+11	A6F8  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3369:25273+4	A6F9  78      	        LD      A,B             ; Get MSB of divisor
3370:25277+4	A6FA  17      	        RLA                     ; Double it
3371:25281+4	A6FB  47      	        LD      B,A             ; Put it back
3372:25285+13	A6FC  3A5AB0  	        LD      A,(DIV4)        ; Get VLSB of quotient
3373:25298+4	A6FF  17      	        RLA                     ; Double it
3374:25302+13	A700  325AB0  	        LD      (DIV4),A        ; Put it back
3375:25315+4	A703  79      	        LD      A,C             ; Get MSB of quotient
3376:25319+4	A704  B2      	        OR      D               ; Merge NMSB
3377:25323+4	A705  B3      	        OR      E               ; Merge LSB
3378:25327+10	A706  C2D2A6  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3379:25337+11	A709  E5      	        PUSH    HL              ; Save divisor
3380:25348+10	A70A  212CB1  	        LD      HL,FPEXP        ; Point to exponent
3381:25358+11	A70D  35      	        DEC     (HL)            ; Divide by 2
3382:25369+10	A70E  E1      	        POP     HL              ; Restore divisor
3383:25379+10	A70F  C2D2A6  	        JP      NZ,DIVLP        ; Ok - Keep going
3384:25389+10	A712  C3BC94  	        JP      OVERR           ; Overflow error
3385:				
3386:25399+4	A715  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3387:25403+4	A716  B7      	        OR      A               ; Test it
3388:25407+10	A717  CA39A7  	        JP      Z,OVTST3        ; Zero - Result zero
3389:25417+4	A71A  7D      	        LD      A,L             ; Get add/subtract flag
3390:25421+10	A71B  212CB1  	        LD      HL,FPEXP        ; Point to exponent
3391:25431+7	A71E  AE      	        XOR     (HL)            ; Add or subtract it
3392:25438+4	A71F  80      	        ADD     A,B             ; Add the other exponent
3393:25442+4	A720  47      	        LD      B,A             ; Save new exponent
3394:25446+4	A721  1F      	        RRA                     ; Test exponent for overflow
3395:25450+4	A722  A8      	        XOR     B
3396:25454+4	A723  78      	        LD      A,B             ; Get exponent
3397:25458+10	A724  F238A7  	        JP      P,OVTST2        ; Positive - Test for overflow
3398:25468+7	A727  C680    	        ADD     A,80H           ; Add excess 128
3399:25475+7	A729  77      	        LD      (HL),A          ; Save new exponent
3400:25482+10	A72A  CA98A6  	        JP      Z,POPHRT        ; Zero - Result zero
3401:25492+17	A72D  CDBDA7  	        CALL    SIGNS           ; Set MSBs and sign of result
3402:25509+7	A730  77      	        LD      (HL),A          ; Save new exponent
3403:25516+6	A731  2B      	        DEC     HL              ; Point to MSB
3404:25522+10	A732  C9      	        RET
3405:				
3406:25532+17	A733  CD57A7  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3407:25549+4	A736  2F      	        CPL                     ; Invert sign
3408:25553+10	A737  E1      	        POP     HL              ; Clean up stack
3409:25563+4	A738  B7      	OVTST2: OR      A               ; Test if new exponent zero
3410:25567+10	A739  E1      	OVTST3: POP     HL              ; Clear off return address
3411:25577+10	A73A  F277A5  	        JP      P,RESZER        ; Result zero
3412:25587+10	A73D  C3BC94  	        JP      OVERR           ; Overflow error
3413:				
3414:25597+17	A740  CDA3A7  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3415:25614+4	A743  78      	        LD      A,B             ; Get exponent
3416:25618+4	A744  B7      	        OR      A               ; Is it zero?
3417:25622+5+6	A745  C8      	        RET     Z               ; Yes - Result is zero
3418:25627+7	A746  C602    	        ADD     A,2             ; Multiply by 4
3419:25634+10	A748  DABC94  	        JP      C,OVERR         ; Overflow - ?OV Error
3420:25644+4	A74B  47      	        LD      B,A             ; Re-save exponent
3421:25648+17	A74C  CD11A5  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3422:25665+10	A74F  212CB1  	        LD      HL,FPEXP        ; Point to exponent
3423:25675+11	A752  34      	        INC     (HL)            ; Double number (Times 10)
3424:25686+5+6	A753  C0      	        RET     NZ              ; Ok - Return
3425:25691+10	A754  C3BC94  	        JP      OVERR           ; Overflow error
3426:				
3427:25701+13	A757  3A2CB1  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3428:25714+4	A75A  B7      	        OR      A
3429:25718+5+6	A75B  C8      	        RET     Z               ; RETurn if number is zero
3430:25723+13	A75C  3A2BB1  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3431:     -	A75F  FE      	        .BYTE      0FEH            ; Test sign
3432:25736+4	A760  2F      	RETREL: CPL                     ; Invert sign
3433:25740+4	A761  17      	        RLA                     ; Sign bit to carry
3434:25744+4	A762  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3435:25748+5+6	A763  C0      	        RET     NZ              ; Return -1 if negative
3436:25753+4	A764  3C      	        INC     A               ; Bump to +1
3437:25757+10	A765  C9      	        RET                     ; Positive - Return +1
3438:				
3439:25767+17	A766  CD57A7  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3440:25784+7	A769  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3441:25791+10	A76B  110000  	        LD      DE,0            ; Zero NMSB and LSB
3442:25801+10	A76E  212CB1  	RETINT: LD      HL,FPEXP        ; Point to exponent
3443:25811+4	A771  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3444:25815+7	A772  70      	        LD      (HL),B          ; Save exponent
3445:25822+7	A773  0600    	        LD      B,0             ; CDE = integer to normalise
3446:25829+6	A775  23      	        INC     HL              ; Point to sign of result
3447:25835+10	A776  3680    	        LD      (HL),80H        ; Set sign of result
3448:25845+4	A778  17      	        RLA                     ; Carry = sign of integer
3449:25849+10	A779  C35FA5  	        JP      CONPOS          ; Set sign of result
3450:				
3451:25859+17	A77C  CD57A7  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3452:25876+5+6	A77F  F0      	        RET     P               ; Return if positive
3453:25881+10	A780  212BB1  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3454:25891+7	A783  7E      	        LD      A,(HL)          ; Get sign of mantissa
3455:25898+7	A784  EE80    	        XOR     80H             ; Invert sign of mantissa
3456:25905+7	A786  77      	        LD      (HL),A          ; Re-save sign of mantissa
3457:25912+10	A787  C9      	        RET
3458:				
3459:25922+4	A788  EB      	STAKFP: EX      DE,HL           ; Save code string address
3460:25926+16	A789  2A29B1  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3461:25942+19	A78C  E3      	        EX      (SP),HL         ; Stack them,get return
3462:25961+11	A78D  E5      	        PUSH    HL              ; Re-save return
3463:25972+16	A78E  2A2BB1  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3464:25988+19	A791  E3      	        EX      (SP),HL         ; Stack them,get return
3465:26007+11	A792  E5      	        PUSH    HL              ; Re-save return
3466:26018+4	A793  EB      	        EX      DE,HL           ; Restore code string address
3467:26022+10	A794  C9      	        RET
3468:				
3469:26032+17	A795  CDA6A7  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3470:26049+4	A798  EB      	FPBCDE: EX      DE,HL           ; Save code string address
3471:26053+16	A799  2229B1  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3472:26069+4	A79C  60      	        LD      H,B             ; Exponent of number
3473:26073+4	A79D  69      	        LD      L,C             ; MSB of number
3474:26077+16	A79E  222BB1  	        LD      (FPREG+2),HL    ; Save MSB and exponent
3475:26093+4	A7A1  EB      	        EX      DE,HL           ; Restore code string address
3476:26097+10	A7A2  C9      	        RET
3477:				
3478:26107+10	A7A3  2129B1  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
3479:26117+7	A7A6  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3480:26124+6	A7A7  23      	        INC     HL
3481:26130+7	A7A8  56      	        LD      D,(HL)          ; Get NMSB of number
3482:26137+6	A7A9  23      	        INC     HL
3483:26143+7	A7AA  4E      	        LD      C,(HL)          ; Get MSB of number
3484:26150+6	A7AB  23      	        INC     HL
3485:26156+7	A7AC  46      	        LD      B,(HL)          ; Get exponent of number
3486:26163+6	A7AD  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3487:26169+10	A7AE  C9      	        RET
3488:				
3489:26179+10	A7AF  1129B1  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
3490:26189+7	A7B2  0604    	DETHL4: LD      B,4             ; 4 bytes to move
3491:26196+7	A7B4  1A      	DETHLB: LD      A,(DE)          ; Get source
3492:26203+7	A7B5  77      	        LD      (HL),A          ; Save destination
3493:26210+6	A7B6  13      	        INC     DE              ; Next source
3494:26216+6	A7B7  23      	        INC     HL              ; Next destination
3495:26222+4	A7B8  05      	        DEC     B               ; Count bytes
3496:26226+10	A7B9  C2B4A7  	        JP      NZ,DETHLB       ; Loop if more
3497:26236+10	A7BC  C9      	        RET
3498:				
3499:26246+10	A7BD  212BB1  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3500:26256+7	A7C0  7E      	        LD      A,(HL)          ; Get MSB
3501:26263+4	A7C1  07      	        RLCA                    ; Old sign to carry
3502:26267+4	A7C2  37      	        SCF                     ; Set MSBit
3503:26271+4	A7C3  1F      	        RRA                     ; Set MSBit of MSB
3504:26275+7	A7C4  77      	        LD      (HL),A          ; Save new MSB
3505:26282+4	A7C5  3F      	        CCF                     ; Complement sign
3506:26286+4	A7C6  1F      	        RRA                     ; Old sign to carry
3507:26290+6	A7C7  23      	        INC     HL
3508:26296+6	A7C8  23      	        INC     HL
3509:26302+7	A7C9  77      	        LD      (HL),A          ; Set sign of result
3510:26309+4	A7CA  79      	        LD      A,C             ; Get MSB
3511:26313+4	A7CB  07      	        RLCA                    ; Old sign to carry
3512:26317+4	A7CC  37      	        SCF                     ; Set MSBit
3513:26321+4	A7CD  1F      	        RRA                     ; Set MSBit of MSB
3514:26325+4	A7CE  4F      	        LD      C,A             ; Save MSB
3515:26329+4	A7CF  1F      	        RRA
3516:26333+7	A7D0  AE      	        XOR     (HL)            ; New sign of result
3517:26340+10	A7D1  C9      	        RET
3518:				
3519:26350+4	A7D2  78      	CMPNUM: LD      A,B             ; Get exponent of number
3520:26354+4	A7D3  B7      	        OR      A
3521:26358+10	A7D4  CA57A7  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3522:26368+10	A7D7  2160A7  	        LD      HL,RETREL       ; Return relation routine
3523:26378+11	A7DA  E5      	        PUSH    HL              ; Save for return
3524:26389+17	A7DB  CD57A7  	        CALL    TSTSGN          ; Test sign of FPREG
3525:26406+4	A7DE  79      	        LD      A,C             ; Get MSB of number
3526:26410+5+6	A7DF  C8      	        RET     Z               ; FPREG zero - Number's MSB
3527:26415+10	A7E0  212BB1  	        LD      HL,FPREG+2      ; MSB of FPREG
3528:26425+7	A7E3  AE      	        XOR     (HL)            ; Combine signs
3529:26432+4	A7E4  79      	        LD      A,C             ; Get MSB of number
3530:26436+5+6	A7E5  F8      	        RET     M               ; Exit if signs different
3531:26441+17	A7E6  CDECA7  	        CALL    CMPFP           ; Compare FP numbers
3532:26458+4	A7E9  1F      	        RRA                     ; Get carry to sign
3533:26462+4	A7EA  A9      	        XOR     C               ; Combine with MSB of number
3534:26466+10	A7EB  C9      	        RET
3535:				
3536:26476+6	A7EC  23      	CMPFP:  INC     HL              ; Point to exponent
3537:26482+4	A7ED  78      	        LD      A,B             ; Get exponent
3538:26486+7	A7EE  BE      	        CP      (HL)            ; Compare exponents
3539:26493+5+6	A7EF  C0      	        RET     NZ              ; Different
3540:26498+6	A7F0  2B      	        DEC     HL              ; Point to MBS
3541:26504+4	A7F1  79      	        LD      A,C             ; Get MSB
3542:26508+7	A7F2  BE      	        CP      (HL)            ; Compare MSBs
3543:26515+5+6	A7F3  C0      	        RET     NZ              ; Different
3544:26520+6	A7F4  2B      	        DEC     HL              ; Point to NMSB
3545:26526+4	A7F5  7A      	        LD      A,D             ; Get NMSB
3546:26530+7	A7F6  BE      	        CP      (HL)            ; Compare NMSBs
3547:26537+5+6	A7F7  C0      	        RET     NZ              ; Different
3548:26542+6	A7F8  2B      	        DEC     HL              ; Point to LSB
3549:26548+4	A7F9  7B      	        LD      A,E             ; Get LSB
3550:26552+7	A7FA  96      	        SUB     (HL)            ; Compare LSBs
3551:26559+5+6	A7FB  C0      	        RET     NZ              ; Different
3552:26564+10	A7FC  E1      	        POP     HL              ; Drop RETurn
3553:26574+10	A7FD  E1      	        POP     HL              ; Drop another RETurn
3554:26584+10	A7FE  C9      	        RET
3555:				
3556:26594+4	A7FF  47      	FPINT:  LD      B,A             ; <- Move
3557:26598+4	A800  4F      	        LD      C,A             ; <- exponent
3558:26602+4	A801  57      	        LD      D,A             ; <- to all
3559:26606+4	A802  5F      	        LD      E,A             ; <- bits
3560:26610+4	A803  B7      	        OR      A               ; Test exponent
3561:26614+5+6	A804  C8      	        RET     Z               ; Zero - Return zero
3562:26619+11	A805  E5      	        PUSH    HL              ; Save pointer to number
3563:26630+17	A806  CDA3A7  	        CALL    BCDEFP          ; Move FPREG to BCDE
3564:26647+17	A809  CDBDA7  	        CALL    SIGNS           ; Set MSBs & sign of result
3565:26664+7	A80C  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3566:26671+4	A80D  67      	        LD      H,A             ; Save combined signs
3567:26675+10+7	A80E  FC23A8  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3568:26685+7	A811  3E98    	        LD      A,80H+24        ; 24 bits
3569:26692+4	A813  90      	        SUB     B               ; Bits to shift
3570:26696+17	A814  CDD6A5  	        CALL    SCALE           ; Shift BCDE
3571:26713+4	A817  7C      	        LD      A,H             ; Get combined sign
3572:26717+4	A818  17      	        RLA                     ; Sign to carry
3573:26721+10+7	A819  DCA9A5  	        CALL    C,FPROND        ; Negative - Round number up
3574:26731+7	A81C  0600    	        LD      B,0             ; Zero exponent
3575:26738+10+7	A81E  DCC2A5  	        CALL    C,COMPL         ; If negative make positive
3576:26748+10	A821  E1      	        POP     HL              ; Restore pointer to number
3577:26758+10	A822  C9      	        RET
3578:				
3579:26768+6	A823  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3580:26774+4	A824  7A      	        LD      A,D             ; Test LSBs
3581:26778+4	A825  A3      	        AND     E
3582:26782+4	A826  3C      	        INC     A
3583:26786+5+6	A827  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3584:26791+6	A828  0B      	        DEC     BC              ; Decrement MSBs
3585:26797+10	A829  C9      	        RET
3586:				
3587:26807+10	A82A  212CB1  	INT:    LD      HL,FPEXP        ; Point to exponent
3588:26817+7	A82D  7E      	        LD      A,(HL)          ; Get exponent
3589:26824+7	A82E  FE98    	        CP      80H+24          ; Integer accuracy only?
3590:26831+13	A830  3A29B1  	        LD      A,(FPREG)       ; Get LSB
3591:26844+5+6	A833  D0      	        RET     NC              ; Yes - Already integer
3592:26849+7	A834  7E      	        LD      A,(HL)          ; Get exponent
3593:26856+17	A835  CDFFA7  	        CALL    FPINT           ; F.P to integer
3594:26873+10	A838  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3595:26883+4	A83A  7B      	        LD      A,E             ; Get LSB of number
3596:26887+11	A83B  F5      	        PUSH    AF              ; Save LSB
3597:26898+4	A83C  79      	        LD      A,C             ; Get MSB of number
3598:26902+4	A83D  17      	        RLA                     ; Sign to carry
3599:26906+17	A83E  CD5FA5  	        CALL    CONPOS          ; Set sign of result
3600:26923+10	A841  F1      	        POP     AF              ; Restore LSB of number
3601:26933+10	A842  C9      	        RET
3602:				
3603:26943+10	A843  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3604:26953+4	A846  78      	        LD      A,B             ; Test multiplier
3605:26957+4	A847  B1      	        OR      C
3606:26961+5+6	A848  C8      	        RET     Z               ; Return zero if zero
3607:26966+7	A849  3E10    	        LD      A,16            ; 16 bits
3608:26973+11	A84B  29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3609:26984+10	A84C  DA83A0  	        JP      C,BSERR         ; ?BS Error if overflow
3610:26994+4	A84F  EB      	        EX      DE,HL
3611:26998+11	A850  29      	        ADD     HL,HL           ; Shift multiplier left
3612:27009+4	A851  EB      	        EX      DE,HL
3613:27013+10	A852  D259A8  	        JP      NC,NOMLAD       ; Bit was zero - No add
3614:27023+11	A855  09      	        ADD     HL,BC           ; Add multiplicand
3615:27034+10	A856  DA83A0  	        JP      C,BSERR         ; ?BS Error if overflow
3616:27044+4	A859  3D      	NOMLAD: DEC     A               ; Count bits
3617:27048+10	A85A  C24BA8  	        JP      NZ,MLDBLP       ; More
3618:27058+10	A85D  C9      	        RET
3619:				
3620:27068+7	A85E  FE2D    	ASCTFP: CP      '-'             ; Negative?
3621:27075+11	A860  F5      	        PUSH    AF              ; Save it and flags
3622:27086+10	A861  CA6AA8  	        JP      Z,CNVNUM        ; Yes - Convert number
3623:27096+7	A864  FE2B    	        CP      '+'             ; Positive?
3624:27103+10	A866  CA6AA8  	        JP      Z,CNVNUM        ; Yes - Convert number
3625:27113+6	A869  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3626:27119+17	A86A  CD77A5  	CNVNUM: CALL    RESZER          ; Set result to zero
3627:27136+4	A86D  47      	        LD      B,A             ; Digits after point counter
3628:27140+4	A86E  57      	        LD      D,A             ; Sign of exponent
3629:27144+4	A86F  5F      	        LD      E,A             ; Exponent of ten
3630:27148+4	A870  2F      	        CPL
3631:27152+4	A871  4F      	        LD      C,A             ; Before or after point flag
3632:27156+17	A872  CD0599  	MANLP:  CALL    GETCHR          ; Get next character
3633:27173+10	A875  DABBA8  	        JP      C,ADDIG         ; Digit - Add to number
3634:27183+7	A878  FE2E    	        CP      '.'
3635:27190+10	A87A  CA96A8  	        JP      Z,DPOINT        ; '.' - Flag point
3636:27200+7	A87D  FE45    	        CP      'E'
3637:27207+10	A87F  C29AA8  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3638:27217+17	A882  CD0599  	        CALL    GETCHR          ; Get next character
3639:27234+17	A885  CDAE9E  	        CALL    SGNEXP          ; Get sign of exponent
3640:27251+17	A888  CD0599  	EXPLP:  CALL    GETCHR          ; Get next character
3641:27268+10	A88B  DADDA8  	        JP      C,EDIGIT        ; Digit - Add to exponent
3642:27278+4	A88E  14      	        INC     D               ; Is sign negative?
3643:27282+10	A88F  C29AA8  	        JP      NZ,CONEXP       ; No - Scale number
3644:27292+4	A892  AF      	        XOR     A
3645:27296+4	A893  93      	        SUB     E               ; Negate exponent
3646:27300+4	A894  5F      	        LD      E,A             ; And re-save it
3647:27304+4	A895  0C      	        INC     C               ; Flag end of number
3648:27308+4	A896  0C      	DPOINT: INC     C               ; Flag point passed
3649:27312+10	A897  CA72A8  	        JP      Z,MANLP         ; Zero - Get another digit
3650:27322+11	A89A  E5      	CONEXP: PUSH    HL              ; Save code string address
3651:27333+4	A89B  7B      	        LD      A,E             ; Get exponent
3652:27337+4	A89C  90      	        SUB     B               ; Subtract digits after point
3653:27341+10+7	A89D  F4B3A8  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3654:27351+10	A8A0  F2A9A8  	        JP      P,ENDCON        ; Positive - All done
3655:27361+11	A8A3  F5      	        PUSH    AF              ; Save number of times to /10
3656:27372+17	A8A4  CD9FA6  	        CALL    DIV10           ; Divide by 10
3657:27389+10	A8A7  F1      	        POP     AF              ; Restore count
3658:27399+4	A8A8  3C      	        INC     A               ; Count divides
3659:				
3660:27403+10	A8A9  C29DA8  	ENDCON: JP      NZ,SCALMI       ; More to do
3661:27413+10	A8AC  D1      	        POP     DE              ; Restore code string address
3662:27423+10	A8AD  F1      	        POP     AF              ; Restore sign of number
3663:27433+10+7	A8AE  CC80A7  	        CALL    Z,INVSGN        ; Negative - Negate number
3664:27443+4	A8B1  EB      	        EX      DE,HL           ; Code string address to HL
3665:27447+10	A8B2  C9      	        RET
3666:				
3667:27457+5+6	A8B3  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3668:27462+11	A8B4  F5      	MULTEN: PUSH    AF              ; Save count
3669:27473+17	A8B5  CD40A7  	        CALL    MLSP10          ; Multiply number by 10
3670:27490+10	A8B8  F1      	        POP     AF              ; Restore count
3671:27500+4	A8B9  3D      	        DEC     A               ; Count multiplies
3672:27504+10	A8BA  C9      	        RET
3673:				
3674:27514+11	A8BB  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3675:27525+4	A8BC  57      	        LD      D,A             ; Save digit
3676:27529+4	A8BD  78      	        LD      A,B             ; Get digits after point
3677:27533+4	A8BE  89      	        ADC     A,C             ; Add one if after point
3678:27537+4	A8BF  47      	        LD      B,A             ; Re-save counter
3679:27541+11	A8C0  C5      	        PUSH    BC              ; Save point flags
3680:27552+11	A8C1  E5      	        PUSH    HL              ; Save code string address
3681:27563+11	A8C2  D5      	        PUSH    DE              ; Save digit
3682:27574+17	A8C3  CD40A7  	        CALL    MLSP10          ; Multiply number by 10
3683:27591+10	A8C6  F1      	        POP     AF              ; Restore digit
3684:27601+7	A8C7  D630    	        SUB     '0'             ; Make it absolute
3685:27608+17	A8C9  CDD2A8  	        CALL    RSCALE          ; Re-scale number
3686:27625+10	A8CC  E1      	        POP     HL              ; Restore code string address
3687:27635+10	A8CD  C1      	        POP     BC              ; Restore point flags
3688:27645+10	A8CE  D1      	        POP     DE              ; Restore sign of exponent
3689:27655+10	A8CF  C372A8  	        JP      MANLP           ; Get another digit
3690:				
3691:27665+17	A8D2  CD88A7  	RSCALE: CALL    STAKFP          ; Put number on stack
3692:27682+17	A8D5  CD69A7  	        CALL    FLGREL          ; Digit to add to FPREG
3693:27699+10	A8D8  C1      	PADD:   POP     BC              ; Restore number
3694:27709+10	A8D9  D1      	        POP     DE
3695:27719+10	A8DA  C311A5  	        JP      FPADD           ; Add BCDE to FPREG and return
3696:				
3697:27729+4	A8DD  7B      	EDIGIT: LD      A,E             ; Get digit
3698:27733+4	A8DE  07      	        RLCA                    ; Times 2
3699:27737+4	A8DF  07      	        RLCA                    ; Times 4
3700:27741+4	A8E0  83      	        ADD     A,E             ; Times 5
3701:27745+4	A8E1  07      	        RLCA                    ; Times 10
3702:27749+7	A8E2  86      	        ADD     A,(HL)          ; Add next digit
3703:27756+7	A8E3  D630    	        SUB     '0'             ; Make it absolute
3704:27763+4	A8E5  5F      	        LD      E,A             ; Save new digit
3705:27767+10	A8E6  C388A8  	        JP      EXPLP           ; Look for another digit
3706:				
3707:27777+11	A8E9  E5      	LINEIN: PUSH    HL              ; Save code string address
3708:27788+10	A8EA  214594  	        LD      HL,INMSG        ; Output " in "
3709:27798+17	A8ED  CD4EA2  	        CALL    PRS             ; Output string at HL
3710:27815+10	A8F0  E1      	        POP     HL              ; Restore code string address
3711:27825+4	A8F1  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3712:27829+4	A8F2  AF      	        XOR     A
3713:27833+7	A8F3  0698    	        LD      B,80H+24        ; 24 bits
3714:27840+17	A8F5  CD6EA7  	        CALL    RETINT          ; Return the integer
3715:27857+10	A8F8  214DA2  	        LD      HL,PRNUMS       ; Print number string
3716:27867+11	A8FB  E5      	        PUSH    HL              ; Save for return
3717:27878+10	A8FC  212EB1  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3718:27888+11	A8FF  E5      	        PUSH    HL              ; Save for return
3719:27899+17	A900  CD57A7  	        CALL    TSTSGN          ; Test sign of FPREG
3720:27916+10	A903  3620    	        LD      (HL),' '        ; Space at start
3721:27926+10	A905  F20AA9  	        JP      P,SPCFST        ; Positive - Space to start
3722:27936+10	A908  362D    	        LD      (HL),'-'        ; '-' sign at start
3723:27946+6	A90A  23      	SPCFST: INC     HL              ; First byte of number
3724:27952+10	A90B  3630    	        LD      (HL),'0'        ; '0' if zero
3725:27962+10	A90D  CAC0A9  	        JP      Z,JSTZER        ; Return '0' if zero
3726:27972+11	A910  E5      	        PUSH    HL              ; Save buffer address
3727:27983+10+7	A911  FC80A7  	        CALL    M,INVSGN        ; Negate FPREG if negative
3728:27993+4	A914  AF      	        XOR     A               ; Zero A
3729:27997+11	A915  F5      	        PUSH    AF              ; Save it
3730:28008+17	A916  CDC6A9  	        CALL    RNGTST          ; Test number is in range
3731:28025+10	A919  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3732:28035+10	A91C  11F84F  	        LD      DE,4FF8H
3733:28045+17	A91F  CDD2A7  	        CALL    CMPNUM          ; Compare numbers
3734:28062+4	A922  B7      	        OR      A
3735:28066+10	A923  E237A9  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3736:28076+10	A926  F1      	        POP     AF              ; Restore count
3737:28086+17	A927  CDB4A8  	        CALL    MULTEN          ; Multiply by ten
3738:28103+11	A92A  F5      	        PUSH    AF              ; Re-save count
3739:28114+10	A92B  C319A9  	        JP      SIXDIG          ; Test it again
3740:				
3741:28124+17	A92E  CD9FA6  	GTSIXD: CALL    DIV10           ; Divide by 10
3742:28141+10	A931  F1      	        POP     AF              ; Get count
3743:28151+4	A932  3C      	        INC     A               ; Count divides
3744:28155+11	A933  F5      	        PUSH    AF              ; Re-save count
3745:28166+17	A934  CDC6A9  	        CALL    RNGTST          ; Test number is in range
3746:28183+17	A937  CDFFA4  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3747:28200+4	A93A  3C      	        INC     A
3748:28204+17	A93B  CDFFA7  	        CALL    FPINT           ; F.P to integer
3749:28221+17	A93E  CD98A7  	        CALL    FPBCDE          ; Move BCDE to FPREG
3750:28238+10	A941  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3751:28248+10	A944  F1      	        POP     AF              ; Restore count
3752:28258+4	A945  81      	        ADD     A,C             ; 6 digits before point
3753:28262+4	A946  3C      	        INC     A               ; Add one
3754:28266+10	A947  FA53A9  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3755:28276+7	A94A  FE08    	        CP      6+1+1           ; More than 999999 ?
3756:28283+10	A94C  D253A9  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3757:28293+4	A94F  3C      	        INC     A               ; Adjust for exponent
3758:28297+4	A950  47      	        LD      B,A             ; Exponent of number
3759:28301+7	A951  3E02    	        LD      A,2             ; Make it zero after
3760:				
3761:28308+4	A953  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3762:28312+4	A954  3D      	        DEC     A
3763:28316+10	A955  E1      	        POP     HL              ; Restore buffer address
3764:28326+11	A956  F5      	        PUSH    AF              ; Save count
3765:28337+10	A957  11D9A9  	        LD      DE,POWERS       ; Powers of ten
3766:28347+4	A95A  05      	        DEC     B               ; Count digits before point
3767:28351+10	A95B  C264A9  	        JP      NZ,DIGTXT       ; Not zero - Do number
3768:28361+10	A95E  362E    	        LD      (HL),'.'        ; Save point
3769:28371+6	A960  23      	        INC     HL              ; Move on
3770:28377+10	A961  3630    	        LD      (HL),'0'        ; Save zero
3771:28387+6	A963  23      	        INC     HL              ; Move on
3772:28393+4	A964  05      	DIGTXT: DEC     B               ; Count digits before point
3773:28397+10	A965  362E    	        LD      (HL),'.'        ; Save point in case
3774:28407+10+7	A967  CCADA7  	        CALL    Z,INCHL         ; Last digit - move on
3775:28417+11	A96A  C5      	        PUSH    BC              ; Save digits before point
3776:28428+11	A96B  E5      	        PUSH    HL              ; Save buffer address
3777:28439+11	A96C  D5      	        PUSH    DE              ; Save powers of ten
3778:28450+17	A96D  CDA3A7  	        CALL    BCDEFP          ; Move FPREG to BCDE
3779:28467+10	A970  E1      	        POP     HL              ; Powers of ten table
3780:28477+7	A971  062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3781:28484+4	A973  04      	TRYAGN: INC     B               ; Count subtractions
3782:28488+4	A974  7B      	        LD      A,E             ; Get LSB
3783:28492+7	A975  96      	        SUB     (HL)            ; Subtract LSB
3784:28499+4	A976  5F      	        LD      E,A             ; Save LSB
3785:28503+6	A977  23      	        INC     HL
3786:28509+4	A978  7A      	        LD      A,D             ; Get NMSB
3787:28513+7	A979  9E      	        SBC     A,(HL)          ; Subtract NMSB
3788:28520+4	A97A  57      	        LD      D,A             ; Save NMSB
3789:28524+6	A97B  23      	        INC     HL
3790:28530+4	A97C  79      	        LD      A,C             ; Get MSB
3791:28534+7	A97D  9E      	        SBC     A,(HL)          ; Subtract MSB
3792:28541+4	A97E  4F      	        LD      C,A             ; Save MSB
3793:28545+6	A97F  2B      	        DEC     HL              ; Point back to start
3794:28551+6	A980  2B      	        DEC     HL
3795:28557+10	A981  D273A9  	        JP      NC,TRYAGN       ; No overflow - Try again
3796:28567+17	A984  CDB6A5  	        CALL    PLUCDE          ; Restore number
3797:28584+6	A987  23      	        INC     HL              ; Start of next number
3798:28590+17	A988  CD98A7  	        CALL    FPBCDE          ; Move BCDE to FPREG
3799:28607+4	A98B  EB      	        EX      DE,HL           ; Save point in table
3800:28611+10	A98C  E1      	        POP     HL              ; Restore buffer address
3801:28621+7	A98D  70      	        LD      (HL),B          ; Save digit in buffer
3802:28628+6	A98E  23      	        INC     HL              ; And move on
3803:28634+10	A98F  C1      	        POP     BC              ; Restore digit count
3804:28644+4	A990  0D      	        DEC     C               ; Count digits
3805:28648+10	A991  C264A9  	        JP      NZ,DIGTXT       ; More - Do them
3806:28658+4	A994  05      	        DEC     B               ; Any decimal part?
3807:28662+10	A995  CAA4A9  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3808:28672+6	A998  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3809:28678+7	A999  7E      	        LD      A,(HL)          ; Get character
3810:28685+7	A99A  FE30    	        CP      '0'             ; '0' character?
3811:28692+10	A99C  CA98A9  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3812:28702+7	A99F  FE2E    	        CP      '.'             ; A decimal point?
3813:28709+10+7	A9A1  C4ADA7  	        CALL    NZ,INCHL        ; Move back over digit
3814:				
3815:28719+10	A9A4  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3816:28729+10	A9A5  CAC3A9  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3817:28739+10	A9A8  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3818:28749+6	A9AA  23      	        INC     HL              ; And move on
3819:28755+10	A9AB  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3820:28765+10	A9AD  F2B4A9  	        JP      P,OUTEXP        ; Positive - Output exponent
3821:28775+10	A9B0  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3822:28785+4	A9B2  2F      	        CPL                     ; Negate exponent
3823:28789+4	A9B3  3C      	        INC     A
3824:28793+7	A9B4  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3825:28800+4	A9B6  04      	EXPTEN: INC     B               ; Count subtractions
3826:28804+7	A9B7  D60A    	        SUB     10              ; Tens digit
3827:28811+10	A9B9  D2B6A9  	        JP      NC,EXPTEN       ; More to do
3828:28821+7	A9BC  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3829:28828+6	A9BE  23      	        INC     HL              ; Move on
3830:28834+7	A9BF  70      	        LD      (HL),B          ; Save MSB of exponent
3831:28841+6	A9C0  23      	JSTZER: INC     HL              ;
3832:28847+7	A9C1  77      	        LD      (HL),A          ; Save LSB of exponent
3833:28854+6	A9C2  23      	        INC     HL
3834:28860+7	A9C3  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3835:28867+10	A9C4  E1      	        POP     HL              ; Restore code string address
3836:28877+10	A9C5  C9      	        RET
3837:				
3838:28887+10	A9C6  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3839:28897+10	A9C9  11F723  	        LD      DE,23F7H
3840:28907+17	A9CC  CDD2A7  	        CALL    CMPNUM          ; Compare numbers
3841:28924+4	A9CF  B7      	        OR      A
3842:28928+10	A9D0  E1      	        POP     HL              ; Return address to HL
3843:28938+10	A9D1  E22EA9  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3844:28948+4	A9D4  E9      	        JP      (HL)            ; Otherwise return to caller
3845:				
3846:     -	A9D5  00000080	HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3847:				
3848:     -	A9D9  A08601  	POWERS: .BYTE      0A0H,086H,001H  ; 100000
3849:     -	A9DC  102700  	        .BYTE      010H,027H,000H  ;  10000
3850:     -	A9DF  E80300  	        .BYTE      0E8H,003H,000H  ;   1000
3851:     -	A9E2  640000  	        .BYTE      064H,000H,000H  ;    100
3852:     -	A9E5  0A0000  	        .BYTE      00AH,000H,000H  ;     10
3853:     -	A9E8  010000  	        .BYTE      001H,000H,000H  ;      1
3854:				
3855:28952+10	A9EB  2180A7  	NEGAFT: LD  HL,INVSGN           ; Negate result
3856:28962+19	A9EE  E3      	        EX      (SP),HL         ; To be done after caller
3857:28981+4	A9EF  E9      	        JP      (HL)            ; Return to caller
3858:				
3859:28985+17	A9F0  CD88A7  	SQR:    CALL    STAKFP          ; Put value on stack
3860:29002+10	A9F3  21D5A9  	        LD      HL,HALF         ; Set power to 1/2
3861:29012+17	A9F6  CD95A7  	        CALL    PHLTFP          ; Move 1/2 to FPREG
3862:				
3863:29029+10	A9F9  C1      	POWER:  POP     BC              ; Get base
3864:29039+10	A9FA  D1      	        POP     DE
3865:29049+17	A9FB  CD57A7  	        CALL    TSTSGN          ; Test sign of power
3866:29066+4	A9FE  78      	        LD      A,B             ; Get exponent of base
3867:29070+10	A9FF  CA3EAA  	        JP      Z,EXP           ; Make result 1 if zero
3868:29080+10	AA02  F209AA  	        JP      P,POWER1        ; Positive base - Ok
3869:29090+4	AA05  B7      	        OR      A               ; Zero to negative power?
3870:29094+10	AA06  CAB094  	        JP      Z,DZERR         ; Yes - ?/0 Error
3871:29104+4	AA09  B7      	POWER1: OR      A               ; Base zero?
3872:29108+10	AA0A  CA78A5  	        JP      Z,SAVEXP        ; Yes - Return zero
3873:29118+11	AA0D  D5      	        PUSH    DE              ; Save base
3874:29129+11	AA0E  C5      	        PUSH    BC
3875:29140+4	AA0F  79      	        LD      A,C             ; Get MSB of base
3876:29144+7	AA10  F67F    	        OR      01111111B       ; Get sign status
3877:29151+17	AA12  CDA3A7  	        CALL    BCDEFP          ; Move power to BCDE
3878:29168+10	AA15  F226AA  	        JP      P,POWER2        ; Positive base - Ok
3879:29178+11	AA18  D5      	        PUSH    DE              ; Save power
3880:29189+11	AA19  C5      	        PUSH    BC
3881:29200+17	AA1A  CD2AA8  	        CALL    INT             ; Get integer of power
3882:29217+10	AA1D  C1      	        POP     BC              ; Restore power
3883:29227+10	AA1E  D1      	        POP     DE
3884:29237+11	AA1F  F5      	        PUSH    AF              ; MSB of base
3885:29248+17	AA20  CDD2A7  	        CALL    CMPNUM          ; Power an integer?
3886:29265+10	AA23  E1      	        POP     HL              ; Restore MSB of base
3887:29275+4	AA24  7C      	        LD      A,H             ; but don't affect flags
3888:29279+4	AA25  1F      	        RRA                     ; Exponent odd or even?
3889:29283+10	AA26  E1      	POWER2: POP     HL              ; Restore MSB and exponent
3890:29293+16	AA27  222BB1  	        LD      (FPREG+2),HL    ; Save base in FPREG
3891:29309+10	AA2A  E1      	        POP     HL              ; LSBs of base
3892:29319+16	AA2B  2229B1  	        LD      (FPREG),HL      ; Save in FPREG
3893:29335+10+7	AA2E  DCEBA9  	        CALL    C,NEGAFT        ; Odd power - Negate result
3894:29345+10+7	AA31  CC80A7  	        CALL    Z,INVSGN        ; Negative base - Negate it
3895:29355+11	AA34  D5      	        PUSH    DE              ; Save power
3896:29366+11	AA35  C5      	        PUSH    BC
3897:29377+17	AA36  CD0BA6  	        CALL    LOG             ; Get LOG of base
3898:29394+10	AA39  C1      	        POP     BC              ; Restore power
3899:29404+10	AA3A  D1      	        POP     DE
3900:29414+17	AA3B  CD4CA6  	        CALL    FPMULT          ; Multiply LOG by power
3901:				
3902:29431+17	AA3E  CD88A7  	EXP:    CALL    STAKFP          ; Put value on stack
3903:29448+10	AA41  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3904:29458+10	AA44  113BAA  	        LD      DE,0AA3BH
3905:29468+17	AA47  CD4CA6  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3906:29485+13	AA4A  3A2CB1  	        LD      A,(FPEXP)       ; Get exponent
3907:29498+7	AA4D  FE88    	        CP      80H+8           ; Is it in range?
3908:29505+10	AA4F  D233A7  	        JP      NC,OVTST1       ; No - Test for overflow
3909:29515+17	AA52  CD2AA8  	        CALL    INT             ; Get INT of FPREG
3910:29532+7	AA55  C680    	        ADD     A,80H           ; For excess 128
3911:29539+7	AA57  C602    	        ADD     A,2             ; Exponent > 126?
3912:29546+10	AA59  DA33A7  	        JP      C,OVTST1        ; Yes - Test for overflow
3913:29556+11	AA5C  F5      	        PUSH    AF              ; Save scaling factor
3914:29567+10	AA5D  21FAA5  	        LD      HL,UNITY        ; Point to 1.
3915:29577+17	AA60  CD02A5  	        CALL    ADDPHL          ; Add 1 to FPREG
3916:29594+17	AA63  CD43A6  	        CALL    MULLN2          ; Multiply by LN(2)
3917:29611+10	AA66  F1      	        POP     AF              ; Restore scaling factor
3918:29621+10	AA67  C1      	        POP     BC              ; Restore exponent
3919:29631+10	AA68  D1      	        POP     DE
3920:29641+11	AA69  F5      	        PUSH    AF              ; Save scaling factor
3921:29652+17	AA6A  CD0EA5  	        CALL    SUBCDE          ; Subtract exponent from FPREG
3922:29669+17	AA6D  CD80A7  	        CALL    INVSGN          ; Negate result
3923:29686+10	AA70  217EAA  	        LD      HL,EXPTAB       ; Coefficient table
3924:29696+17	AA73  CDAEAA  	        CALL    SMSER1          ; Sum the series
3925:29713+10	AA76  110000  	        LD      DE,0            ; Zero LSBs
3926:29723+10	AA79  C1      	        POP     BC              ; Scaling factor
3927:29733+4	AA7A  4A      	        LD      C,D             ; Zero MSB
3928:29737+10	AA7B  C34CA6  	        JP      FPMULT          ; Scale result to correct value
3929:				
3930:     -	AA7E  08      	EXPTAB: .BYTE      8                       ; Table used by EXP
3931:     -	AA7F  402E9474	        .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3932:     -	AA83  704F2E77	        .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3933:     -	AA87  6E02887A	        .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3934:     -	AA8B  E6A02A7C	        .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3935:     -	AA8F  50AAAA7E	        .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3936:     -	AA93  FFFF7F7F	        .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3937:     -	AA97  00008081	        .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3938:     -	AA9B  00000081	        .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3939:				
3940:29747+17	AA9F  CD88A7  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
3941:29764+10	AAA2  114AA6  	        LD      DE,MULT         ; Multiply by "X"
3942:29774+11	AAA5  D5      	        PUSH    DE              ; To be done after
3943:29785+11	AAA6  E5      	        PUSH    HL              ; Save address of table
3944:29796+17	AAA7  CDA3A7  	        CALL    BCDEFP          ; Move FPREG to BCDE
3945:29813+17	AAAA  CD4CA6  	        CALL    FPMULT          ; Square the value
3946:29830+10	AAAD  E1      	        POP     HL              ; Restore address of table
3947:29840+17	AAAE  CD88A7  	SMSER1: CALL    STAKFP          ; Put value on stack
3948:29857+7	AAB1  7E      	        LD      A,(HL)          ; Get number of coefficients
3949:29864+6	AAB2  23      	        INC     HL              ; Point to start of table
3950:29870+17	AAB3  CD95A7  	        CALL    PHLTFP          ; Move coefficient to FPREG
3951:     -	AAB6  06      	        .BYTE      06H             ; Skip "POP AF"
3952:29887+10	AAB7  F1      	SUMLP:  POP     AF              ; Restore count
3953:29897+10	AAB8  C1      	        POP     BC              ; Restore number
3954:29907+10	AAB9  D1      	        POP     DE
3955:29917+4	AABA  3D      	        DEC     A               ; Cont coefficients
3956:29921+5+6	AABB  C8      	        RET     Z               ; All done
3957:29926+11	AABC  D5      	        PUSH    DE              ; Save number
3958:29937+11	AABD  C5      	        PUSH    BC
3959:29948+11	AABE  F5      	        PUSH    AF              ; Save count
3960:29959+11	AABF  E5      	        PUSH    HL              ; Save address in table
3961:29970+17	AAC0  CD4CA6  	        CALL    FPMULT          ; Multiply FPREG by BCDE
3962:29987+10	AAC3  E1      	        POP     HL              ; Restore address in table
3963:29997+17	AAC4  CDA6A7  	        CALL    LOADFP          ; Number at HL to BCDE
3964:30014+11	AAC7  E5      	        PUSH    HL              ; Save address in table
3965:30025+17	AAC8  CD11A5  	        CALL    FPADD           ; Add coefficient to FPREG
3966:30042+10	AACB  E1      	        POP     HL              ; Restore address in table
3967:30052+10	AACC  C3B7AA  	        JP      SUMLP           ; More coefficients
3968:				
3969:30062+17	AACF  CD57A7  	RND:    CALL    TSTSGN          ; Test sign of FPREG
3970:30079+10	AAD2  215EB0  	        LD      HL,SEED+2       ; Random number seed
3971:30089+10	AAD5  FA30AB  	        JP      M,RESEED        ; Negative - Re-seed
3972:30099+10	AAD8  217FB0  	        LD      HL,LSTRND       ; Last random number
3973:30109+17	AADB  CD95A7  	        CALL    PHLTFP          ; Move last RND to FPREG
3974:30126+10	AADE  215EB0  	        LD      HL,SEED+2       ; Random number seed
3975:30136+5+6	AAE1  C8      	        RET     Z               ; Return if RND(0)
3976:30141+7	AAE2  86      	        ADD     A,(HL)          ; Add (SEED)+2)
3977:30148+7	AAE3  E607    	        AND     00000111B       ; 0 to 7
3978:30155+7	AAE5  0600    	        LD      B,0
3979:30162+7	AAE7  77      	        LD      (HL),A          ; Re-save seed
3980:30169+6	AAE8  23      	        INC     HL              ; Move to coefficient table
3981:30175+4	AAE9  87      	        ADD     A,A             ; 4 bytes
3982:30179+4	AAEA  87      	        ADD     A,A             ; per entry
3983:30183+4	AAEB  4F      	        LD      C,A             ; BC = Offset into table
3984:30187+11	AAEC  09      	        ADD     HL,BC           ; Point to coefficient
3985:30198+17	AAED  CDA6A7  	        CALL    LOADFP          ; Coefficient to BCDE
3986:30215+17	AAF0  CD4CA6  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3987:30232+13	AAF3  3A5DB0  	        LD      A,(SEED+1)      ; Get (SEED+1)
3988:30245+4	AAF6  3C      	        INC     A               ; Add 1
3989:30249+7	AAF7  E603    	        AND     00000011B       ; 0 to 3
3990:30256+7	AAF9  0600    	        LD      B,0
3991:30263+7	AAFB  FE01    	        CP      1               ; Is it zero?
3992:30270+4	AAFD  88      	        ADC     A,B             ; Yes - Make it 1
3993:30274+13	AAFE  325DB0  	        LD      (SEED+1),A      ; Re-save seed
3994:30287+10	AB01  2134AB  	        LD      HL,RNDTAB-4     ; Addition table
3995:30297+4	AB04  87      	        ADD     A,A             ; 4 bytes
3996:30301+4	AB05  87      	        ADD     A,A             ; per entry
3997:30305+4	AB06  4F      	        LD      C,A             ; BC = Offset into table
3998:30309+11	AB07  09      	        ADD     HL,BC           ; Point to value
3999:30320+17	AB08  CD02A5  	        CALL    ADDPHL          ; Add value to FPREG
4000:30337+17	AB0B  CDA3A7  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
4001:30354+4	AB0E  7B      	        LD      A,E             ; Get LSB
4002:30358+4	AB0F  59      	        LD      E,C             ; LSB = MSB
4003:30362+7	AB10  EE4F    	        XOR     01001111B       ; Fiddle around
4004:30369+4	AB12  4F      	        LD      C,A             ; New MSB
4005:30373+10	AB13  3680    	        LD      (HL),80H        ; Set exponent
4006:30383+6	AB15  2B      	        DEC     HL              ; Point to MSB
4007:30389+7	AB16  46      	        LD      B,(HL)          ; Get MSB
4008:30396+10	AB17  3680    	        LD      (HL),80H        ; Make value -0.5
4009:30406+10	AB19  215CB0  	        LD      HL,SEED         ; Random number seed
4010:30416+11	AB1C  34      	        INC     (HL)            ; Count seed
4011:30427+7	AB1D  7E      	        LD      A,(HL)          ; Get seed
4012:30434+7	AB1E  D6AB    	        SUB     171             ; Do it modulo 171
4013:30441+10	AB20  C227AB  	        JP      NZ,RND2         ; Non-zero - Ok
4014:30451+7	AB23  77      	        LD      (HL),A          ; Zero seed
4015:30458+4	AB24  0C      	        INC     C               ; Fillde about
4016:30462+4	AB25  15      	        DEC     D               ; with the
4017:30466+4	AB26  1C      	        INC     E               ; number
4018:30470+17	AB27  CD62A5  	RND2:   CALL    BNORM           ; Normalise number
4019:30487+10	AB2A  217FB0  	        LD      HL,LSTRND       ; Save random number
4020:30497+10	AB2D  C3AFA7  	        JP      FPTHL           ; Move FPREG to last and return
4021:				
4022:30507+7	AB30  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
4023:30514+6	AB31  2B      	        DEC     HL
4024:30520+7	AB32  77      	        LD      (HL),A
4025:30527+6	AB33  2B      	        DEC     HL
4026:30533+7	AB34  77      	        LD      (HL),A
4027:30540+10	AB35  C30BAB  	        JP      RND1            ; Return RND seed
4028:				
4029:     -	AB38  68B14668	RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4030:     -	AB3C  99E99269	        .BYTE   099H,0E9H,092H,069H
4031:     -	AB40  10D17568	        .BYTE   010H,0D1H,075H,068H
4032:				
4033:30550+10	AB44  218EAB  	COS:    LD      HL,HALFPI       ; Point to PI/2
4034:30560+17	AB47  CD02A5  	        CALL    ADDPHL          ; Add it to PPREG
4035:30577+17	AB4A  CD88A7  	SIN:    CALL    STAKFP          ; Put angle on stack
4036:30594+10	AB4D  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4037:30604+10	AB50  11DB0F  	        LD      DE,0FDBH
4038:30614+17	AB53  CD98A7  	        CALL    FPBCDE          ; Move 2 PI to FPREG
4039:30631+10	AB56  C1      	        POP     BC              ; Restore angle
4040:30641+10	AB57  D1      	        POP     DE
4041:30651+17	AB58  CDADA6  	        CALL    DVBCDE          ; Divide angle by 2 PI
4042:30668+17	AB5B  CD88A7  	        CALL    STAKFP          ; Put it on stack
4043:30685+17	AB5E  CD2AA8  	        CALL    INT             ; Get INT of result
4044:30702+10	AB61  C1      	        POP     BC              ; Restore number
4045:30712+10	AB62  D1      	        POP     DE
4046:30722+17	AB63  CD0EA5  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4047:30739+10	AB66  2192AB  	        LD      HL,QUARTR       ; Point to 0.25
4048:30749+17	AB69  CD08A5  	        CALL    SUBPHL          ; Subtract value from 0.25
4049:30766+17	AB6C  CD57A7  	        CALL    TSTSGN          ; Test sign of value
4050:30783+4	AB6F  37      	        SCF                     ; Flag positive
4051:30787+10	AB70  F27AAB  	        JP      P,SIN1          ; Positive - Ok
4052:30797+17	AB73  CDFFA4  	        CALL    ROUND           ; Add 0.5 to value
4053:30814+17	AB76  CD57A7  	        CALL    TSTSGN          ; Test sign of value
4054:30831+4	AB79  B7      	        OR      A               ; Flag negative
4055:30835+11	AB7A  F5      	SIN1:   PUSH    AF              ; Save sign
4056:30846+10+7	AB7B  F480A7  	        CALL    P,INVSGN        ; Negate value if positive
4057:30856+10	AB7E  2192AB  	        LD      HL,QUARTR       ; Point to 0.25
4058:30866+17	AB81  CD02A5  	        CALL    ADDPHL          ; Add 0.25 to value
4059:30883+10	AB84  F1      	        POP     AF              ; Restore sign
4060:30893+10+7	AB85  D480A7  	        CALL    NC,INVSGN       ; Negative - Make positive
4061:30903+10	AB88  2196AB  	        LD      HL,SINTAB       ; Coefficient table
4062:30913+10	AB8B  C39FAA  	        JP      SUMSER          ; Evaluate sum of series
4063:				
4064:     -	AB8E  DB0F4981	HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4065:				
4066:     -	AB92  0000007F	QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4067:				
4068:     -	AB96  05      	SINTAB: .BYTE   5                       ; Table used by SIN
4069:     -	AB97  BAD71E86	        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4070:     -	AB9B  64269987	        .BYTE   064H,026H,099H,087H     ;-76.575
4071:     -	AB9F  58342387	        .BYTE   058H,034H,023H,087H     ; 81.602
4072:     -	ABA3  E05DA586	        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4073:     -	ABA7  DA0F4983	        .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4074:				
4075:30923+17	ABAB  CD88A7  	TAN:    CALL    STAKFP          ; Put angle on stack
4076:30940+17	ABAE  CD4AAB  	        CALL    SIN             ; Get SIN of angle
4077:30957+10	ABB1  C1      	        POP     BC              ; Restore angle
4078:30967+10	ABB2  E1      	        POP     HL
4079:30977+17	ABB3  CD88A7  	        CALL    STAKFP          ; Save SIN of angle
4080:30994+4	ABB6  EB      	        EX      DE,HL           ; BCDE = Angle
4081:30998+17	ABB7  CD98A7  	        CALL    FPBCDE          ; Angle to FPREG
4082:31015+17	ABBA  CD44AB  	        CALL    COS             ; Get COS of angle
4083:31032+10	ABBD  C3ABA6  	        JP      DIV             ; TAN = SIN / COS
4084:				
4085:31042+17	ABC0  CD57A7  	ATN:    CALL    TSTSGN          ; Test sign of value
4086:31059+10+7	ABC3  FCEBA9  	        CALL    M,NEGAFT        ; Negate result after if -ve
4087:31069+10+7	ABC6  FC80A7  	        CALL    M,INVSGN        ; Negate value if -ve
4088:31079+13	ABC9  3A2CB1  	        LD      A,(FPEXP)       ; Get exponent
4089:31092+7	ABCC  FE81    	        CP      81H             ; Number less than 1?
4090:31099+10	ABCE  DADDAB  	        JP      C,ATN1          ; Yes - Get arc tangnt
4091:31109+10	ABD1  010081  	        LD      BC,8100H        ; BCDE = 1
4092:31119+4	ABD4  51      	        LD      D,C
4093:31123+4	ABD5  59      	        LD      E,C
4094:31127+17	ABD6  CDADA6  	        CALL    DVBCDE          ; Get reciprocal of number
4095:31144+10	ABD9  2108A5  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4096:31154+11	ABDC  E5      	        PUSH    HL              ; Save for angle > 1
4097:31165+10	ABDD  21E7AB  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4098:31175+17	ABE0  CD9FAA  	        CALL    SUMSER          ; Evaluate sum of series
4099:31192+10	ABE3  218EAB  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4100:31202+10	ABE6  C9      	        RET                     ; Number > 1 - Sub from PI/2
4101:				
4102:     -	ABE7  09      	ATNTAB: .BYTE   9                       ; Table used by ATN
4103:     -	ABE8  4AD73B78	        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4104:     -	ABEC  026E847B	        .BYTE   002H,06EH,084H,07BH     ;-1/15
4105:     -	ABF0  FEC12F7C	        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4106:     -	ABF4  74319A7D	        .BYTE   074H,031H,09AH,07DH     ;-1/11
4107:     -	ABF8  843D5A7D	        .BYTE   084H,03DH,05AH,07DH     ; 1/9
4108:     -	ABFC  C87F917E	        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4109:     -	AC00  E4BB4C7E	        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4110:     -	AC04  6CAAAA7F	        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4111:     -	AC08  00000081	        .BYTE   000H,000H,000H,081H     ; 1/1
4112:				
4113:				
4114:31212+10	AC0C  C9      	ARET:   RET                     ; A RETurn instruction
4115:				
4116:				;GETINP: RST	10H             ;input a character <FIXME>
4117:31222+17	AC0D  CD8FAD  	GETINP: call	umon_getc	;<ESH> get serial input
4118:31239+10	AC10  C9      	        RET
4119:				
4120:     -	AC11          	CLS: 
4121:31249+7	AC11  3E0C    	        LD      A,CS            ; ASCII Clear screen
4122:31256+10	AC13  C34BAD  	        JP      MONOUT          ; Output character
4123:				
4124:31266+17	AC16  CDD6A4  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4125:31283+4	AC19  7B      	        LD      A,E             ; Width to A
4126:31287+13	AC1A  3287B0  	        LD      (LWIDTH),A      ; Set width
4127:31300+10	AC1D  C9      	        RET
4128:				
4129:31310+17	AC1E  CD759D  	LINES:  CALL    GETNUM          ; Get a number
4130:31327+17	AC21  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 32767
4131:31344+20	AC24  ED538BB0	        LD      (LINESC),DE     ; Set lines counter
4132:31364+20	AC28  ED538DB0	        LD      (LINESN),DE     ; Set lines number
4133:31384+10	AC2C  C9      	        RET
4134:				
4135:31394+17	AC2D  CDBA99  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4136:31411+11	AC30  D5      	        PUSH    DE              ; Save number
4137:31422+10	AC31  E1      	        POP     HL              ; Number to HL
4138:31432+7	AC32  46      	        LD      B,(HL)          ; Get LSB of contents
4139:31439+6	AC33  23      	        INC     HL
4140:31445+7	AC34  7E      	        LD      A,(HL)          ; Get MSB of contents
4141:31452+10	AC35  C330A1  	        JP      ABPASS          ; Return integer AB
4142:				
4143:31462+17	AC38  CD759D  	DOKE:   CALL    GETNUM          ; Get a number
4144:31479+17	AC3B  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 32767
4145:31496+11	AC3E  D5      	        PUSH    DE              ; Save address
4146:31507+17	AC3F  CD7B97  	        CALL    CHKSYN          ; Make sure ',' follows
4147:     -	AC42  2C      	        .BYTE      ','
4148:31524+17	AC43  CD759D  	        CALL    GETNUM          ; Get a number
4149:31541+17	AC46  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 32767
4150:31558+19	AC49  E3      	        EX      (SP),HL         ; Save value,get address
4151:31577+7	AC4A  73      	        LD      (HL),E          ; Save LSB of value
4152:31584+6	AC4B  23      	        INC     HL
4153:31590+7	AC4C  72      	        LD      (HL),D          ; Save MSB of value
4154:31597+10	AC4D  E1      	        POP     HL              ; Restore code string address
4155:31607+10	AC4E  C9      	        RET
4156:				
4157:				
4158:				; HEX$(nn) Convert 16 bit number to Hexadecimal string
4159:				
4160:31617+17	AC4F  CD789D  	HEX: 	CALL	TSTNUM          ; Verify it's a number
4161:31634+17	AC52  CDBA99  	        CALL	DEINT           ; Get integer -32768 to 32767
4162:31651+11	AC55  C5      	        PUSH	BC              ; Save contents of BC
4163:31662+10	AC56  212EB1  	        LD	    HL,PBUFF
4164:31672+4	AC59  7A      	        LD	    A,D             ; Get high order into A
4165:31676+7	AC5A  FE00    	        CP      $0
4166:31683+7+5	AC5C  280C    			JR      Z,HEX2          ; Skip output if both high digits are zero
4167:31690+17	AC5E  CD87AC  	        CALL    BYT2ASC         ; Convert D to ASCII
4168:31707+4	AC61  78      			LD      A,B
4169:31711+7	AC62  FE30    			CP      '0'
4170:31718+7+5	AC64  2802    			JR      Z,HEX1          ; Don't store high digit if zero
4171:31725+7	AC66  70      	        LD	    (HL),B          ; Store it to PBUFF
4172:31732+6	AC67  23      	        INC	    HL              ; Next location
4173:31738+7	AC68  71      	HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4174:31745+6	AC69  23      	        INC     HL              ; Next location
4175:31751+4	AC6A  7B      	HEX2:   LD	    A,E             ; Get lower byte
4176:31755+17	AC6B  CD87AC  	        CALL    BYT2ASC         ; Convert E to ASCII
4177:31772+4	AC6E  7A      			LD      A,D
4178:31776+7	AC6F  FE00    	        CP      $0
4179:31783+7+5	AC71  2005    			JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4180:31790+4	AC73  78      			LD      A,B
4181:31794+7	AC74  FE30    			CP      '0'             ; If high digit of lower byte is zero then don't print
4182:31801+7+5	AC76  2802    			JR      Z,HEX4
4183:31808+7	AC78  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4184:31815+6	AC79  23      	        INC     HL              ; Next location
4185:31821+7	AC7A  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4186:31828+6	AC7B  23      	        INC     HL              ; PBUFF+4 to zero
4187:31834+4	AC7C  AF      	        XOR     A               ; Terminating character
4188:31838+7	AC7D  77      	        LD      (HL),A          ; Store zero to terminate
4189:31845+6	AC7E  23      	        INC     HL              ; Make sure PBUFF is terminated
4190:31851+7	AC7F  77      	        LD      (HL),A          ; Store the double zero there
4191:31858+10	AC80  C1      	        POP     BC              ; Get BC back
4192:31868+10	AC81  212EB1  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4193:31878+10	AC84  C3DEA1  	        JP      STR1            ; Convert the PBUFF to a string and return it
4194:				
4195:31888+4	AC87  47      	BYT2ASC	LD      B,A             ; Save original value
4196:31892+7	AC88  E60F    	        AND     $0F             ; Strip off upper nybble
4197:31899+7	AC8A  FE0A    	        CP      $0A             ; 0-9?
4198:31906+7+5	AC8C  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4199:31913+7	AC8E  C607    	        ADD     A,$07           ; Bring value up to ASCII A-F
4200:31920+7	AC90  C630    	ADD30	ADD     A,$30           ; And make ASCII
4201:31927+4	AC92  4F      	        LD      C,A             ; Save converted char to C
4202:31931+4	AC93  78      	        LD      A,B             ; Retrieve original value
4203:31935+4	AC94  0F      	        RRCA                    ; and Rotate it right
4204:31939+4	AC95  0F      	        RRCA
4205:31943+4	AC96  0F      	        RRCA
4206:31947+4	AC97  0F      	        RRCA
4207:31951+7	AC98  E60F    	        AND     $0F             ; Mask off upper nybble
4208:31958+7	AC9A  FE0A    	        CP      $0A             ; 0-9? < A hex?
4209:31965+7+5	AC9C  3802    	        JR      C,ADD301        ; Skip Add 7
4210:31972+7	AC9E  C607    	        ADD     A,$07           ; Bring it up to ASCII A-F
4211:31979+7	ACA0  C630    	ADD301	ADD     A,$30           ; And make it full ASCII
4212:31986+4	ACA2  47      	        LD      B,A             ; Store high order byte
4213:31990+10	ACA3  C9      	        RET	
4214:				
4215:				; Convert "&Hnnnn" to FPREG
4216:				; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4217:				; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4218:32000+4	ACA4  EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4219:32004+10	ACA5  210000  	        LD      HL,$0000        ; Zero out the value
4220:32014+17	ACA8  CDBDAC  	        CALL    GETHEX          ; Check the number for valid hex
4221:32031+10	ACAB  DADDAC  	        JP      C,HXERR         ; First value wasn't hex, HX error
4222:32041+12	ACAE  1805    	        JR      HEXLP1          ; Convert first character
4223:32053+17	ACB0  CDBDAC  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
4224:32070+7+5	ACB3  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4225:32077+11	ACB5  29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4226:32088+11	ACB6  29      	        ADD     HL,HL
4227:32099+11	ACB7  29      	        ADD     HL,HL
4228:32110+11	ACB8  29      	        ADD     HL,HL
4229:32121+4	ACB9  B5      	        OR      L               ; Add in D0-D3 into L
4230:32125+4	ACBA  6F      	        LD      L,A             ; Save new value
4231:32129+12	ACBB  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4232:				
4233:32141+6	ACBD  13      	GETHEX  INC     DE              ; Next location
4234:32147+7	ACBE  1A      	        LD      A,(DE)          ; Load character at pointer
4235:32154+7	ACBF  FE20    	        CP      ' '
4236:32161+10	ACC1  CABDAC  	        JP      Z,GETHEX        ; Skip spaces
4237:32171+7	ACC4  D630    	        SUB     $30             ; Get absolute value
4238:32178+5+6	ACC6  D8      	        RET     C               ; < "0", error
4239:32183+7	ACC7  FE0A    	        CP      $0A
4240:32190+7+5	ACC9  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4241:32197+7	ACCB  D607    	        SUB     $07             ; Reduce to A-F
4242:32204+7	ACCD  FE0A    	        CP      $0A             ; Value should be $0A-$0F at this point
4243:32211+5+6	ACCF  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4244:32216+7	ACD0  FE10    	NOSUB7  CP      $10             ; > Greater than "F"?
4245:32223+4	ACD2  3F      	        CCF
4246:32227+10	ACD3  C9      	        RET                     ; CY set if it wasn't valid hex
4247:				    
4248:32237+4	ACD4  EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4249:32241+4	ACD5  7A      	        LD      A,D             ; Load DE into AC
4250:32245+4	ACD6  4B      	        LD      C,E             ; For prep to 
4251:32249+11	ACD7  E5      	        PUSH    HL
4252:32260+17	ACD8  CD2FA1  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4253:32277+10	ACDB  E1      	        POP     HL
4254:32287+10	ACDC  C9      	        RET
4255:				
4256:32297+7	ACDD  1E26    	HXERR:  LD      E,HX            ; ?HEX Error
4257:32304+10	ACDF  C3C194  	        JP      ERROR
4258:				
4259:				; BIN$(NN) Convert integer to a 1-16 char binary string
4260:32314+17	ACE2  CD789D  	BIN:    CALL    TSTNUM          ; Verify it's a number
4261:32331+17	ACE5  CDBA99  	        CALL    DEINT           ; Get integer -32768 to 32767
4262:32348+11	ACE8  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4263:32359+10	ACE9  212EB1  	        LD      HL,PBUFF
4264:32369+7	ACEC  0611    	        LD      B,17            ; One higher than max char count
4265:     -	ACEE          	ZEROSUP:                        ; Suppress leading zeros
4266:32376+4	ACEE  05      	        DEC     B               ; Max 16 chars
4267:32380+4	ACEF  78      	        LD      A,B
4268:32384+7	ACF0  FE01    	        CP      $01
4269:32391+7+5	ACF2  2808    	        JR      Z,BITOUT        ; Always output at least one character
4270:32398+8	ACF4  CB13    	        RL      E
4271:32406+8	ACF6  CB12    	        RL      D
4272:32414+7+5	ACF8  30F4    	        JR      NC,ZEROSUP
4273:32421+12	ACFA  1804    	        JR      BITOUT2
4274:     -	ACFC          	BITOUT:      
4275:32433+8	ACFC  CB13    	        RL      E
4276:32441+8	ACFE  CB12    	        RL      D               ; Top bit now in carry
4277:     -	AD00          	BITOUT2:
4278:32449+7	AD00  3E30    	        LD      A,'0'           ; Char for '0'
4279:32456+7	AD02  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4280:32463+7	AD04  77      	        LD      (HL),A
4281:32470+6	AD05  23      	        INC     HL
4282:32476+4	AD06  05      	        DEC     B
4283:32480+7+5	AD07  20F3    	        JR      NZ,BITOUT
4284:32487+4	AD09  AF      	        XOR     A               ; Terminating character
4285:32491+7	AD0A  77      	        LD      (HL),A          ; Store zero to terminate
4286:32498+6	AD0B  23      	        INC     HL              ; Make sure PBUFF is terminated
4287:32504+7	AD0C  77      	        LD      (HL),A          ; Store the double zero there
4288:32511+10	AD0D  C1      	        POP     BC
4289:32521+10	AD0E  212EB1  	        LD      HL,PBUFF
4290:32531+10	AD11  C3DEA1  	        JP      STR1
4291:				
4292:				; Convert "&Bnnnn" to FPREG
4293:				; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4294:32541+4	AD14  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4295:32545+10	AD15  210000  	        LD      HL,$0000        ; Zero out the value
4296:32555+17	AD18  CD31AD  	        CALL    CHKBIN          ; Check the number for valid bin
4297:32572+10	AD1B  DA3FAD  	        JP      C,BINERR        ; First value wasn't bin, HX error
4298:32582+7	AD1E  D630    	BINIT:  SUB     '0'
4299:32589+11	AD20  29      	        ADD     HL,HL           ; Rotate HL left
4300:32600+4	AD21  B5      	        OR      L
4301:32604+4	AD22  6F      	        LD      L,A
4302:32608+17	AD23  CD31AD  	        CALL    CHKBIN          ; Get second and addtional characters
4303:32625+7+5	AD26  30F6    	        JR      NC,BINIT        ; Process if a bin character
4304:32632+4	AD28  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4305:32636+4	AD29  7A      	        LD      A,D             ; Load DE into AC
4306:32640+4	AD2A  4B      	        LD      C,E             ; For prep to 
4307:32644+11	AD2B  E5      	        PUSH    HL
4308:32655+17	AD2C  CD2FA1  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4309:32672+10	AD2F  E1      	        POP     HL
4310:32682+10	AD30  C9      	        RET
4311:				
4312:				; Char is in A, NC if char is 0 or 1
4313:32692+6	AD31  13      	CHKBIN: INC     DE
4314:32698+7	AD32  1A      	        LD      A,(DE)
4315:32705+7	AD33  FE20    	        CP      ' '
4316:32712+10	AD35  CA31AD  	        JP      Z,CHKBIN        ; Skip spaces
4317:32722+7	AD38  FE30    	        CP      '0'             ; Set C if < '0'
4318:32729+5+6	AD3A  D8      	        RET     C
4319:32734+7	AD3B  FE32    	        CP      '2'
4320:32741+4	AD3D  3F      	        CCF                     ; Set C if > '1'
4321:32745+10	AD3E  C9      	        RET
4322:				
4323:32755+7	AD3F  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4324:32762+10	AD41  C3C194  	        JP      ERROR
4325:				
4326:				
4327:     -	AD44          	JJUMP1: 
4328:32772+14	AD44  DD21FFFF	        LD      IX,-1           ; Flag cold start
4329:32786+10	AD48  C31191  	        JP      CSTART          ; Go and initialise
4330:				
4331:     -	AD4B          	MONOUT: 
4332:32796+10	AD4B  C3BBAD  		jp	umon_putc
4333:				;        JP      $0008           ; output a char
4334:				
4335:				
4336:     -	AD4E          	MONITR: 
4337:32806+10	AD4E  C30081  	        JP      $8100           ; <ESH> goto UMON
4338:				
4339:				
4340:32816+7	AD51  3E00    	INITST: LD      A,0             ; Clear break flag
4341:32823+13	AD53  3292B0  	        LD      (BRKFLG),A
4342:32836+10	AD56  C31891  	        JP      INIT
4343:				
4344:32846+14	AD59  ED45    	ARETN:  RETN                    ; Return from NMI
4345:				
4346:				
4347:32860+11	AD5B  F5      	TSTBIT: PUSH    AF              ; Save bit mask
4348:32871+4	AD5C  A0      	        AND     B               ; Get common bits
4349:32875+10	AD5D  C1      	        POP     BC              ; Restore bit mask
4350:32885+4	AD5E  B8      	        CP      B               ; Same bit set?
4351:32889+7	AD5F  3E00    	        LD      A,0             ; Return 0 in A
4352:32896+10	AD61  C9      	        RET
4353:				
4354:32906+17	AD62  CD8697  	OUTNCR: CALL    OUTC            ; Output character in A
4355:32923+10	AD65  C3B09B  	        JP      PRNTCRLF        ; Output CRLF
4356:				
4357:				;;; -------------------- SERIAL I/O --------------------
4358:				
4359:				;;; 
4360:				;;; serial port
4361:				;;; umon_putc:  send a character from A
4362:				;;; umon_getc:  receive a character to A
4363:				;;;
4364:				;;; 
4365:				
4366:				
4367:     -	0080          	serial_port:	equ	80H	;input port
4368:     -	0000          	led_port:	equ	0	;port 0 for LED/keyboard output
4369:					
4370:     -	0080          	data_bit:	equ	80H	;input data mask
4371:					
4372:				;;; serial port timing macros
4373:				;;; 23/10 seem to be OK for 4800 baud (4MHz CPU) or 19200 (16MHz CPU)
4374:				
4375:				;;; UGH - z80asm doesn't support macros
4376:				
4377:     -	0016          	dfull:	equ	22
4378:     -	0009          	dhalf:	equ	9
4379:				
4380:				;;;;; delay macro:  uses B
4381:				;;delay	macro	p1
4382:				;;	local	dilly
4383:				;;	ld	b,p1		;7T
4384:				;;
4385:				;;;;; 33T per loop / 28T for last
4386:				;;dilly:	nop			;4T
4387:				;;	nop			;4T
4388:				;;	nop			;4T
4389:				;;	nop			;4T
4390:				;;	nop			;4T
4391:				;;	djnz	dilly		;13T / 8T
4392:				;;	endm
4393:				
4394:				;;bitdly	macro			;766T
4395:				;;	delay	full
4396:				;;	endm
4397:				
4398:				;;; there are an additional 70T in the rest of the code,
4399:				;;; 833T is ideal 19200 baud, so 833-70 = 763 target
4400:				;;; 763 - 27 (call/ret) - 7 (ld) = 729
4401:				;;; 23* loop = 721T so add 2 NOPs and we're good
4402:				
4403:				;;; delay exactly 763T (hopefully)?
4404:				;;; full=22: 27T+7T+28T+21*33T = 755 + 8 = 763
4405:				                                ;27T (call+ret)
4406:32933+7	AD68  0616    	bitdly:	ld	b,dfull         ;7T
4407:32940+4	AD6A  00      	dilly:	nop			;4T
4408:32944+4	AD6B  00      		nop			;4T
4409:32948+4	AD6C  00      		nop			;4T
4410:32952+4	AD6D  00      		nop			;4T
4411:32956+4	AD6E  00      		nop			;4T
4412:32960+8+5	AD6F  10F9    		djnz	dilly		;13T / 8T
4413:32968+4	AD71  00      		nop			;4T
4414:32972+4	AD72  00      		nop			;4T
4415:32976+10	AD73  C9      		ret
4416:				
4417:				;;; old version was 332T
4418:				;;; this one is 330T
4419:				                                ;27T (call+ret)
4420:32986+7	AD74  0609    	halfdly: ld	b,dhalf		;7T
4421:32993+4	AD76  00      	dally:	nop			;4T
4422:32997+4	AD77  00      		nop			;4T
4423:33001+4	AD78  00      		nop			;4T
4424:33005+4	AD79  00      		nop			;4T
4425:33009+4	AD7A  00      		nop			;4T
4426:33013+8+5	AD7B  10F9    		djnz	dally		;13T / 8T
4427:33021+4	AD7D  00      		nop			;4T
4428:33025+10	AD7E  C9      		ret
4429:				
4430:				;;;
4431:				;;; check for serial activity (break)
4432:				;;; if so, wait for end of activity, then receive a character
4433:				;;; return 0 (Z) if no character, else char in A
4434:				;;;
4435:     -	AD7F          	umon_chkbrk:
4436:33035+11	AD7F  DB80    		in	a,(serial_port)
4437:33046+7	AD81  E680    		and	data_bit
4438:33053+7+5	AD83  2008    		jr	nz,nobrk
4439:					;; got break, wait for it to end
4440:33060+11	AD85  DB80    	isbrk:	in	a,(serial_port)
4441:33071+7	AD87  E680    		and	data_bit
4442:33078+7+5	AD89  28FA    		jr	z, isbrk	;loop while low
4443:				
4444:33085+12	AD8B  1802    		jr	umon_getc	;now go get a character
4445:				
4446:33097+4	AD8D  AF      	nobrk:	xor	a		; zero a, set Z
4447:33101+10	AD8E  C9      		ret
4448:				
4449:				;;; 
4450:				;;; receive a character to A
4451:				;;; 
4452:     -	AD8F          	umon_getc:	
4453:33111+11	AD8F  C5      		push	bc
4454:33122+11	AD90  D5      		push	de
4455:33133+11	AD91  E5      		push	hl
4456:				
4457:33144+7	AD92  1E09    		ld	e,9		; bit count (start + 8 data)
4458:					
4459:					;; wait for high
4460:33151+11	AD94  DB80    	ci0:	in	a,(serial_port)
4461:33162+7	AD96  E680    		and	data_bit
4462:33169+7+5	AD98  28FA    		jr	z,ci0		;loop if/while low
4463:					
4464:33176+11	AD9A  DB80    	ci1:	in	a,(serial_port) ; read serial line
4465:33187+7	AD9C  E680    		and	data_bit	; isolate serial bit
4466:33194+7+5	AD9E  20FA    		jr	nz,ci1		; loop while high
4467:33201+17	ADA0  CD74AD  		call 	halfdly		;delay to middle of first (start) bit
4468:				
4469:     -	ADA3          	ci3:
4470:33218+17	ADA3  CD68AD  		call	bitdly	       ;delay to middle of LSB data bit    766
4471:33235+11	ADA6  DB80    		in	a,(serial_port) ; read serial character              12
4472:33246+7	ADA8  E680    		and	data_bit	; isolate serial data                 7
4473:33253+7+5	ADAA  2801    		jr	z,ci6		; j if data is 0                  7 / 12
4474:33260+4	ADAC  3C      		inc	a		; now register A=serial data          4
4475:33264+4	ADAD  1F      	ci6:	rra			; rotate it into carry                4
4476:33268+4	ADAE  1D      		dec	e		; dec bit count                       4
4477:33272+7+5	ADAF  2805    		jr	z,ci5		; j if last bit                   7 / 12
4478:					
4479:33279+4	ADB1  79      		ld	a,c		; this is where we assemble char      4
4480:33283+4	ADB2  1F      		rra			; rotate it into the character from c 4
4481:33287+4	ADB3  4F      		ld	c,a		;                                     4
4482:				
4483:33291+12	ADB4  18ED    		jr	ci3		; do next bit                        12
4484:					
4485:					;; total loop ~ 836T = 52.3 uS or 19139 Hz (0.3% error, not bad!)
4486:				
4487:33303+4	ADB6  79      	ci5:	ld	a,c
4488:					
4489:33307+10	ADB7  E1      		pop	hl
4490:33317+10	ADB8  D1      		pop	de
4491:33327+10	ADB9  C1      		pop	bc
4492:				
4493:33337+10	ADBA  C9      		ret
4494:				
4495:				;;;
4496:				;;; send character in A
4497:				;;; saves all
4498:				;;; 
4499:     -	ADBB          	umon_putc:
4500:33347+11	ADBB  C5      		push	bc
4501:33358+11	ADBC  D5      		push	de
4502:33369+11	ADBD  F5      		push	af
4503:33380+4	ADBE  4F      		ld	c,a		;character to C
4504:				
4505:33384+7	ADBF  1E08    		ld	e,8		;bit counter
4506:					
4507:				;	mark			;ensure a stop bit
4508:33391+7	ADC1  3E80    		ld	a,data_bit
4509:33398+11	ADC3  D300    		out	(led_port),a
4510:33409+17	ADC5  CD68AD  		call	bitdly
4511:					
4512:				;	spc			;start bit
4513:33426+7	ADC8  3E00    		ld	a,0
4514:33433+11	ADCA  D300    		out	(led_port),a
4515:33444+17	ADCC  CD68AD  		call	bitdly
4516:					
4517:					;; loop here for bits
4518:33461+8	ADCF  CB19    	rrot:	rr	c		;shift out LSB
4519:33469+7+5	ADD1  3806    		jr	c,one
4520:					
4521:				;	spc
4522:33476+7	ADD3  3E00    		ld	a,0
4523:33483+11	ADD5  D300    		out	(led_port),a
4524:33494+12	ADD7  1804    		jr	bite
4525:     -	ADD9          	one:
4526:				;	mark
4527:33506+7	ADD9  3E80    		ld	a,data_bit
4528:33513+11	ADDB  D300    		out	(led_port),a
4529:     -	ADDD          	bite:
4530:33524+17	ADDD  CD68AD  		call	bitdly
4531:					
4532:33541+4	ADE0  1D      		dec	e
4533:33545+7+5	ADE1  20EC    		jr	nz,rrot
4534:				;	mark
4535:33552+7	ADE3  3E80    		ld	a,data_bit
4536:33559+11	ADE5  D300    		out	(led_port),a
4537:33570+17	ADE7  CD68AD  		call	bitdly		; stop bit
4538:					
4539:33587+10	ADEA  F1      		pop	af
4540:33597+10	ADEB  D1      		pop	de
4541:33607+10	ADEC  C1      		pop	bc
4542:33617+10	ADED  C9      		ret
4543:					
4544:     -	ADEE          		.end



Statistics:

     4	passes
     0	jr promotions
   657	symbols
  7406	bytes



Symbol Table:

abpass          a130     
abs             a77c     
accsum          9999     
acpass          a12f     
add30           ac90     
add301          aca0     
addexp          a715     
addig           a8bb     
addphl          a502     
allfol          a3fe     
antvlu          9c99     
aret            ac0c     
aretn           ad59     
arldsv          a050     
arrend         =b11f     
arrlp           a2c9     
asc             a3cf     
asctfp          a85e     
aspcs           9bfb     
atn             abc0     
atn1            abdd     
atntab          abe7     
atoh            99d4     
badinp          9c20     
bakstk          9456     
baktmp          a3af     
bastxt         =b0a3     
bcdefp          a7a3     
bfree           91ad     
bin             ace2     
bin2            ace8     
binerr          ad3f     
binit           ad1e     
bintfp          ad14     
bitdly          ad68     
bite            addd     
bitout          acfc     
bitout2         ad00     
bksp           =   8     
bn             =  28     
bnorm           a562     
bnrmlp          a565     
brk             994b     
brkflg         =b092     
brklin         =b113     
brkmsg          9450     
brkret          91a7     
bs             =  10     
bserr           a083     
buffer         =b0a6     
byt2asc         ac87     
bytsft          a69a     
cfeval          9fe6     
charty          9f94     
chekfn          a1c7     
chkbin          ad31     
chkltr          99a6     
chkstk          948a     
chksum         =b08f     
chksyn          977b     
chktyp          9d7a     
chr             a3e0     
ci0             ad94     
ci1             ad9a     
ci3             ada3     
ci5             adb6     
ci6             adad     
clear           99f9     
clotst          97b0     
clreg           95df     
clrptr          95ba     
cls             ac11     
cmpfp           a7ec     
cmplg1          9efa     
cmplog          9ef8     
cmpnum          a7d2     
cmpres          9f3c     
cmpstr          9f24     
cn             =  20     
cnvnum          a86a     
cold            9100     
comman         =b088     
compl           a5c2     
concat          a344     
conexp          a89a     
conpos          a55f     
cont            997e     
contad         =b119     
convar          9e65     
copy            9120     
cos             ab44     
count           9820     
cpdehl          9775     
cpylit          96b1     
cr             =   d     
crarlp          a0a3     
creary          a088     
crestr          9af8     
crnclp          9612     
crtmst          a200     
crtst           a20c     
crtste          a222     
crunch          9609     
cs             =   c     
cstart          9111     
ctlofg         =b08a     
ctrlc          =   3     
ctrlg          =   7     
ctrlo          =   f     
ctrlq          =  11     
ctrlr          =  12     
ctrls          =  13     
ctrlu          =  15     
curopr         =b10a     
curpos         =b0f0     
dally           ad76     
data            9a9f     
data_bit       =  80     
datflg         =b0f3     
datlin         =b10e     
datsnr          94a7     
dcbcde          a823     
dd             =  12     
dderr           94b6     
deek            ac2d     
def             a144     
defsiz          a0ab     
deint           99ba     
del            =  7f     
delchr          96e1     
depint          99b4     
dethl4          a7b2     
dethlb          a7b4     
dfull          =  16     
dhalf          =   9     
digtxt          a964     
dilly           ad6a     
dim             9f66     
dimret          9f5d     
dinpos          97aa     
div             a6ab     
div1           =b04f     
div10           a69f     
div2           =b053     
div3           =b057     
div4           =b05a     
divlp           a6d2     
divsup         =b04e     
doagn           95f8     
docom           9bcc     
dodel           96c1     
doebit          a9a4     
dofn            a171     
doke            ac38     
donull          9bba     
dospc           9bf6     
dotab           9be3     
dpoint          a896     
dtstr           a210     
dvbcde          a6ad     
dz             =  14     
dzerr           94b0     
echdel          96d5     
edigit          a8dd     
endbuf          96b8     
endcon          a8a9     
enddim          a10a     
endinp          9bab     
endnam          9f88     
endprg          995a     
enfmem          9493     
errin           94e1     
errlin         =b117     
errmsg          943e     
error           94c1     
errors          93b4     
esc            =  1b     
eval            9d87     
eval1           9d8a     
eval2           9d93     
eval3           9d96     
evlpar          9e4c     
evnot           9f46     
excute          98e5     
exp             aa3e     
explp           a888     
exptab          aa7e     
expten          a9b6     
extig           9cf5     
fandt           9d1f     
fc             =   8     
fcerr           99cf     
fdtlp           9d06     
findel          a0e6     
flgdif          a762     
flgrel          a769     
fnarg          =b125     
fnctab          91fe     
fndary          a056     
fndelp          a0eb     
fndend          958d     
fndnum          a4d3     
fndtok          97ff     
fndvar          9fcd     
fndwrd          963c     
fnofst          9e76     
fnrgnm         =b123     
fnthr           9fdb     
fnval           9e9d     
foprnd          9dbf     
for             984c     
forflg         =b110     
forfnd          987c     
forslp          9860     
fpadd           a511     
fpbcde          a798     
fpexp          =b12c     
fpint           a7ff     
fpmult          a64c     
fpreg          =b129     
fprond          a5a9     
fpsint          99ae     
fpthl           a7af     
fre             a10e     
frenum          a12a     
frmevl          9e68     
garbge          a291     
garblp          a294     
getchr          9905     
getcmd          9505     
gethex          acbd     
getinp          ac0d     
getint          a4d6     
getlen          a3c4     
getlin          96f2     
getln           99d5     
getnum          9d75     
getnxt          9657     
getstr          a38e     
getvar          9f6b     
gnxary          a2c8     
gofunc          9ea5     
gosub           9a4b     
goto            9a5c     
grbary          a2e8     
grbdon          a269     
grblp           a2a2     
gstrcu          a391     
gstrde          a395     
gstrhl          a394     
gtflnm          a3d3     
gtfnam          9f70     
gtlnlp          99d8     
gtsixd          a92e     
gtvlus          9c71     
half            a9d5     
halfdly         ad74     
halfpi          ab8e     
hex             ac4f     
hex1            ac68     
hex2            ac6a     
hex3            ac78     
hex4            ac7a     
hexit           acd4     
hexlp           acb0     
hexlp1          acb5     
hextfp          aca4     
hx             =  26     
hxerr           acdd     
id             =  16     
idtest          a1b9     
if              9b2e     
ifgo            9b3c     
ifjmp           98ec     
inchl           a7ad     
inclen          97a6     
indfnd          9470     
inewln          9555     
init            9118     
initab          93de     
initbe          943e     
initst          ad51     
inmsg           9445     
inp             a493     
inpbin          9cc3     
inpbrk          9957     
inport         =b084     
inpsub         =b083     
input           9c31     
inrng           a937     
int             a82a     
intvar          95c9     
invsgn          a780     
isbrk           ad85     
itmsep          9cb4     
jjump1          ad44     
jstzer          a9c0     
kilfor          9d65     
kilin           96ec     
lcrflg         =b0f1     
led_port       =   0     
left            a3f0     
len             a3c0     
let             9ab6     
letnum          9b09     
letstr          9ad1     
lf             =   a     
lfrgnm          a489     
lineat         =b0a1     
linein          a8e9     
lines           ac1e     
linesc         =b08b     
linesn         =b08d     
linfnd          953e     
list            97c1     
listlp          97cd     
loadfp          a7a6     
log             a60b     
logtab          a5fe     
lokfor          945a     
loopst         =b10c     
ls             =  1c     
lstbin         =b111     
lstlp2          97ed     
lstlp3          97f0     
lstram         =b0f4     
lstrnd         =b07f     
ltstnd          9cce     
lwidth         =b087     
makint          a4d9     
maknum          a953     
manlp           a872     
match           9689     
memmsg          91f3     
mid             a42a     
mid1            a3f6     
midnum          a48e     
mincde          a551     
minus           9e54     
mktmst          a1fd     
mldblp          a84b     
mldebc          a843     
mloop           9148     
mlsp10          a740     
mo             =  24     
monitr          ad4e     
monout          ad4b     
mordt           9cda     
morinp          96fb     
movbuf          9574     
movdir          9691     
movlp           947f     
movstr          947c     
movup           9479     
mrprnt          9b4e     
msize           9135     
mul8lp          a677     
mulln2          a643     
mult            a64a     
mult8           a66e     
multen          a8b4     
mulval         =b13b     
mvstpt          9b00     
nedmor          9c6d     
negaft          a9eb     
new             95b9     
nexitm          9c06     
next            9d2a     
next1           9d2d     
nf             =   0     
nferr           94b3     
nmiflg         =b091     
nobrk           ad8d     
nochng          9681     
noened          a9c3     
nolin           996d     
nomadd          a688     
nomlad          a859     
nopmpt          9c4b     
normal          a57c     
nospc           9678     
nosub7          acd0     
noswap          a52b     
notamp          9e29     
notstr          9fa3     
noxor           a4b9     
nscfor          9fb3     
nulflg         =b089     
null            9991     
nullp           9bc1     
nulls          =b086     
numasc          a8fc     
nxtary          a06a     
nxtbyt          9667     
nxtchr          96a8     
nxtdat         =b121     
nxtdta          9a9e     
nxtitm          9c65     
nxtopr         =b115     
nxtstl          9aa5     
nxtstt          9aa8     
od             =   6     
okmsg           944a     
om             =   c     
omerr           94a2     
on              9b10     
one             add9     
ongo            9b1f     
ongolp          9b20     
onjmp           98ed     
opnpar          9d83     
oprnd           9dfe     
os             =  1a     
otkln           96e9     
otport         =b04c     
outc            9786     
outexp          a9b4     
outit           9767     
outnbs          976d     
outncr          ad62     
outsub         =b04b     
outwrd          9809     
ov             =   a     
overr           94bc     
ovtst1          a733     
ovtst2          a738     
ovtst3          a739     
padd            a8d8     
pand            9ebf     
passa           a13f     
pbuff          =b12e     
peek            a4e7     
pend            9952     
phltfp          a795     
plucde          a5b6     
pnorm           a584     
point          =b096     
poke            a4ee     
popaf           a283     
pophl           a3ad     
pophrt          a698     
popnok          94f7     
por             9ebe     
por1            9ee1     
pos             a13c     
posint          99b1     
pout            a49f     
power           a9f9     
power1          aa09     
power2          aa26     
powers          a9d9     
print           9b52     
pritab          939f     
prntcrlf        9bb0     
prnthl          a8f1     
prntlp          9b55     
prntnb          9b98     
prntok          94f8     
prntst          9b9c     
prnums          a24d     
proces          9714     
prognd         =b11b     
progst         =b13e     
prompt          95fc     
prs             a24e     
prs1            a251     
prslp           a258     
pset           =b099     
psub            a50c     
ptrlp           9581     
putbuf          9753     
putctl          9758     
putfid          98c1     
qtstlp          a213     
qtstr           a20d     
quartr          ab92     
read            9c60     
readfg         =b112     
redo            9c0d     
rem             9aa1     
resdiv          a6e5     
reseed          ab30     
reset          =b09c     
restnl          992a     
restor          9915     
reszer          a577     
retadr          a01a     
retint          a76e     
retlin          9a99     
retnad          968d     
retnul          a01d     
retnum          9e60     
retrel          a760     
return          9a7a     
rg             =   4     
right           a420     
right1          a3f4     
rinput         =b093     
rltlp           9da3     
rnd             aacf     
rnd1            ab0b     
rnd2            ab27     
rndtab          ab38     
rngtst          a9c6     
rondb           a598     
rondup          a597     
round           a4ff     
rrot            adcf     
rscale          a8d2     
rslnbk          9843     
rststr          a443     
run             9a3f     
runcnt          98c5     
runfst          95c5     
runlin          9a5b     
savexp          a578     
savstp          98b8     
savstr          a1e8     
sbscpt          a028     
scale           a5d6     
scallp          a5d8     
scalmi          a89d     
scalpl          a8b3     
scnend          a31f     
scptlp          a02e     
search          9655     
seed           =b05c     
serial_port    =  80     
setio           a4c3     
setlin          9817     
setlit          969f     
setptr          957c     
settop          916c     
sftprg          9546     
sgn             a766     
sgnexp          9eae     
sgnres         =b12d     
shrite          a5e5     
shrlp           a5e8     
shrt1           a5ec     
signon          91bc     
signs           a7bd     
sin             ab4a     
sin1            ab7a     
sintab          ab96     
sixdig          a919     
smpvar          a2b3     
smser1          aaae     
sn             =   2     
snerr           94ad     
spcfst          a90a     
spclp           9bff     
sqr             a9f0     
srchln          9599     
srchlp          959c     
sstsa           a37b     
st             =  1e     
stack          =b0ab     
stakfp          a788     
stall           993f     
startb          9106     
stkths          9de7     
stlook         =b1a2     
stop            9950     
stored          9a1c     
stpool          a2f6     
str             a1d8     
str1            a1de     
stradd          a2f9     
strbot         =b108     
strent          9cb7     
strspc         =b09f     
sttlin          9ba3     
subcde          a50e     
subphl          a508     
sumlp           aab7     
sumser          aa9f     
suptlz          a998     
svnam2          9f87     
svstad          a206     
tan             abab     
testos          a285     
testr           a267     
tm             =  18     
tmerr           94bf     
tmpstr         =b104     
tmstpl         =b0f8     
tmstpt         =b0f6     
topool          a3ec     
tostra          a384     
tryagn          a973     
tsalp           a385     
tstbit          ad5b     
tstbrk          9930     
tstmem          915a     
tstnum          9d78     
tstopl          a22e     
tstred          9ee6     
tstrem          96a2     
tstsgn          a757     
tststr          9d79     
ttylin          96f2     
type           =b0f2     
uf             =  22     
uferr           94b9     
ul             =   e     
ulerr           9a75     
umon_chkbrk     ad7f     
umon_getc       ad8f     
umon_putc       adbb     
unity           a5fa     
updata          992b     
usr            =b048     
val             a45a     
val1            a478     
val2            a482     
val3            a485     
varend         =b11d     
wait            a4a5     
waitlp          a4ba     
warm            9103     
warmst          91a4     
width           ac16     
words           9236     
wordtb          9355     
wrkspc         =b045     
zdata          =  83     
zdiv           =  af     
zend           =  80     
zequal         =  b4     
zerary          a0c9     
zerbyt         =9449     
zerolp          a00c     
zerosup         acee     
zfn            =  a7     
zfor           =  81     
zgosub         =  8c     
zgoto          =  88     
zgtr           =  b3     
zleft          =  cf     
zlth           =  b5     
zminus         =  ad     
znew           =  a4     
znot           =  aa     
zonelp          9bda     
zor            =  b2     
zplus          =  ac     
zpoint         =  c7     
zprint         =  9e     
zrem           =  8e     
zsgn           =  b6     
zspc           =  a8     
zstep          =  ab     
ztab           =  a5     
zthen          =  a9     
ztimes         =  ae     
zto            =  a6     
