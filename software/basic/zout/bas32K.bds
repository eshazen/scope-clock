binary-debuggable-source
0000 0000 f bas32K.asm
0000 0000 s ;==================================================================================
0000 0000 s ; Modifications by Eric Hazen for the Retro-25 project 
0000 0000 s ;    (https://github.com/eshazen/retro-25)
0000 0000 s ; See <ESH> tags for my modifications
0000 0000 s ; Inserted my serial code at the end to keep it all in one file
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;
0000 0000 s ; The updates to the original BASIC within this file are copyright Grant Searle
0000 0000 s ;
0000 0000 s ; You have permission to use this for NON COMMERCIAL USE ONLY
0000 0000 s ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0000 0000 s ;
0000 0000 s ; http://searle.hostei.com/grant/index.html
0000 0000 s ; (now see http://searle.wales)
0000 0000 s ;
0000 0000 s ; eMail: home.micros01@btinternet.com
0000 0000 s ;
0000 0000 s ; If the above don't work, please perform an Internet search to see if I have
0000 0000 s ; updated the web page hosting service.
0000 0000 s ;
0000 0000 s ;==================================================================================
0000 0000 s 
0000 0000 s ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0000 0000 s ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0000 0000 s ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0000 0000 s ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0000 0000 s ; the original ROM code (checksum A934H). PA
0000 0000 s 
0000 0000 s ; GENERAL EQUATES
0000 0000 s 
0000 0000 s CTRLC   .EQU    03H             ; Control "C"
0000 0000 s CTRLG   .EQU    07H             ; Control "G"
0000 0000 s BKSP    .EQU    08H             ; Back space
0000 0000 s LF      .EQU    0AH             ; Line feed
0000 0000 s CS      .EQU    0CH             ; Clear screen
0000 0000 s CR      .EQU    0DH             ; Carriage return
0000 0000 s CTRLO   .EQU    0FH             ; Control "O"
0000 0000 s CTRLQ	.EQU	11H		; Control "Q"
0000 0000 s CTRLR   .EQU    12H             ; Control "R"
0000 0000 s CTRLS   .EQU    13H             ; Control "S"
0000 0000 s CTRLU   .EQU    15H             ; Control "U"
0000 0000 s ESC     .EQU    1BH             ; Escape
0000 0000 s DEL     .EQU    7FH             ; Delete
0000 0000 s 
0000 0000 s ; BASIC WORK SPACE LOCATIONS
0000 0000 s 
0000 0000 s ;WRKSPC  .EQU    8045H             ; BASIC Work space
0000 0000 s WRKSPC  .EQU    0B045H             ; BASIC Work space
0000 0000 s USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0000 0000 s OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0000 0000 s OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0000 0000 s DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0000 0000 s DIV1    .EQU    WRKSPC+0AH           ; <- Values
0000 0000 s DIV2    .EQU    WRKSPC+0EH           ; <-   to
0000 0000 s DIV3    .EQU    WRKSPC+12H           ; <-   be
0000 0000 s DIV4    .EQU    WRKSPC+15H           ; <-inserted
0000 0000 s SEED    .EQU    WRKSPC+17H           ; Random number seed
0000 0000 s LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0000 0000 s INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0000 0000 s INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0000 0000 s NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0000 0000 s LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0000 0000 s COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0000 0000 s NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0000 0000 s CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0000 0000 s LINESC  .EQU    WRKSPC+46H           ; Lines counter
0000 0000 s LINESN  .EQU    WRKSPC+48H           ; Lines number
0000 0000 s CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0000 0000 s NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0000 0000 s BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0000 0000 s RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0000 0000 s POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0000 0000 s PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0000 0000 s RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0000 0000 s STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0000 0000 s LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0000 0000 s BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0000 0000 s BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0000 0000 s STACK   .EQU    WRKSPC+66H           ; Initial stack
0000 0000 s CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0000 0000 s LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0000 0000 s TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0000 0000 s DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0000 0000 s LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0000 0000 s TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0000 0000 s TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0000 0000 s TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0000 0000 s STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0000 0000 s CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0000 0000 s LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0000 0000 s DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0000 0000 s FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0000 0000 s LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0000 0000 s READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0000 0000 s BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0000 0000 s NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0000 0000 s ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0000 0000 s CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0000 0000 s PROGND  .EQU    WRKSPC+0D6H          ; End of program
0000 0000 s VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0000 0000 s ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0000 0000 s NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0000 0000 s FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0000 0000 s FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0000 0000 s FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0000 0000 s FPEXP   .EQU    FPREG+3         ; Floating point exponent
0000 0000 s SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0000 0000 s PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0000 0000 s MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0000 0000 s PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0000 0000 s STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0000 0000 s 
0000 0000 s ; BASIC ERROR CODE VALUES
0000 0000 s 
0000 0000 s NF      .EQU    00H             ; NEXT without FOR
0000 0000 s SN      .EQU    02H             ; Syntax error
0000 0000 s RG      .EQU    04H             ; RETURN without GOSUB
0000 0000 s OD      .EQU    06H             ; Out of DATA
0000 0000 s FC      .EQU    08H             ; Function call error
0000 0000 s OV      .EQU    0AH             ; Overflow
0000 0000 s OM      .EQU    0CH             ; Out of memory
0000 0000 s UL      .EQU    0EH             ; Undefined line number
0000 0000 s BS      .EQU    10H             ; Bad subscript
0000 0000 s DD      .EQU    12H             ; Re-DIMensioned array
0000 0000 s DZ      .EQU    14H             ; Division by zero (/0)
0000 0000 s ID      .EQU    16H             ; Illegal direct
0000 0000 s TM      .EQU    18H             ; Type miss-match
0000 0000 s OS      .EQU    1AH             ; Out of string space
0000 0000 s LS      .EQU    1CH             ; String too long
0000 0000 s ST      .EQU    1EH             ; String formula too complex
0000 0000 s CN      .EQU    20H             ; Can't CONTinue
0000 0000 s UF      .EQU    22H             ; UnDEFined FN function
0000 0000 s MO      .EQU    24H             ; Missing operand
0000 0000 s HX      .EQU    26H             ; HEX error
0000 0000 s BN      .EQU    28H             ; BIN error
0000 0000 s 
0000 0000 s ;        .ORG    8100H		; <ESH> lives in RAM
9100 9100 s         .ORG    9100H		; above UMON <FIXME>
9100 9100 s ;;; NOTE: also need to change WRKSPC somewhere safe
9100 9100 s 
9100 9100 d c30691
9100 9100 s COLD:   JP      STARTB          ; Jump for cold start
9103 9103 d c3a491
9103 9103 s WARM:   JP      WARMST          ; Jump for warm start
9106 9106 s STARTB: 
9106 9106 d dd210000
9106 9106 s         LD      IX,0            ; Flag cold start
910a 910a d c31191
910a 910a s         JP      CSTART          ; Jump to initialise
910d 910d s 
910d 910d d ba99
910d 910d s         .WORD   DEINT           ; Get integer -32768 to 32767
910f 910f d 30a1
910f 910f s         .WORD   ABPASS          ; Return integer in AB
9111 9111 s 
9111 9111 s 
9111 9111 d 2145b0
9111 9111 s CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
9114 9114 d f9
9114 9114 s         LD      SP,HL           ; Set up a temporary stack
9115 9115 d c351ad
9115 9115 s         JP      INITST          ; Go to initialise
9118 9118 s 
9118 9118 d 11de93
9118 9118 s INIT:   LD      DE,INITAB       ; Initialise workspace
911b 911b d 0663
911b 911b s         LD      B,INITBE-INITAB+3; Bytes to copy
911d 911d d 2145b0
911d 911d s         LD      HL,WRKSPC       ; Into workspace RAM
9120 9120 d 1a
9120 9120 s COPY:   LD      A,(DE)          ; Get source
9121 9121 d 77
9121 9121 s         LD      (HL),A          ; To destination
9122 9122 d 23
9122 9122 s         INC     HL              ; Next destination
9123 9123 d 13
9123 9123 s         INC     DE              ; Next source
9124 9124 d 05
9124 9124 s         DEC     B               ; Count bytes
9125 9125 d c22091
9125 9125 s         JP      NZ,COPY         ; More to move
9128 9128 d f9
9128 9128 s         LD      SP,HL           ; Temporary stack
9129 9129 d cddf95
9129 9129 s         CALL    CLREG           ; Clear registers and stack
912c 912c d cdb09b
912c 912c s         CALL    PRNTCRLF        ; Output CRLF
912f 912f d 32efb0
912f 912f s         LD      (BUFFER+72+1),A ; Mark end of buffer
9132 9132 d 323eb1
9132 9132 s         LD      (PROGST),A      ; Initialise program area
9135 9135 d 21f391
9135 9135 s MSIZE:  LD      HL,MEMMSG       ; Point to message
9138 9138 d cd4ea2
9138 9138 s         CALL    PRS             ; Output "Memory size"
913b 913b d cdfc95
913b 913b s         CALL    PROMPT          ; Get input with '?'
913e 913e d cd0599
913e 913e s         CALL    GETCHR          ; Get next character
9141 9141 d b7
9141 9141 s         OR      A               ; Set flags
9142 9142 d c25a91
9142 9142 s         JP      NZ,TSTMEM       ; If number - Test if RAM there
9145 9145 d 21a2b1
9145 9145 s         LD      HL,STLOOK       ; Point to start of RAM
9148 9148 d 23
9148 9148 s MLOOP:  INC     HL              ; Next byte
9149 9149 d 7c
9149 9149 s         LD      A,H             ; Above address FFFF ?
914a 914a d b5
914a 914a s         OR      L
914b 914b d ca6c91
914b 914b s         JP      Z,SETTOP        ; Yes - 64K RAM
914e 914e d 7e
914e 914e s         LD      A,(HL)          ; Get contents
914f 914f d 47
914f 914f s         LD      B,A             ; Save it
9150 9150 d 2f
9150 9150 s         CPL                     ; Flip all bits
9151 9151 d 77
9151 9151 s         LD      (HL),A          ; Put it back
9152 9152 d be
9152 9152 s         CP      (HL)            ; RAM there if same
9153 9153 d 70
9153 9153 s         LD      (HL),B          ; Restore old contents
9154 9154 d ca4891
9154 9154 s         JP      Z,MLOOP         ; If RAM - test next byte
9157 9157 d c36c91
9157 9157 s         JP      SETTOP          ; Top of RAM found
915a 915a s 
915a 915a d cdd499
915a 915a s TSTMEM: CALL    ATOH            ; Get high memory into DE
915d 915d d b7
915d 915d s         OR      A               ; Set flags on last byte
915e 915e d c2ad94
915e 915e s         JP      NZ,SNERR        ; ?SN Error if bad character
9161 9161 d eb
9161 9161 s         EX      DE,HL           ; Address into HL
9162 9162 d 2b
9162 9162 s         DEC     HL              ; Back one byte
9163 9163 d 3ed9
9163 9163 s         LD      A,11011001B     ; Test byte
9165 9165 d 46
9165 9165 s         LD      B,(HL)          ; Get old contents
9166 9166 d 77
9166 9166 s         LD      (HL),A          ; Load test byte
9167 9167 d be
9167 9167 s         CP      (HL)            ; RAM there if same
9168 9168 d 70
9168 9168 s         LD      (HL),B          ; Restore old contents
9169 9169 d c23591
9169 9169 s         JP      NZ,MSIZE        ; Ask again if no RAM
916c 916c s 
916c 916c d 2b
916c 916c s SETTOP: DEC     HL              ; Back one byte
916d 916d d 11a1b1
916d 916d s         LD      DE,STLOOK-1     ; See if enough RAM
9170 9170 d cd7597
9170 9170 s         CALL    CPDEHL          ; Compare DE with HL
9173 9173 d da3591
9173 9173 s         JP      C,MSIZE         ; Ask again if not enough RAM
9176 9176 d 11ceff
9176 9176 s         LD      DE,0-50         ; 50 Bytes string space
9179 9179 d 22f4b0
9179 9179 s         LD      (LSTRAM),HL     ; Save last available RAM
917c 917c d 19
917c 917c s         ADD     HL,DE           ; Allocate string space
917d 917d d 229fb0
917d 917d s         LD      (STRSPC),HL     ; Save string space
9180 9180 d cdba95
9180 9180 s         CALL    CLRPTR          ; Clear program area
9183 9183 d 2a9fb0
9183 9183 s         LD      HL,(STRSPC)     ; Get end of memory
9186 9186 d 11efff
9186 9186 s         LD      DE,0-17         ; Offset for free bytes
9189 9189 d 19
9189 9189 s         ADD     HL,DE           ; Adjust HL
918a 918a d 113eb1
918a 918a s         LD      DE,PROGST       ; Start of program text
918d 918d d 7d
918d 918d s         LD      A,L             ; Get LSB
918e 918e d 93
918e 918e s         SUB     E               ; Adjust it
918f 918f d 6f
918f 918f s         LD      L,A             ; Re-save
9190 9190 d 7c
9190 9190 s         LD      A,H             ; Get MSB
9191 9191 d 9a
9191 9191 s         SBC     A,D             ; Adjust it
9192 9192 d 67
9192 9192 s         LD      H,A             ; Re-save
9193 9193 d e5
9193 9193 s         PUSH    HL              ; Save bytes free
9194 9194 d 21bc91
9194 9194 s         LD      HL,SIGNON       ; Sign-on message
9197 9197 d cd4ea2
9197 9197 s         CALL    PRS             ; Output string
919a 919a d e1
919a 919a s         POP     HL              ; Get bytes free back
919b 919b d cdf1a8
919b 919b s         CALL    PRNTHL          ; Output amount of free memory
919e 919e d 21ad91
919e 919e s         LD      HL,BFREE        ; " Bytes free" message
91a1 91a1 d cd4ea2
91a1 91a1 s         CALL    PRS             ; Output string
91a4 91a4 s 
91a4 91a4 d 31abb0
91a4 91a4 s WARMST: LD      SP,STACK        ; Temporary stack
91a7 91a7 d cddf95
91a7 91a7 s BRKRET: CALL    CLREG           ; Clear registers and stack
91aa 91aa d c3f894
91aa 91aa s         JP      PRNTOK          ; Go to get command line
91ad 91ad s 
91ad 91ad d 20427974657320667265650d0a0000
91ad 91ad s BFREE:  .BYTE   " Bytes free",CR,LF,0,0
91bc 91bc s 
91bc 91bc d 5a38302042415349432056657220342e37620d0a
91bc 91bc s SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
91d0 91d0 d 436f7079726967687420284329
91d0 91d0 s         .BYTE   "Copyright ",40,"C",41
91dd 91dd d 2031393738206279204d6963726f736f66740d0a0000
91dd 91dd s         .BYTE   " 1978 by Microsoft",CR,LF,0,0
91f3 91f3 s 
91f3 91f3 d 4d656d6f727920746f7000
91f3 91f3 s MEMMSG: .BYTE   "Memory top",0
91fe 91fe s 
91fe 91fe s ; FUNCTION ADDRESS TABLE
91fe 91fe s 
91fe 91fe d 66a7
91fe 91fe s FNCTAB: .WORD   SGN
9200 9200 d 2aa8
9200 9200 s         .WORD   INT
9202 9202 d 7ca7
9202 9202 s         .WORD   ABS
9204 9204 d 48b0
9204 9204 s         .WORD   USR
9206 9206 d 0ea1
9206 9206 s         .WORD   FRE
9208 9208 d 93a4
9208 9208 s         .WORD   INP
920a 920a d 3ca1
920a 920a s         .WORD   POS
920c 920c d f0a9
920c 920c s         .WORD   SQR
920e 920e d cfaa
920e 920e s         .WORD   RND
9210 9210 d 0ba6
9210 9210 s         .WORD   LOG
9212 9212 d 3eaa
9212 9212 s         .WORD   EXP
9214 9214 d 44ab
9214 9214 s         .WORD   COS
9216 9216 d 4aab
9216 9216 s         .WORD   SIN
9218 9218 d abab
9218 9218 s         .WORD   TAN
921a 921a d c0ab
921a 921a s         .WORD   ATN
921c 921c d e7a4
921c 921c s         .WORD   PEEK
921e 921e d 2dac
921e 921e s         .WORD   DEEK
9220 9220 d 96b0
9220 9220 s         .WORD   POINT
9222 9222 d c0a3
9222 9222 s         .WORD   LEN
9224 9224 d d8a1
9224 9224 s         .WORD   STR
9226 9226 d 5aa4
9226 9226 s         .WORD   VAL
9228 9228 d cfa3
9228 9228 s         .WORD   ASC
922a 922a d e0a3
922a 922a s         .WORD   CHR
922c 922c d 4fac
922c 922c s         .WORD   HEX
922e 922e d e2ac
922e 922e s         .WORD   BIN
9230 9230 d f0a3
9230 9230 s         .WORD   LEFT
9232 9232 d 20a4
9232 9232 s         .WORD   RIGHT
9234 9234 d 2aa4
9234 9234 s         .WORD   MID
9236 9236 s 
9236 9236 s ; RESERVED WORD LIST
9236 9236 s 
9236 9236 d c54e44
9236 9236 s WORDS:  .BYTE   'E'+80H,"ND"
9239 9239 d c64f52
9239 9239 s         .BYTE   'F'+80H,"OR"
923c 923c d ce455854
923c 923c s         .BYTE   'N'+80H,"EXT"
9240 9240 d c4415441
9240 9240 s         .BYTE   'D'+80H,"ATA"
9244 9244 d c94e505554
9244 9244 s         .BYTE   'I'+80H,"NPUT"
9249 9249 d c4494d
9249 9249 s         .BYTE   'D'+80H,"IM"
924c 924c d d2454144
924c 924c s         .BYTE   'R'+80H,"EAD"
9250 9250 d cc4554
9250 9250 s         .BYTE   'L'+80H,"ET"
9253 9253 d c74f544f
9253 9253 s         .BYTE   'G'+80H,"OTO"
9257 9257 d d2554e
9257 9257 s         .BYTE   'R'+80H,"UN"
925a 925a d c946
925a 925a s         .BYTE   'I'+80H,"F"
925c 925c d d24553544f5245
925c 925c s         .BYTE   'R'+80H,"ESTORE"
9263 9263 d c74f535542
9263 9263 s         .BYTE   'G'+80H,"OSUB"
9268 9268 d d2455455524e
9268 9268 s         .BYTE   'R'+80H,"ETURN"
926e 926e d d2454d
926e 926e s         .BYTE   'R'+80H,"EM"
9271 9271 d d3544f50
9271 9271 s         .BYTE   'S'+80H,"TOP"
9275 9275 d cf5554
9275 9275 s         .BYTE   'O'+80H,"UT"
9278 9278 d cf4e
9278 9278 s         .BYTE   'O'+80H,"N"
927a 927a d ce554c4c
927a 927a s         .BYTE   'N'+80H,"ULL"
927e 927e d d7414954
927e 927e s         .BYTE   'W'+80H,"AIT"
9282 9282 d c44546
9282 9282 s         .BYTE   'D'+80H,"EF"
9285 9285 d d04f4b45
9285 9285 s         .BYTE   'P'+80H,"OKE"
9289 9289 d c44f4b45
9289 9289 s         .BYTE   'D'+80H,"OKE"
928d 928d d d3435245454e
928d 928d s         .BYTE   'S'+80H,"CREEN"
9293 9293 d cc494e4553
9293 9293 s         .BYTE   'L'+80H,"INES"
9298 9298 d c34c53
9298 9298 s         .BYTE   'C'+80H,"LS"
929b 929b d d749445448
929b 929b s         .BYTE   'W'+80H,"IDTH"
92a0 92a0 d cd4f4e49544f52
92a0 92a0 s         .BYTE   'M'+80H,"ONITOR"
92a7 92a7 d d34554
92a7 92a7 s         .BYTE   'S'+80H,"ET"
92aa 92aa d d245534554
92aa 92aa s         .BYTE   'R'+80H,"ESET"
92af 92af d d052494e54
92af 92af s         .BYTE   'P'+80H,"RINT"
92b4 92b4 d c34f4e54
92b4 92b4 s         .BYTE   'C'+80H,"ONT"
92b8 92b8 d cc495354
92b8 92b8 s         .BYTE   'L'+80H,"IST"
92bc 92bc d c34c454152
92bc 92bc s         .BYTE   'C'+80H,"LEAR"
92c1 92c1 d c34c4f4144
92c1 92c1 s         .BYTE   'C'+80H,"LOAD"
92c6 92c6 d c353415645
92c6 92c6 s         .BYTE   'C'+80H,"SAVE"
92cb 92cb d ce4557
92cb 92cb s         .BYTE   'N'+80H,"EW"
92ce 92ce s 
92ce 92ce d d4414228
92ce 92ce s         .BYTE   'T'+80H,"AB("
92d2 92d2 d d44f
92d2 92d2 s         .BYTE   'T'+80H,"O"
92d4 92d4 d c64e
92d4 92d4 s         .BYTE   'F'+80H,"N"
92d6 92d6 d d3504328
92d6 92d6 s         .BYTE   'S'+80H,"PC("
92da 92da d d448454e
92da 92da s         .BYTE   'T'+80H,"HEN"
92de 92de d ce4f54
92de 92de s         .BYTE   'N'+80H,"OT"
92e1 92e1 d d3544550
92e1 92e1 s         .BYTE   'S'+80H,"TEP"
92e5 92e5 s 
92e5 92e5 d ab
92e5 92e5 s         .BYTE   '+'+80H
92e6 92e6 d ad
92e6 92e6 s         .BYTE   '-'+80H
92e7 92e7 d aa
92e7 92e7 s         .BYTE   '*'+80H
92e8 92e8 d af
92e8 92e8 s         .BYTE   '/'+80H
92e9 92e9 d de
92e9 92e9 s         .BYTE   '^'+80H
92ea 92ea d c14e44
92ea 92ea s         .BYTE   'A'+80H,"ND"
92ed 92ed d cf52
92ed 92ed s         .BYTE   'O'+80H,"R"
92ef 92ef d be
92ef 92ef s         .BYTE   '>'+80H
92f0 92f0 d bd
92f0 92f0 s         .BYTE   '='+80H
92f1 92f1 d bc
92f1 92f1 s         .BYTE   '<'+80H
92f2 92f2 s 
92f2 92f2 d d3474e
92f2 92f2 s         .BYTE   'S'+80H,"GN"
92f5 92f5 d c94e54
92f5 92f5 s         .BYTE   'I'+80H,"NT"
92f8 92f8 d c14253
92f8 92f8 s         .BYTE   'A'+80H,"BS"
92fb 92fb d d55352
92fb 92fb s         .BYTE   'U'+80H,"SR"
92fe 92fe d c65245
92fe 92fe s         .BYTE   'F'+80H,"RE"
9301 9301 d c94e50
9301 9301 s         .BYTE   'I'+80H,"NP"
9304 9304 d d04f53
9304 9304 s         .BYTE   'P'+80H,"OS"
9307 9307 d d35152
9307 9307 s         .BYTE   'S'+80H,"QR"
930a 930a d d24e44
930a 930a s         .BYTE   'R'+80H,"ND"
930d 930d d cc4f47
930d 930d s         .BYTE   'L'+80H,"OG"
9310 9310 d c55850
9310 9310 s         .BYTE   'E'+80H,"XP"
9313 9313 d c34f53
9313 9313 s         .BYTE   'C'+80H,"OS"
9316 9316 d d3494e
9316 9316 s         .BYTE   'S'+80H,"IN"
9319 9319 d d4414e
9319 9319 s         .BYTE   'T'+80H,"AN"
931c 931c d c1544e
931c 931c s         .BYTE   'A'+80H,"TN"
931f 931f d d045454b
931f 931f s         .BYTE   'P'+80H,"EEK"
9323 9323 d c445454b
9323 9323 s         .BYTE   'D'+80H,"EEK"
9327 9327 d d04f494e54
9327 9327 s         .BYTE   'P'+80H,"OINT"
932c 932c d cc454e
932c 932c s         .BYTE   'L'+80H,"EN"
932f 932f d d3545224
932f 932f s         .BYTE   'S'+80H,"TR$"
9333 9333 d d6414c
9333 9333 s         .BYTE   'V'+80H,"AL"
9336 9336 d c15343
9336 9336 s         .BYTE   'A'+80H,"SC"
9339 9339 d c3485224
9339 9339 s         .BYTE   'C'+80H,"HR$"
933d 933d d c8455824
933d 933d s         .BYTE   'H'+80H,"EX$"
9341 9341 d c2494e24
9341 9341 s         .BYTE   'B'+80H,"IN$"
9345 9345 d cc45465424
9345 9345 s         .BYTE   'L'+80H,"EFT$"
934a 934a d d24947485424
934a 934a s         .BYTE   'R'+80H,"IGHT$"
9350 9350 d cd494424
9350 9350 s         .BYTE   'M'+80H,"ID$"
9354 9354 d 80
9354 9354 s         .BYTE   80H             ; End of list marker
9355 9355 s 
9355 9355 s ; KEYWORD ADDRESS TABLE
9355 9355 s 
9355 9355 d 5299
9355 9355 s WORDTB: .WORD   PEND
9357 9357 d 4c98
9357 9357 s         .WORD   FOR
9359 9359 d 2a9d
9359 9359 s         .WORD   NEXT
935b 935b d 9f9a
935b 935b s         .WORD   DATA
935d 935d d 319c
935d 935d s         .WORD   INPUT
935f 935f d 669f
935f 935f s         .WORD   DIM
9361 9361 d 609c
9361 9361 s         .WORD   READ
9363 9363 d b69a
9363 9363 s         .WORD   LET
9365 9365 d 5c9a
9365 9365 s         .WORD   GOTO
9367 9367 d 3f9a
9367 9367 s         .WORD   RUN
9369 9369 d 2e9b
9369 9369 s         .WORD   IF
936b 936b d 1599
936b 936b s         .WORD   RESTOR
936d 936d d 4b9a
936d 936d s         .WORD   GOSUB
936f 936f d 7a9a
936f 936f s         .WORD   RETURN
9371 9371 d a19a
9371 9371 s         .WORD   REM
9373 9373 d 5099
9373 9373 s         .WORD   STOP
9375 9375 d 9fa4
9375 9375 s         .WORD   POUT
9377 9377 d 109b
9377 9377 s         .WORD   ON
9379 9379 d 9199
9379 9379 s         .WORD   NULL
937b 937b d a5a4
937b 937b s         .WORD   WAIT
937d 937d d 44a1
937d 937d s         .WORD   DEF
937f 937f d eea4
937f 937f s         .WORD   POKE
9381 9381 d 38ac
9381 9381 s         .WORD   DOKE
9383 9383 d a19a
9383 9383 s         .WORD   REM
9385 9385 d 1eac
9385 9385 s         .WORD   LINES
9387 9387 d 11ac
9387 9387 s         .WORD   CLS
9389 9389 d 16ac
9389 9389 s         .WORD   WIDTH
938b 938b d 4ead
938b 938b s         .WORD   MONITR
938d 938d d 99b0
938d 938d s         .WORD   PSET
938f 938f d 9cb0
938f 938f s         .WORD   RESET
9391 9391 d 529b
9391 9391 s         .WORD   PRINT
9393 9393 d 7e99
9393 9393 s         .WORD   CONT
9395 9395 d c197
9395 9395 s         .WORD   LIST
9397 9397 d f999
9397 9397 s         .WORD   CLEAR
9399 9399 d a19a
9399 9399 s         .WORD   REM
939b 939b d a19a
939b 939b s         .WORD   REM
939d 939d d b995
939d 939d s         .WORD   NEW
939f 939f s 
939f 939f s ; RESERVED WORD TOKEN VALUES
939f 939f s 
939f 939f s ZEND    .EQU    080H            ; END
939f 939f s ZFOR    .EQU    081H            ; FOR
939f 939f s ZDATA   .EQU    083H            ; DATA
939f 939f s ZGOTO   .EQU    088H            ; GOTO
939f 939f s ZGOSUB  .EQU    08CH            ; GOSUB
939f 939f s ZREM    .EQU    08EH            ; REM
939f 939f s ZPRINT  .EQU    09EH            ; PRINT
939f 939f s ZNEW    .EQU    0A4H            ; NEW
939f 939f s 
939f 939f s ZTAB    .EQU    0A5H            ; TAB
939f 939f s ZTO     .EQU    0A6H            ; TO
939f 939f s ZFN     .EQU    0A7H            ; FN
939f 939f s ZSPC    .EQU    0A8H            ; SPC
939f 939f s ZTHEN   .EQU    0A9H            ; THEN
939f 939f s ZNOT    .EQU    0AAH            ; NOT
939f 939f s ZSTEP   .EQU    0ABH            ; STEP
939f 939f s 
939f 939f s ZPLUS   .EQU    0ACH            ; +
939f 939f s ZMINUS  .EQU    0ADH            ; -
939f 939f s ZTIMES  .EQU    0AEH            ; *
939f 939f s ZDIV    .EQU    0AFH            ; /
939f 939f s ZOR     .EQU    0B2H            ; OR
939f 939f s ZGTR    .EQU    0B3H            ; >
939f 939f s ZEQUAL  .EQU    0B4H            ; M
939f 939f s ZLTH    .EQU    0B5H            ; <
939f 939f s ZSGN    .EQU    0B6H            ; SGN
939f 939f s ZPOINT  .EQU    0C7H            ; POINT
939f 939f s ZLEFT   .EQU    0CDH +2         ; LEFT$
939f 939f s 
939f 939f s ; ARITHMETIC PRECEDENCE TABLE
939f 939f s 
939f 939f d 79
939f 939f s PRITAB: .BYTE   79H             ; Precedence value
93a0 93a0 d d8a8
93a0 93a0 s         .WORD   PADD            ; FPREG = <last> + FPREG
93a2 93a2 s 
93a2 93a2 d 79
93a2 93a2 s         .BYTE   79H             ; Precedence value
93a3 93a3 d 0ca5
93a3 93a3 s         .WORD   PSUB            ; FPREG = <last> - FPREG
93a5 93a5 s 
93a5 93a5 d 7c
93a5 93a5 s         .BYTE   7CH             ; Precedence value
93a6 93a6 d 4aa6
93a6 93a6 s         .WORD   MULT            ; PPREG = <last> * FPREG
93a8 93a8 s 
93a8 93a8 d 7c
93a8 93a8 s         .BYTE   7CH             ; Precedence value
93a9 93a9 d aba6
93a9 93a9 s         .WORD   DIV             ; FPREG = <last> / FPREG
93ab 93ab s 
93ab 93ab d 7f
93ab 93ab s         .BYTE   7FH             ; Precedence value
93ac 93ac d f9a9
93ac 93ac s         .WORD   POWER           ; FPREG = <last> ^ FPREG
93ae 93ae s 
93ae 93ae d 50
93ae 93ae s         .BYTE   50H             ; Precedence value
93af 93af d bf9e
93af 93af s         .WORD   PAND            ; FPREG = <last> AND FPREG
93b1 93b1 s 
93b1 93b1 d 46
93b1 93b1 s         .BYTE   46H             ; Precedence value
93b2 93b2 d be9e
93b2 93b2 s         .WORD   POR             ; FPREG = <last> OR FPREG
93b4 93b4 s 
93b4 93b4 s ; BASIC ERROR CODE LIST
93b4 93b4 s 
93b4 93b4 d 4e46
93b4 93b4 s ERRORS: .BYTE   "NF"            ; NEXT without FOR
93b6 93b6 d 534e
93b6 93b6 s         .BYTE   "SN"            ; Syntax error
93b8 93b8 d 5247
93b8 93b8 s         .BYTE   "RG"            ; RETURN without GOSUB
93ba 93ba d 4f44
93ba 93ba s         .BYTE   "OD"            ; Out of DATA
93bc 93bc d 4643
93bc 93bc s         .BYTE   "FC"            ; Illegal function call
93be 93be d 4f56
93be 93be s         .BYTE   "OV"            ; Overflow error
93c0 93c0 d 4f4d
93c0 93c0 s         .BYTE   "OM"            ; Out of memory
93c2 93c2 d 554c
93c2 93c2 s         .BYTE   "UL"            ; Undefined line
93c4 93c4 d 4253
93c4 93c4 s         .BYTE   "BS"            ; Bad subscript
93c6 93c6 d 4444
93c6 93c6 s         .BYTE   "DD"            ; Re-DIMensioned array
93c8 93c8 d 2f30
93c8 93c8 s         .BYTE   "/0"            ; Division by zero
93ca 93ca d 4944
93ca 93ca s         .BYTE   "ID"            ; Illegal direct
93cc 93cc d 544d
93cc 93cc s         .BYTE   "TM"            ; Type mis-match
93ce 93ce d 4f53
93ce 93ce s         .BYTE   "OS"            ; Out of string space
93d0 93d0 d 4c53
93d0 93d0 s         .BYTE   "LS"            ; String too long
93d2 93d2 d 5354
93d2 93d2 s         .BYTE   "ST"            ; String formula too complex
93d4 93d4 d 434e
93d4 93d4 s         .BYTE   "CN"            ; Can't CONTinue
93d6 93d6 d 5546
93d6 93d6 s         .BYTE   "UF"            ; Undefined FN function
93d8 93d8 d 4d4f
93d8 93d8 s         .BYTE   "MO"            ; Missing operand
93da 93da d 4858
93da 93da s         .BYTE   "HX"            ; HEX error
93dc 93dc d 424e
93dc 93dc s         .BYTE   "BN"            ; BIN error
93de 93de s 
93de 93de s ; INITIALISATION TABLE -------------------------------------------------------
93de 93de s 
93de 93de d c3a491
93de 93de s INITAB: JP      WARMST          ; Warm start jump
93e1 93e1 d c3cf99
93e1 93e1 s         JP      FCERR           ; "USR (X)" jump (Set to Error)
93e4 93e4 d d300
93e4 93e4 s         OUT     (0),A           ; "OUT p,n" skeleton
93e6 93e6 d c9
93e6 93e6 s         RET
93e7 93e7 d d600
93e7 93e7 s         SUB     0               ; Division support routine
93e9 93e9 d 6f
93e9 93e9 s         LD      L,A
93ea 93ea d 7c
93ea 93ea s         LD      A,H
93eb 93eb d de00
93eb 93eb s         SBC     A,0
93ed 93ed d 67
93ed 93ed s         LD      H,A
93ee 93ee d 78
93ee 93ee s         LD      A,B
93ef 93ef d de00
93ef 93ef s         SBC     A,0
93f1 93f1 d 47
93f1 93f1 s         LD      B,A
93f2 93f2 d 3e00
93f2 93f2 s         LD      A,0
93f4 93f4 d c9
93f4 93f4 s         RET
93f5 93f5 d 000000
93f5 93f5 s         .BYTE   0,0,0                   ; Random number seed table used by RND
93f8 93f8 d 354aca99
93f8 93f8 s         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
93fc 93fc d 391c7698
93fc 93fc s         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
9400 9400 d 2295b398
9400 9400 s         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
9404 9404 d 0add4798
9404 9404 s         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
9408 9408 d 53d19999
9408 9408 s         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
940c 940c d 0a1a9f98
940c 940c s         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
9410 9410 d 65bccd98
9410 9410 s         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
9414 9414 d d6773e98
9414 9414 s         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
9418 9418 d 52c74f80
9418 9418 s         .BYTE   052H,0C7H,04FH,080H     ; Last random number
941c 941c d db00
941c 941c s         IN      A,(0)           ; INP (x) skeleton
941e 941e d c9
941e 941e s         RET
941f 941f d 01
941f 941f s         .BYTE   1               ; POS (x) number (1)
9420 9420 d ff
9420 9420 s         .BYTE   255             ; Terminal width (255 = no auto CRLF)
9421 9421 d 1c
9421 9421 s         .BYTE   28              ; Width for commas (3 columns)
9422 9422 d 00
9422 9422 s         .BYTE   0               ; No nulls after input bytes
9423 9423 d 00
9423 9423 s         .BYTE   0               ; Output enabled (^O off)
9424 9424 d 1400
9424 9424 s         .WORD   20              ; Initial lines counter
9426 9426 d 1400
9426 9426 s         .WORD   20              ; Initial lines number
9428 9428 d 0000
9428 9428 s         .WORD   0               ; Array load/save check sum
942a 942a d 00
942a 942a s         .BYTE   0               ; Break not by NMI
942b 942b d 00
942b 942b s         .BYTE   0               ; Break flag
942c 942c d c3f296
942c 942c s         JP      TTYLIN          ; Input reflection (set to TTY)
942f 942f d c30000
942f 942f s         JP      $0000           ; POINT reflection unused
9432 9432 d c30000
9432 9432 s         JP      $0000           ; SET reflection
9435 9435 d c30000
9435 9435 s         JP      $0000          	; RESET reflection
9438 9438 d a2b1
9438 9438 s         .WORD   STLOOK          ; Temp string space
943a 943a d feff
943a 943a s         .WORD   -2              ; Current line number (cold)
943c 943c d 3fb1
943c 943c s         .WORD   PROGST+1        ; Start of program text
943e 943e s INITBE:                         
943e 943e s 
943e 943e s ; END OF INITIALISATION TABLE ---------------------------------------------------
943e 943e s 
943e 943e d 204572726f7200
943e 943e s ERRMSG: .BYTE   " Error",0
9445 9445 d 20696e2000
9445 9445 s INMSG:  .BYTE   " in ",0
944a 944a s ZERBYT  .EQU    $-1             ; A zero byte
944a 944a d 4f6b0d0a0000
944a 944a s OKMSG:  .BYTE   "Ok",CR,LF,0,0
9450 9450 d 427265616b00
9450 9450 s BRKMSG: .BYTE   "Break",0
9456 9456 s 
9456 9456 d 210400
9456 9456 s BAKSTK: LD      HL,4            ; Look for "FOR" block with
9459 9459 d 39
9459 9459 s         ADD     HL,SP           ; same index as specified
945a 945a d 7e
945a 945a s LOKFOR: LD      A,(HL)          ; Get block ID
945b 945b d 23
945b 945b s         INC     HL              ; Point to index address
945c 945c d fe81
945c 945c s         CP      ZFOR            ; Is it a "FOR" token
945e 945e d c0
945e 945e s         RET     NZ              ; No - exit
945f 945f d 4e
945f 945f s         LD      C,(HL)          ; BC = Address of "FOR" index
9460 9460 d 23
9460 9460 s         INC     HL
9461 9461 d 46
9461 9461 s         LD      B,(HL)
9462 9462 d 23
9462 9462 s         INC     HL              ; Point to sign of STEP
9463 9463 d e5
9463 9463 s         PUSH    HL              ; Save pointer to sign
9464 9464 d 69
9464 9464 s         LD      L,C             ; HL = address of "FOR" index
9465 9465 d 60
9465 9465 s         LD      H,B
9466 9466 d 7a
9466 9466 s         LD      A,D             ; See if an index was specified
9467 9467 d b3
9467 9467 s         OR      E               ; DE = 0 if no index specified
9468 9468 d eb
9468 9468 s         EX      DE,HL           ; Specified index into HL
9469 9469 d ca7094
9469 9469 s         JP      Z,INDFND        ; Skip if no index given
946c 946c d eb
946c 946c s         EX      DE,HL           ; Index back into DE
946d 946d d cd7597
946d 946d s         CALL    CPDEHL          ; Compare index with one given
9470 9470 d 010d00
9470 9470 s INDFND: LD      BC,16-3         ; Offset to next block
9473 9473 d e1
9473 9473 s         POP     HL              ; Restore pointer to sign
9474 9474 d c8
9474 9474 s         RET     Z               ; Return if block found
9475 9475 d 09
9475 9475 s         ADD     HL,BC           ; Point to next block
9476 9476 d c35a94
9476 9476 s         JP      LOKFOR          ; Keep on looking
9479 9479 s 
9479 9479 d cd9394
9479 9479 s MOVUP:  CALL    ENFMEM          ; See if enough memory
947c 947c d c5
947c 947c s MOVSTR: PUSH    BC              ; Save end of source
947d 947d d e3
947d 947d s         EX      (SP),HL         ; Swap source and dest" end
947e 947e d c1
947e 947e s         POP     BC              ; Get end of destination
947f 947f d cd7597
947f 947f s MOVLP:  CALL    CPDEHL          ; See if list moved
9482 9482 d 7e
9482 9482 s         LD      A,(HL)          ; Get byte
9483 9483 d 02
9483 9483 s         LD      (BC),A          ; Move it
9484 9484 d c8
9484 9484 s         RET     Z               ; Exit if all done
9485 9485 d 0b
9485 9485 s         DEC     BC              ; Next byte to move to
9486 9486 d 2b
9486 9486 s         DEC     HL              ; Next byte to move
9487 9487 d c37f94
9487 9487 s         JP      MOVLP           ; Loop until all bytes moved
948a 948a s 
948a 948a d e5
948a 948a s CHKSTK: PUSH    HL              ; Save code string address
948b 948b d 2a1fb1
948b 948b s         LD      HL,(ARREND)     ; Lowest free memory
948e 948e d 0600
948e 948e s         LD      B,0             ; BC = Number of levels to test
9490 9490 d 09
9490 9490 s         ADD     HL,BC           ; 2 Bytes for each level
9491 9491 d 09
9491 9491 s         ADD     HL,BC
9492 9492 d 3e
9492 9492 s         .BYTE   3EH             ; Skip "PUSH HL"
9493 9493 d e5
9493 9493 s ENFMEM: PUSH    HL              ; Save code string address
9494 9494 d 3ed0
9494 9494 s         LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
9496 9496 d 95
9496 9496 s         SUB     L
9497 9497 d 6f
9497 9497 s         LD      L,A
9498 9498 d 3eff
9498 9498 s         LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
949a 949a d 9c
949a 949a s         SBC     A,H
949b 949b d daa294
949b 949b s         JP      C,OMERR         ; Not enough - ?OM Error
949e 949e d 67
949e 949e s         LD      H,A
949f 949f d 39
949f 949f s         ADD     HL,SP           ; Test if stack is overflowed
94a0 94a0 d e1
94a0 94a0 s         POP     HL              ; Restore code string address
94a1 94a1 d d8
94a1 94a1 s         RET     C               ; Return if enough mmory
94a2 94a2 d 1e0c
94a2 94a2 s OMERR:  LD      E,OM            ; ?OM Error
94a4 94a4 d c3c194
94a4 94a4 s         JP      ERROR
94a7 94a7 s 
94a7 94a7 d 2a0eb1
94a7 94a7 s DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
94aa 94aa d 22a1b0
94aa 94aa s         LD      (LINEAT),HL     ; Save as current line
94ad 94ad d 1e02
94ad 94ad s SNERR:  LD      E,SN            ; ?SN Error
94af 94af d 01
94af 94af s         .BYTE   01H             ; Skip "LD E,DZ"
94b0 94b0 d 1e14
94b0 94b0 s DZERR:  LD      E,DZ            ; ?/0 Error
94b2 94b2 d 01
94b2 94b2 s         .BYTE   01H             ; Skip "LD E,NF"
94b3 94b3 d 1e00
94b3 94b3 s NFERR:  LD      E,NF            ; ?NF Error
94b5 94b5 d 01
94b5 94b5 s         .BYTE   01H             ; Skip "LD E,DD"
94b6 94b6 d 1e12
94b6 94b6 s DDERR:  LD      E,DD            ; ?DD Error
94b8 94b8 d 01
94b8 94b8 s         .BYTE   01H             ; Skip "LD E,UF"
94b9 94b9 d 1e22
94b9 94b9 s UFERR:  LD      E,UF            ; ?UF Error
94bb 94bb d 01
94bb 94bb s         .BYTE   01H             ; Skip "LD E,OV
94bc 94bc d 1e0a
94bc 94bc s OVERR:  LD      E,OV            ; ?OV Error
94be 94be d 01
94be 94be s         .BYTE   01H             ; Skip "LD E,TM"
94bf 94bf d 1e18
94bf 94bf s TMERR:  LD      E,TM            ; ?TM Error
94c1 94c1 s 
94c1 94c1 d cddf95
94c1 94c1 s ERROR:  CALL    CLREG           ; Clear registers and stack
94c4 94c4 d 328ab0
94c4 94c4 s         LD      (CTLOFG),A      ; Enable output (A is 0)
94c7 94c7 d cda39b
94c7 94c7 s         CALL    STTLIN          ; Start new line
94ca 94ca d 21b493
94ca 94ca s         LD      HL,ERRORS       ; Point to error codes
94cd 94cd d 57
94cd 94cd s         LD      D,A             ; D = 0 (A is 0)
94ce 94ce d 3e3f
94ce 94ce s         LD      A,'?'
94d0 94d0 d cd8697
94d0 94d0 s         CALL    OUTC            ; Output '?'
94d3 94d3 d 19
94d3 94d3 s         ADD     HL,DE           ; Offset to correct error code
94d4 94d4 d 7e
94d4 94d4 s         LD      A,(HL)          ; First character
94d5 94d5 d cd8697
94d5 94d5 s         CALL    OUTC            ; Output it
94d8 94d8 d cd0599
94d8 94d8 s         CALL    GETCHR          ; Get next character
94db 94db d cd8697
94db 94db s         CALL    OUTC            ; Output it
94de 94de d 213e94
94de 94de s         LD      HL,ERRMSG       ; "Error" message
94e1 94e1 d cd4ea2
94e1 94e1 s ERRIN:  CALL    PRS             ; Output message
94e4 94e4 d 2aa1b0
94e4 94e4 s         LD      HL,(LINEAT)     ; Get line of error
94e7 94e7 d 11feff
94e7 94e7 s         LD      DE,-2           ; Cold start error if -2
94ea 94ea d cd7597
94ea 94ea s         CALL    CPDEHL          ; See if cold start error
94ed 94ed d ca1191
94ed 94ed s         JP      Z,CSTART        ; Cold start error - Restart
94f0 94f0 d 7c
94f0 94f0 s         LD      A,H             ; Was it a direct error?
94f1 94f1 d a5
94f1 94f1 s         AND     L               ; Line = -1 if direct error
94f2 94f2 d 3c
94f2 94f2 s         INC     A
94f3 94f3 d c4e9a8
94f3 94f3 s         CALL    NZ,LINEIN       ; No - output line of error
94f6 94f6 d 3e
94f6 94f6 s         .BYTE   3EH             ; Skip "POP BC"
94f7 94f7 d c1
94f7 94f7 s POPNOK: POP     BC              ; Drop address in input buffer
94f8 94f8 s 
94f8 94f8 d af
94f8 94f8 s PRNTOK: XOR     A               ; Output "Ok" and get command
94f9 94f9 d 328ab0
94f9 94f9 s         LD      (CTLOFG),A      ; Enable output
94fc 94fc d cda39b
94fc 94fc s         CALL    STTLIN          ; Start new line
94ff 94ff d 214a94
94ff 94ff s         LD      HL,OKMSG        ; "Ok" message
9502 9502 d cd4ea2
9502 9502 s         CALL    PRS             ; Output "Ok"
9505 9505 d 21ffff
9505 9505 s GETCMD: LD      HL,-1           ; Flag direct mode
9508 9508 d 22a1b0
9508 9508 s         LD      (LINEAT),HL     ; Save as current line
950b 950b d cdf296
950b 950b s         CALL    GETLIN          ; Get an input line
950e 950e d da0595
950e 950e s         JP      C,GETCMD        ; Get line again if break
9511 9511 d cd0599
9511 9511 s         CALL    GETCHR          ; Get first character
9514 9514 d 3c
9514 9514 s         INC     A               ; Test if end of line
9515 9515 d 3d
9515 9515 s         DEC     A               ; Without affecting Carry
9516 9516 d ca0595
9516 9516 s         JP      Z,GETCMD        ; Nothing entered - Get another
9519 9519 d f5
9519 9519 s         PUSH    AF              ; Save Carry status
951a 951a d cdd499
951a 951a s         CALL    ATOH            ; Get line number into DE
951d 951d d d5
951d 951d s         PUSH    DE              ; Save line number
951e 951e d cd0996
951e 951e s         CALL    CRUNCH          ; Tokenise rest of line
9521 9521 d 47
9521 9521 s         LD      B,A             ; Length of tokenised line
9522 9522 d d1
9522 9522 s         POP     DE              ; Restore line number
9523 9523 d f1
9523 9523 s         POP     AF              ; Restore Carry
9524 9524 d d2e598
9524 9524 s         JP      NC,EXCUTE       ; No line number - Direct mode
9527 9527 d d5
9527 9527 s         PUSH    DE              ; Save line number
9528 9528 d c5
9528 9528 s         PUSH    BC              ; Save length of tokenised line
9529 9529 d af
9529 9529 s         XOR     A
952a 952a d 3211b1
952a 952a s         LD      (LSTBIN),A      ; Clear last byte input
952d 952d d cd0599
952d 952d s         CALL    GETCHR          ; Get next character
9530 9530 d b7
9530 9530 s         OR      A               ; Set flags
9531 9531 d f5
9531 9531 s         PUSH    AF              ; And save them
9532 9532 d cd9995
9532 9532 s         CALL    SRCHLN          ; Search for line number in DE
9535 9535 d da3e95
9535 9535 s         JP      C,LINFND        ; Jump if line found
9538 9538 d f1
9538 9538 s         POP     AF              ; Get status
9539 9539 d f5
9539 9539 s         PUSH    AF              ; And re-save
953a 953a d ca759a
953a 953a s         JP      Z,ULERR         ; Nothing after number - Error
953d 953d d b7
953d 953d s         OR      A               ; Clear Carry
953e 953e d c5
953e 953e s LINFND: PUSH    BC              ; Save address of line in prog
953f 953f d d25595
953f 953f s         JP      NC,INEWLN       ; Line not found - Insert new
9542 9542 d eb
9542 9542 s         EX      DE,HL           ; Next line address in DE
9543 9543 d 2a1bb1
9543 9543 s         LD      HL,(PROGND)     ; End of program
9546 9546 d 1a
9546 9546 s SFTPRG: LD      A,(DE)          ; Shift rest of program down
9547 9547 d 02
9547 9547 s         LD      (BC),A
9548 9548 d 03
9548 9548 s         INC     BC              ; Next destination
9549 9549 d 13
9549 9549 s         INC     DE              ; Next source
954a 954a d cd7597
954a 954a s         CALL    CPDEHL          ; All done?
954d 954d d c24695
954d 954d s         JP      NZ,SFTPRG       ; More to do
9550 9550 d 60
9550 9550 s         LD      H,B             ; HL - New end of program
9551 9551 d 69
9551 9551 s         LD      L,C
9552 9552 d 221bb1
9552 9552 s         LD      (PROGND),HL     ; Update end of program
9555 9555 s 
9555 9555 d d1
9555 9555 s INEWLN: POP     DE              ; Get address of line,
9556 9556 d f1
9556 9556 s         POP     AF              ; Get status
9557 9557 d ca7c95
9557 9557 s         JP      Z,SETPTR        ; No text - Set up pointers
955a 955a d 2a1bb1
955a 955a s         LD      HL,(PROGND)     ; Get end of program
955d 955d d e3
955d 955d s         EX      (SP),HL         ; Get length of input line
955e 955e d c1
955e 955e s         POP     BC              ; End of program to BC
955f 955f d 09
955f 955f s         ADD     HL,BC           ; Find new end
9560 9560 d e5
9560 9560 s         PUSH    HL              ; Save new end
9561 9561 d cd7994
9561 9561 s         CALL    MOVUP           ; Make space for line
9564 9564 d e1
9564 9564 s         POP     HL              ; Restore new end
9565 9565 d 221bb1
9565 9565 s         LD      (PROGND),HL     ; Update end of program pointer
9568 9568 d eb
9568 9568 s         EX      DE,HL           ; Get line to move up in HL
9569 9569 d 74
9569 9569 s         LD      (HL),H          ; Save MSB
956a 956a d d1
956a 956a s         POP     DE              ; Get new line number
956b 956b d 23
956b 956b s         INC     HL              ; Skip pointer
956c 956c d 23
956c 956c s         INC     HL
956d 956d d 73
956d 956d s         LD      (HL),E          ; Save LSB of line number
956e 956e d 23
956e 956e s         INC     HL
956f 956f d 72
956f 956f s         LD      (HL),D          ; Save MSB of line number
9570 9570 d 23
9570 9570 s         INC     HL              ; To first byte in line
9571 9571 d 11a6b0
9571 9571 s         LD      DE,BUFFER       ; Copy buffer to program
9574 9574 d 1a
9574 9574 s MOVBUF: LD      A,(DE)          ; Get source
9575 9575 d 77
9575 9575 s         LD      (HL),A          ; Save destinations
9576 9576 d 23
9576 9576 s         INC     HL              ; Next source
9577 9577 d 13
9577 9577 s         INC     DE              ; Next destination
9578 9578 d b7
9578 9578 s         OR      A               ; Done?
9579 9579 d c27495
9579 9579 s         JP      NZ,MOVBUF       ; No - Repeat
957c 957c d cdc595
957c 957c s SETPTR: CALL    RUNFST          ; Set line pointers
957f 957f d 23
957f 957f s         INC     HL              ; To LSB of pointer
9580 9580 d eb
9580 9580 s         EX      DE,HL           ; Address to DE
9581 9581 d 62
9581 9581 s PTRLP:  LD      H,D             ; Address to HL
9582 9582 d 6b
9582 9582 s         LD      L,E
9583 9583 d 7e
9583 9583 s         LD      A,(HL)          ; Get LSB of pointer
9584 9584 d 23
9584 9584 s         INC     HL              ; To MSB of pointer
9585 9585 d b6
9585 9585 s         OR      (HL)            ; Compare with MSB pointer
9586 9586 d ca0595
9586 9586 s         JP      Z,GETCMD        ; Get command line if end
9589 9589 d 23
9589 9589 s         INC     HL              ; To LSB of line number
958a 958a d 23
958a 958a s         INC     HL              ; Skip line number
958b 958b d 23
958b 958b s         INC     HL              ; Point to first byte in line
958c 958c d af
958c 958c s         XOR     A               ; Looking for 00 byte
958d 958d d be
958d 958d s FNDEND: CP      (HL)            ; Found end of line?
958e 958e d 23
958e 958e s         INC     HL              ; Move to next byte
958f 958f d c28d95
958f 958f s         JP      NZ,FNDEND       ; No - Keep looking
9592 9592 d eb
9592 9592 s         EX      DE,HL           ; Next line address to HL
9593 9593 d 73
9593 9593 s         LD      (HL),E          ; Save LSB of pointer
9594 9594 d 23
9594 9594 s         INC     HL
9595 9595 d 72
9595 9595 s         LD      (HL),D          ; Save MSB of pointer
9596 9596 d c38195
9596 9596 s         JP      PTRLP           ; Do next line
9599 9599 s 
9599 9599 d 2aa3b0
9599 9599 s SRCHLN: LD      HL,(BASTXT)     ; Start of program text
959c 959c d 44
959c 959c s SRCHLP: LD      B,H             ; BC = Address to look at
959d 959d d 4d
959d 959d s         LD      C,L
959e 959e d 7e
959e 959e s         LD      A,(HL)          ; Get address of next line
959f 959f d 23
959f 959f s         INC     HL
95a0 95a0 d b6
95a0 95a0 s         OR      (HL)            ; End of program found?
95a1 95a1 d 2b
95a1 95a1 s         DEC     HL
95a2 95a2 d c8
95a2 95a2 s         RET     Z               ; Yes - Line not found
95a3 95a3 d 23
95a3 95a3 s         INC     HL
95a4 95a4 d 23
95a4 95a4 s         INC     HL
95a5 95a5 d 7e
95a5 95a5 s         LD      A,(HL)          ; Get LSB of line number
95a6 95a6 d 23
95a6 95a6 s         INC     HL
95a7 95a7 d 66
95a7 95a7 s         LD      H,(HL)          ; Get MSB of line number
95a8 95a8 d 6f
95a8 95a8 s         LD      L,A
95a9 95a9 d cd7597
95a9 95a9 s         CALL    CPDEHL          ; Compare with line in DE
95ac 95ac d 60
95ac 95ac s         LD      H,B             ; HL = Start of this line
95ad 95ad d 69
95ad 95ad s         LD      L,C
95ae 95ae d 7e
95ae 95ae s         LD      A,(HL)          ; Get LSB of next line address
95af 95af d 23
95af 95af s         INC     HL
95b0 95b0 d 66
95b0 95b0 s         LD      H,(HL)          ; Get MSB of next line address
95b1 95b1 d 6f
95b1 95b1 s         LD      L,A             ; Next line to HL
95b2 95b2 d 3f
95b2 95b2 s         CCF
95b3 95b3 d c8
95b3 95b3 s         RET     Z               ; Lines found - Exit
95b4 95b4 d 3f
95b4 95b4 s         CCF
95b5 95b5 d d0
95b5 95b5 s         RET     NC              ; Line not found,at line after
95b6 95b6 d c39c95
95b6 95b6 s         JP      SRCHLP          ; Keep looking
95b9 95b9 s 
95b9 95b9 d c0
95b9 95b9 s NEW:    RET     NZ              ; Return if any more on line
95ba 95ba d 2aa3b0
95ba 95ba s CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
95bd 95bd d af
95bd 95bd s         XOR     A               ; Set program area to empty
95be 95be d 77
95be 95be s         LD      (HL),A          ; Save LSB = 00
95bf 95bf d 23
95bf 95bf s         INC     HL
95c0 95c0 d 77
95c0 95c0 s         LD      (HL),A          ; Save MSB = 00
95c1 95c1 d 23
95c1 95c1 s         INC     HL
95c2 95c2 d 221bb1
95c2 95c2 s         LD      (PROGND),HL     ; Set program end
95c5 95c5 s 
95c5 95c5 d 2aa3b0
95c5 95c5 s RUNFST: LD      HL,(BASTXT)     ; Clear all variables
95c8 95c8 d 2b
95c8 95c8 s         DEC     HL
95c9 95c9 s 
95c9 95c9 d 2213b1
95c9 95c9 s INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
95cc 95cc d 2af4b0
95cc 95cc s         LD      HL,(LSTRAM)     ; Get end of RAM
95cf 95cf d 2208b1
95cf 95cf s         LD      (STRBOT),HL     ; Clear string space
95d2 95d2 d af
95d2 95d2 s         XOR     A
95d3 95d3 d cd1599
95d3 95d3 s         CALL    RESTOR          ; Reset DATA pointers
95d6 95d6 d 2a1bb1
95d6 95d6 s         LD      HL,(PROGND)     ; Get end of program
95d9 95d9 d 221db1
95d9 95d9 s         LD      (VAREND),HL     ; Clear variables
95dc 95dc d 221fb1
95dc 95dc s         LD      (ARREND),HL     ; Clear arrays
95df 95df s 
95df 95df d c1
95df 95df s CLREG:  POP     BC              ; Save return address
95e0 95e0 d 2a9fb0
95e0 95e0 s         LD      HL,(STRSPC)     ; Get end of working RAN
95e3 95e3 d f9
95e3 95e3 s         LD      SP,HL           ; Set stack
95e4 95e4 d 21f8b0
95e4 95e4 s         LD      HL,TMSTPL       ; Temporary string pool
95e7 95e7 d 22f6b0
95e7 95e7 s         LD      (TMSTPT),HL     ; Reset temporary string ptr
95ea 95ea d af
95ea 95ea s         XOR     A               ; A = 00
95eb 95eb d 6f
95eb 95eb s         LD      L,A             ; HL = 0000
95ec 95ec d 67
95ec 95ec s         LD      H,A
95ed 95ed d 2219b1
95ed 95ed s         LD      (CONTAD),HL     ; No CONTinue
95f0 95f0 d 3210b1
95f0 95f0 s         LD      (FORFLG),A      ; Clear FOR flag
95f3 95f3 d 2223b1
95f3 95f3 s         LD      (FNRGNM),HL     ; Clear FN argument
95f6 95f6 d e5
95f6 95f6 s         PUSH    HL              ; HL = 0000
95f7 95f7 d c5
95f7 95f7 s         PUSH    BC              ; Put back return
95f8 95f8 d 2a13b1
95f8 95f8 s DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
95fb 95fb d c9
95fb 95fb s         RET                     ; Return to execution driver
95fc 95fc s 
95fc 95fc d 3e3f
95fc 95fc s PROMPT: LD      A,'?'           ; '?'
95fe 95fe d cd8697
95fe 95fe s         CALL    OUTC            ; Output character
9601 9601 d 3e20
9601 9601 s         LD      A,' '           ; Space
9603 9603 d cd8697
9603 9603 s         CALL    OUTC            ; Output character
9606 9606 d c393b0
9606 9606 s         JP      RINPUT          ; Get input line
9609 9609 s 
9609 9609 d af
9609 9609 s CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
960a 960a d 32f3b0
960a 960a s         LD      (DATFLG),A      ; Reset literal flag
960d 960d d 0e05
960d 960d s         LD      C,2+3           ; 2 byte number and 3 nulls
960f 960f d 11a6b0
960f 960f s         LD      DE,BUFFER       ; Start of input buffer
9612 9612 d 7e
9612 9612 s CRNCLP: LD      A,(HL)          ; Get byte
9613 9613 d fe20
9613 9613 s         CP      ' '             ; Is it a space?
9615 9615 d ca9196
9615 9615 s         JP      Z,MOVDIR        ; Yes - Copy direct
9618 9618 d 47
9618 9618 s         LD      B,A             ; Save character
9619 9619 d fe22
9619 9619 s         CP      '"'             ; Is it a quote?
961b 961b d cab196
961b 961b s         JP      Z,CPYLIT        ; Yes - Copy literal string
961e 961e d b7
961e 961e s         OR      A               ; Is it end of buffer?
961f 961f d cab896
961f 961f s         JP      Z,ENDBUF        ; Yes - End buffer
9622 9622 d 3af3b0
9622 9622 s         LD      A,(DATFLG)      ; Get data type
9625 9625 d b7
9625 9625 s         OR      A               ; Literal?
9626 9626 d 7e
9626 9626 s         LD      A,(HL)          ; Get byte to copy
9627 9627 d c29196
9627 9627 s         JP      NZ,MOVDIR       ; Literal - Copy direct
962a 962a d fe3f
962a 962a s         CP      '?'             ; Is it '?' short for PRINT
962c 962c d 3e9e
962c 962c s         LD      A,ZPRINT        ; "PRINT" token
962e 962e d ca9196
962e 962e s         JP      Z,MOVDIR        ; Yes - replace it
9631 9631 d 7e
9631 9631 s         LD      A,(HL)          ; Get byte again
9632 9632 d fe30
9632 9632 s         CP      '0'             ; Is it less than '0'
9634 9634 d da3c96
9634 9634 s         JP      C,FNDWRD        ; Yes - Look for reserved words
9637 9637 d fe3c
9637 9637 s         CP      60; ";"+1           ; Is it "0123456789:;" ?
9639 9639 d da9196
9639 9639 s         JP      C,MOVDIR        ; Yes - copy it direct
963c 963c d d5
963c 963c s FNDWRD: PUSH    DE              ; Look for reserved words
963d 963d d 113592
963d 963d s         LD      DE,WORDS-1      ; Point to table
9640 9640 d c5
9640 9640 s         PUSH    BC              ; Save count
9641 9641 d 018d96
9641 9641 s         LD      BC,RETNAD       ; Where to return to
9644 9644 d c5
9644 9644 s         PUSH    BC              ; Save return address
9645 9645 d 067f
9645 9645 s         LD      B,ZEND-1        ; First token value -1
9647 9647 d 7e
9647 9647 s         LD      A,(HL)          ; Get byte
9648 9648 d fe61
9648 9648 s         CP      'a'             ; Less than 'a' ?
964a 964a d da5596
964a 964a s         JP      C,SEARCH        ; Yes - search for words
964d 964d d fe7b
964d 964d s         CP      'z'+1           ; Greater than 'z' ?
964f 964f d d25596
964f 964f s         JP      NC,SEARCH       ; Yes - search for words
9652 9652 d e65f
9652 9652 s         AND     01011111B       ; Force upper case
9654 9654 d 77
9654 9654 s         LD      (HL),A          ; Replace byte
9655 9655 d 4e
9655 9655 s SEARCH: LD      C,(HL)          ; Search for a word
9656 9656 d eb
9656 9656 s         EX      DE,HL
9657 9657 d 23
9657 9657 s GETNXT: INC     HL              ; Get next reserved word
9658 9658 d b6
9658 9658 s         OR      (HL)            ; Start of word?
9659 9659 d f25796
9659 9659 s         JP      P,GETNXT        ; No - move on
965c 965c d 04
965c 965c s         INC     B               ; Increment token value
965d 965d d 7e
965d 965d s         LD      A, (HL)         ; Get byte from table
965e 965e d e67f
965e 965e s         AND     01111111B       ; Strip bit 7
9660 9660 d c8
9660 9660 s         RET     Z               ; Return if end of list
9661 9661 d b9
9661 9661 s         CP      C               ; Same character as in buffer?
9662 9662 d c25796
9662 9662 s         JP      NZ,GETNXT       ; No - get next word
9665 9665 d eb
9665 9665 s         EX      DE,HL
9666 9666 d e5
9666 9666 s         PUSH    HL              ; Save start of word
9667 9667 s 
9667 9667 d 13
9667 9667 s NXTBYT: INC     DE              ; Look through rest of word
9668 9668 d 1a
9668 9668 s         LD      A,(DE)          ; Get byte from table
9669 9669 d b7
9669 9669 s         OR      A               ; End of word ?
966a 966a d fa8996
966a 966a s         JP      M,MATCH         ; Yes - Match found
966d 966d d 4f
966d 966d s         LD      C,A             ; Save it
966e 966e d 78
966e 966e s         LD      A,B             ; Get token value
966f 966f d fe88
966f 966f s         CP      ZGOTO           ; Is it "GOTO" token ?
9671 9671 d c27896
9671 9671 s         JP      NZ,NOSPC        ; No - Don't allow spaces
9674 9674 d cd0599
9674 9674 s         CALL    GETCHR          ; Get next character
9677 9677 d 2b
9677 9677 s         DEC     HL              ; Cancel increment from GETCHR
9678 9678 d 23
9678 9678 s NOSPC:  INC     HL              ; Next byte
9679 9679 d 7e
9679 9679 s         LD      A,(HL)          ; Get byte
967a 967a d fe61
967a 967a s         CP      'a'             ; Less than 'a' ?
967c 967c d da8196
967c 967c s         JP      C,NOCHNG        ; Yes - don't change
967f 967f d e65f
967f 967f s         AND     01011111B       ; Make upper case
9681 9681 d b9
9681 9681 s NOCHNG: CP      C               ; Same as in buffer ?
9682 9682 d ca6796
9682 9682 s         JP      Z,NXTBYT        ; Yes - keep testing
9685 9685 d e1
9685 9685 s         POP     HL              ; Get back start of word
9686 9686 d c35596
9686 9686 s         JP      SEARCH          ; Look at next word
9689 9689 s 
9689 9689 d 48
9689 9689 s MATCH:  LD      C,B             ; Word found - Save token value
968a 968a d f1
968a 968a s         POP     AF              ; Throw away return
968b 968b d eb
968b 968b s         EX      DE,HL
968c 968c d c9
968c 968c s         RET                     ; Return to "RETNAD"
968d 968d d eb
968d 968d s RETNAD: EX      DE,HL           ; Get address in string
968e 968e d 79
968e 968e s         LD      A,C             ; Get token value
968f 968f d c1
968f 968f s         POP     BC              ; Restore buffer length
9690 9690 d d1
9690 9690 s         POP     DE              ; Get destination address
9691 9691 d 23
9691 9691 s MOVDIR: INC     HL              ; Next source in buffer
9692 9692 d 12
9692 9692 s         LD      (DE),A          ; Put byte in buffer
9693 9693 d 13
9693 9693 s         INC     DE              ; Move up buffer
9694 9694 d 0c
9694 9694 s         INC     C               ; Increment length of buffer
9695 9695 d d63a
9695 9695 s         SUB     ':'             ; End of statement?
9697 9697 d ca9f96
9697 9697 s         JP      Z,SETLIT        ; Jump if multi-statement line
969a 969a d fe49
969a 969a s         CP      ZDATA-3AH       ; Is it DATA statement ?
969c 969c d c2a296
969c 969c s         JP      NZ,TSTREM       ; No - see if REM
969f 969f d 32f3b0
969f 969f s SETLIT: LD      (DATFLG),A      ; Set literal flag
96a2 96a2 d d654
96a2 96a2 s TSTREM: SUB     ZREM-3AH        ; Is it REM?
96a4 96a4 d c21296
96a4 96a4 s         JP      NZ,CRNCLP       ; No - Leave flag
96a7 96a7 d 47
96a7 96a7 s         LD      B,A             ; Copy rest of buffer
96a8 96a8 d 7e
96a8 96a8 s NXTCHR: LD      A,(HL)          ; Get byte
96a9 96a9 d b7
96a9 96a9 s         OR      A               ; End of line ?
96aa 96aa d cab896
96aa 96aa s         JP      Z,ENDBUF        ; Yes - Terminate buffer
96ad 96ad d b8
96ad 96ad s         CP      B               ; End of statement ?
96ae 96ae d ca9196
96ae 96ae s         JP      Z,MOVDIR        ; Yes - Get next one
96b1 96b1 d 23
96b1 96b1 s CPYLIT: INC     HL              ; Move up source string
96b2 96b2 d 12
96b2 96b2 s         LD      (DE),A          ; Save in destination
96b3 96b3 d 0c
96b3 96b3 s         INC     C               ; Increment length
96b4 96b4 d 13
96b4 96b4 s         INC     DE              ; Move up destination
96b5 96b5 d c3a896
96b5 96b5 s         JP      NXTCHR          ; Repeat
96b8 96b8 s 
96b8 96b8 d 21a5b0
96b8 96b8 s ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
96bb 96bb d 12
96bb 96bb s         LD      (DE),A          ; Mark end of buffer (A = 00)
96bc 96bc d 13
96bc 96bc s         INC     DE
96bd 96bd d 12
96bd 96bd s         LD      (DE),A          ; A = 00
96be 96be d 13
96be 96be s         INC     DE
96bf 96bf d 12
96bf 96bf s         LD      (DE),A          ; A = 00
96c0 96c0 d c9
96c0 96c0 s         RET
96c1 96c1 s 
96c1 96c1 d 3a89b0
96c1 96c1 s DODEL:  LD      A,(NULFLG)      ; Get null flag status
96c4 96c4 d b7
96c4 96c4 s         OR      A               ; Is it zero?
96c5 96c5 d 3e00
96c5 96c5 s         LD      A,0             ; Zero A - Leave flags
96c7 96c7 d 3289b0
96c7 96c7 s         LD      (NULFLG),A      ; Zero null flag
96ca 96ca d c2d596
96ca 96ca s         JP      NZ,ECHDEL       ; Set - Echo it
96cd 96cd d 05
96cd 96cd s         DEC     B               ; Decrement length
96ce 96ce d caf296
96ce 96ce s         JP      Z,GETLIN        ; Get line again if empty
96d1 96d1 d cd8697
96d1 96d1 s         CALL    OUTC            ; Output null character
96d4 96d4 d 3e
96d4 96d4 s         .BYTE   3EH             ; Skip "DEC B"
96d5 96d5 d 05
96d5 96d5 s ECHDEL: DEC     B               ; Count bytes in buffer
96d6 96d6 d 2b
96d6 96d6 s         DEC     HL              ; Back space buffer
96d7 96d7 d cae996
96d7 96d7 s         JP      Z,OTKLN         ; No buffer - Try again
96da 96da d 7e
96da 96da s         LD      A,(HL)          ; Get deleted byte
96db 96db d cd8697
96db 96db s         CALL    OUTC            ; Echo it
96de 96de d c3fb96
96de 96de s         JP      MORINP          ; Get more input
96e1 96e1 s 
96e1 96e1 d 05
96e1 96e1 s DELCHR: DEC     B               ; Count bytes in buffer
96e2 96e2 d 2b
96e2 96e2 s         DEC     HL              ; Back space buffer
96e3 96e3 d cd8697
96e3 96e3 s         CALL    OUTC            ; Output character in A
96e6 96e6 d c2fb96
96e6 96e6 s         JP      NZ,MORINP       ; Not end - Get more
96e9 96e9 d cd8697
96e9 96e9 s OTKLN:  CALL    OUTC            ; Output character in A
96ec 96ec d cdb09b
96ec 96ec s KILIN:  CALL    PRNTCRLF        ; Output CRLF
96ef 96ef d c3f296
96ef 96ef s         JP      TTYLIN          ; Get line again
96f2 96f2 s 
96f2 96f2 s GETLIN:
96f2 96f2 d 21a6b0
96f2 96f2 s TTYLIN: LD      HL,BUFFER       ; Get a line by character
96f5 96f5 d 0601
96f5 96f5 s         LD      B,1             ; Set buffer as empty
96f7 96f7 d af
96f7 96f7 s         XOR     A
96f8 96f8 d 3289b0
96f8 96f8 s         LD      (NULFLG),A      ; Clear null flag
96fb 96fb d cdb097
96fb 96fb s MORINP: CALL    CLOTST          ; Get character and test ^O
96fe 96fe d 4f
96fe 96fe s         LD      C,A             ; Save character in C
96ff 96ff d fe7f
96ff 96ff s         CP      DEL             ; Delete character?
9701 9701 d cac196
9701 9701 s         JP      Z,DODEL         ; Yes - Process it
9704 9704 d 3a89b0
9704 9704 s         LD      A,(NULFLG)      ; Get null flag
9707 9707 d b7
9707 9707 s         OR      A               ; Test null flag status
9708 9708 d ca1497
9708 9708 s         JP      Z,PROCES        ; Reset - Process character
970b 970b d 3e00
970b 970b s         LD      A,0             ; Set a null
970d 970d d cd8697
970d 970d s         CALL    OUTC            ; Output null
9710 9710 d af
9710 9710 s         XOR     A               ; Clear A
9711 9711 d 3289b0
9711 9711 s         LD      (NULFLG),A      ; Reset null flag
9714 9714 d 79
9714 9714 s PROCES: LD      A,C             ; Get character
9715 9715 d fe07
9715 9715 s         CP      CTRLG           ; Bell?
9717 9717 d ca5897
9717 9717 s         JP      Z,PUTCTL        ; Yes - Save it
971a 971a d fe03
971a 971a s         CP      CTRLC           ; Is it control "C"?
971c 971c d ccb09b
971c 971c s         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
971f 971f d 37
971f 971f s         SCF                     ; Flag break
9720 9720 d c8
9720 9720 s         RET     Z               ; Return if control "C"
9721 9721 d fe0d
9721 9721 s         CP      CR              ; Is it enter?
9723 9723 d caab9b
9723 9723 s         JP      Z,ENDINP        ; Yes - Terminate input
9726 9726 d fe15
9726 9726 s         CP      CTRLU           ; Is it control "U"?
9728 9728 d caec96
9728 9728 s         JP      Z,KILIN         ; Yes - Get another line
972b 972b d fe40
972b 972b s         CP      '@'             ; Is it "kill line"?
972d 972d d cae996
972d 972d s         JP      Z,OTKLN         ; Yes - Kill line
9730 9730 d fe5f
9730 9730 s         CP      '_'             ; Is it delete?
9732 9732 d cae196
9732 9732 s         JP      Z,DELCHR        ; Yes - Delete character
9735 9735 d fe08
9735 9735 s         CP      BKSP            ; Is it backspace?
9737 9737 d cae196
9737 9737 s         JP      Z,DELCHR        ; Yes - Delete character
973a 973a d fe12
973a 973a s         CP      CTRLR           ; Is it control "R"?
973c 973c d c25397
973c 973c s         JP      NZ,PUTBUF       ; No - Put in buffer
973f 973f d c5
973f 973f s         PUSH    BC              ; Save buffer length
9740 9740 d d5
9740 9740 s         PUSH    DE              ; Save DE
9741 9741 d e5
9741 9741 s         PUSH    HL              ; Save buffer address
9742 9742 d 3600
9742 9742 s         LD      (HL),0          ; Mark end of buffer
9744 9744 d cd62ad
9744 9744 s         CALL    OUTNCR          ; Output and do CRLF
9747 9747 d 21a6b0
9747 9747 s         LD      HL,BUFFER       ; Point to buffer start
974a 974a d cd4ea2
974a 974a s         CALL    PRS             ; Output buffer
974d 974d d e1
974d 974d s         POP     HL              ; Restore buffer address
974e 974e d d1
974e 974e s         POP     DE              ; Restore DE
974f 974f d c1
974f 974f s         POP     BC              ; Restore buffer length
9750 9750 d c3fb96
9750 9750 s         JP      MORINP          ; Get another character
9753 9753 s 
9753 9753 d fe20
9753 9753 s PUTBUF: CP      ' '             ; Is it a control code?
9755 9755 d dafb96
9755 9755 s         JP      C,MORINP        ; Yes - Ignore
9758 9758 d 78
9758 9758 s PUTCTL: LD      A,B             ; Get number of bytes in buffer
9759 9759 d fe49
9759 9759 s         CP      72+1            ; Test for line overflow
975b 975b d 3e07
975b 975b s         LD      A,CTRLG         ; Set a bell
975d 975d d d26d97
975d 975d s         JP      NC,OUTNBS       ; Ring bell if buffer full
9760 9760 d 79
9760 9760 s         LD      A,C             ; Get character
9761 9761 d 71
9761 9761 s         LD      (HL),C          ; Save in buffer
9762 9762 d 3211b1
9762 9762 s         LD      (LSTBIN),A      ; Save last input byte
9765 9765 d 23
9765 9765 s         INC     HL              ; Move up buffer
9766 9766 d 04
9766 9766 s         INC     B               ; Increment length
9767 9767 d cd8697
9767 9767 s OUTIT:  CALL    OUTC            ; Output the character entered
976a 976a d c3fb96
976a 976a s         JP      MORINP          ; Get another character
976d 976d s 
976d 976d d cd8697
976d 976d s OUTNBS: CALL    OUTC            ; Output bell and back over it
9770 9770 d 3e08
9770 9770 s         LD      A,BKSP          ; Set back space
9772 9772 d c36797
9772 9772 s         JP      OUTIT           ; Output it and get more
9775 9775 s 
9775 9775 d 7c
9775 9775 s CPDEHL: LD      A,H             ; Get H
9776 9776 d 92
9776 9776 s         SUB     D               ; Compare with D
9777 9777 d c0
9777 9777 s         RET     NZ              ; Different - Exit
9778 9778 d 7d
9778 9778 s         LD      A,L             ; Get L
9779 9779 d 93
9779 9779 s         SUB     E               ; Compare with E
977a 977a d c9
977a 977a s         RET                     ; Return status
977b 977b s 
977b 977b d 7e
977b 977b s CHKSYN: LD      A,(HL)          ; Check syntax of character
977c 977c d e3
977c 977c s         EX      (SP),HL         ; Address of test byte
977d 977d d be
977d 977d s         CP      (HL)            ; Same as in code string?
977e 977e d 23
977e 977e s         INC     HL              ; Return address
977f 977f d e3
977f 977f s         EX      (SP),HL         ; Put it back
9780 9780 d ca0599
9780 9780 s         JP      Z,GETCHR        ; Yes - Get next character
9783 9783 d c3ad94
9783 9783 s         JP      SNERR           ; Different - ?SN Error
9786 9786 s 
9786 9786 d f5
9786 9786 s OUTC:   PUSH    AF              ; Save character
9787 9787 d 3a8ab0
9787 9787 s         LD      A,(CTLOFG)      ; Get control "O" flag
978a 978a d b7
978a 978a s         OR      A               ; Is it set?
978b 978b d c283a2
978b 978b s         JP      NZ,POPAF        ; Yes - don't output
978e 978e d f1
978e 978e s         POP     AF              ; Restore character
978f 978f d c5
978f 978f s         PUSH    BC              ; Save buffer length
9790 9790 d f5
9790 9790 s         PUSH    AF              ; Save character
9791 9791 d fe20
9791 9791 s         CP      ' '             ; Is it a control code?
9793 9793 d daaa97
9793 9793 s         JP      C,DINPOS        ; Yes - Don't INC POS(X)
9796 9796 d 3a87b0
9796 9796 s         LD      A,(LWIDTH)      ; Get line width
9799 9799 d 47
9799 9799 s         LD      B,A             ; To B
979a 979a d 3af0b0
979a 979a s         LD      A,(CURPOS)      ; Get cursor position
979d 979d d 04
979d 979d s         INC     B               ; Width 255?
979e 979e d caa697
979e 979e s         JP      Z,INCLEN        ; Yes - No width limit
97a1 97a1 d 05
97a1 97a1 s         DEC     B               ; Restore width
97a2 97a2 d b8
97a2 97a2 s         CP      B               ; At end of line?
97a3 97a3 d ccb09b
97a3 97a3 s         CALL    Z,PRNTCRLF      ; Yes - output CRLF
97a6 97a6 d 3c
97a6 97a6 s INCLEN: INC     A               ; Move on one character
97a7 97a7 d 32f0b0
97a7 97a7 s         LD      (CURPOS),A      ; Save new position
97aa 97aa d f1
97aa 97aa s DINPOS: POP     AF              ; Restore character
97ab 97ab d c1
97ab 97ab s         POP     BC              ; Restore buffer length
97ac 97ac d cd4bad
97ac 97ac s         CALL    MONOUT          ; Send it
97af 97af d c9
97af 97af s         RET
97b0 97b0 s 
97b0 97b0 d cd0dac
97b0 97b0 s CLOTST: CALL    GETINP          ; Get input character
97b3 97b3 d e67f
97b3 97b3 s         AND     01111111B       ; Strip bit 7
97b5 97b5 d fe0f
97b5 97b5 s         CP      CTRLO           ; Is it control "O"?
97b7 97b7 d c0
97b7 97b7 s         RET     NZ              ; No don't flip flag
97b8 97b8 d 3a8ab0
97b8 97b8 s         LD      A,(CTLOFG)      ; Get flag
97bb 97bb d 2f
97bb 97bb s         CPL                     ; Flip it
97bc 97bc d 328ab0
97bc 97bc s         LD      (CTLOFG),A      ; Put it back
97bf 97bf d af
97bf 97bf s         XOR     A               ; Null character
97c0 97c0 d c9
97c0 97c0 s         RET
97c1 97c1 s 
97c1 97c1 d cdd499
97c1 97c1 s LIST:   CALL    ATOH            ; ASCII number to DE
97c4 97c4 d c0
97c4 97c4 s         RET     NZ              ; Return if anything extra
97c5 97c5 d c1
97c5 97c5 s         POP     BC              ; Rubbish - Not needed
97c6 97c6 d cd9995
97c6 97c6 s         CALL    SRCHLN          ; Search for line number in DE
97c9 97c9 d c5
97c9 97c9 s         PUSH    BC              ; Save address of line
97ca 97ca d cd1798
97ca 97ca s         CALL    SETLIN          ; Set up lines counter
97cd 97cd d e1
97cd 97cd s LISTLP: POP     HL              ; Restore address of line
97ce 97ce d 4e
97ce 97ce s         LD      C,(HL)          ; Get LSB of next line
97cf 97cf d 23
97cf 97cf s         INC     HL
97d0 97d0 d 46
97d0 97d0 s         LD      B,(HL)          ; Get MSB of next line
97d1 97d1 d 23
97d1 97d1 s         INC     HL
97d2 97d2 d 78
97d2 97d2 s         LD      A,B             ; BC = 0 (End of program)?
97d3 97d3 d b1
97d3 97d3 s         OR      C
97d4 97d4 d caf894
97d4 97d4 s         JP      Z,PRNTOK        ; Yes - Go to command mode
97d7 97d7 d cd2098
97d7 97d7 s         CALL    COUNT           ; Count lines
97da 97da d cd3099
97da 97da s         CALL    TSTBRK          ; Test for break key
97dd 97dd d c5
97dd 97dd s         PUSH    BC              ; Save address of next line
97de 97de d cdb09b
97de 97de s         CALL    PRNTCRLF        ; Output CRLF
97e1 97e1 d 5e
97e1 97e1 s         LD      E,(HL)          ; Get LSB of line number
97e2 97e2 d 23
97e2 97e2 s         INC     HL
97e3 97e3 d 56
97e3 97e3 s         LD      D,(HL)          ; Get MSB of line number
97e4 97e4 d 23
97e4 97e4 s         INC     HL
97e5 97e5 d e5
97e5 97e5 s         PUSH    HL              ; Save address of line start
97e6 97e6 d eb
97e6 97e6 s         EX      DE,HL           ; Line number to HL
97e7 97e7 d cdf1a8
97e7 97e7 s         CALL    PRNTHL          ; Output line number in decimal
97ea 97ea d 3e20
97ea 97ea s         LD      A,' '           ; Space after line number
97ec 97ec d e1
97ec 97ec s         POP     HL              ; Restore start of line address
97ed 97ed d cd8697
97ed 97ed s LSTLP2: CALL    OUTC            ; Output character in A
97f0 97f0 d 7e
97f0 97f0 s LSTLP3: LD      A,(HL)          ; Get next byte in line
97f1 97f1 d b7
97f1 97f1 s         OR      A               ; End of line?
97f2 97f2 d 23
97f2 97f2 s         INC     HL              ; To next byte in line
97f3 97f3 d cacd97
97f3 97f3 s         JP      Z,LISTLP        ; Yes - get next line
97f6 97f6 d f2ed97
97f6 97f6 s         JP      P,LSTLP2        ; No token - output it
97f9 97f9 d d67f
97f9 97f9 s         SUB     ZEND-1          ; Find and output word
97fb 97fb d 4f
97fb 97fb s         LD      C,A             ; Token offset+1 to C
97fc 97fc d 113692
97fc 97fc s         LD      DE,WORDS        ; Reserved word list
97ff 97ff d 1a
97ff 97ff s FNDTOK: LD      A,(DE)          ; Get character in list
9800 9800 d 13
9800 9800 s         INC     DE              ; Move on to next
9801 9801 d b7
9801 9801 s         OR      A               ; Is it start of word?
9802 9802 d f2ff97
9802 9802 s         JP      P,FNDTOK        ; No - Keep looking for word
9805 9805 d 0d
9805 9805 s         DEC     C               ; Count words
9806 9806 d c2ff97
9806 9806 s         JP      NZ,FNDTOK       ; Not there - keep looking
9809 9809 d e67f
9809 9809 s OUTWRD: AND     01111111B       ; Strip bit 7
980b 980b d cd8697
980b 980b s         CALL    OUTC            ; Output first character
980e 980e d 1a
980e 980e s         LD      A,(DE)          ; Get next character
980f 980f d 13
980f 980f s         INC     DE              ; Move on to next
9810 9810 d b7
9810 9810 s         OR      A               ; Is it end of word?
9811 9811 d f20998
9811 9811 s         JP      P,OUTWRD        ; No - output the rest
9814 9814 d c3f097
9814 9814 s         JP      LSTLP3          ; Next byte in line
9817 9817 s 
9817 9817 d e5
9817 9817 s SETLIN: PUSH    HL              ; Set up LINES counter
9818 9818 d 2a8db0
9818 9818 s         LD      HL,(LINESN)     ; Get LINES number
981b 981b d 228bb0
981b 981b s         LD      (LINESC),HL     ; Save in LINES counter
981e 981e d e1
981e 981e s         POP     HL
981f 981f d c9
981f 981f s         RET
9820 9820 s 
9820 9820 d e5
9820 9820 s COUNT:  PUSH    HL              ; Save code string address
9821 9821 d d5
9821 9821 s         PUSH    DE
9822 9822 d 2a8bb0
9822 9822 s         LD      HL,(LINESC)     ; Get LINES counter
9825 9825 d 11ffff
9825 9825 s         LD      DE,-1
9828 9828 d ed5a
9828 9828 s         ADC     HL,DE           ; Decrement
982a 982a d 228bb0
982a 982a s         LD      (LINESC),HL     ; Put it back
982d 982d d d1
982d 982d s         POP     DE
982e 982e d e1
982e 982e s         POP     HL              ; Restore code string address
982f 982f d f0
982f 982f s         RET     P               ; Return if more lines to go
9830 9830 d e5
9830 9830 s         PUSH    HL              ; Save code string address
9831 9831 d 2a8db0
9831 9831 s         LD      HL,(LINESN)     ; Get LINES number
9834 9834 d 228bb0
9834 9834 s         LD      (LINESC),HL     ; Reset LINES counter
9837 9837 d cd0dac
9837 9837 s         CALL    GETINP          ; Get input character
983a 983a d fe03
983a 983a s         CP      CTRLC           ; Is it control "C"?
983c 983c d ca4398
983c 983c s         JP      Z,RSLNBK        ; Yes - Reset LINES and break
983f 983f d e1
983f 983f s         POP     HL              ; Restore code string address
9840 9840 d c32098
9840 9840 s         JP      COUNT           ; Keep on counting
9843 9843 s 
9843 9843 d 2a8db0
9843 9843 s RSLNBK: LD      HL,(LINESN)     ; Get LINES number
9846 9846 d 228bb0
9846 9846 s         LD      (LINESC),HL     ; Reset LINES counter
9849 9849 d c3a791
9849 9849 s         JP      BRKRET          ; Go and output "Break"
984c 984c s 
984c 984c d 3e64
984c 984c s FOR:    LD      A,64H           ; Flag "FOR" assignment
984e 984e d 3210b1
984e 984e s         LD      (FORFLG),A      ; Save "FOR" flag
9851 9851 d cdb69a
9851 9851 s         CALL    LET             ; Set up initial index
9854 9854 d c1
9854 9854 s         POP     BC              ; Drop RETurn address
9855 9855 d e5
9855 9855 s         PUSH    HL              ; Save code string address
9856 9856 d cd9f9a
9856 9856 s         CALL    DATA            ; Get next statement address
9859 9859 d 220cb1
9859 9859 s         LD      (LOOPST),HL     ; Save it for start of loop
985c 985c d 210200
985c 985c s         LD      HL,2            ; Offset for "FOR" block
985f 985f d 39
985f 985f s         ADD     HL,SP           ; Point to it
9860 9860 d cd5a94
9860 9860 s FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
9863 9863 d d1
9863 9863 s         POP     DE              ; Get code string address
9864 9864 d c27c98
9864 9864 s         JP      NZ,FORFND       ; No nesting found
9867 9867 d 09
9867 9867 s         ADD     HL,BC           ; Move into "FOR" block
9868 9868 d d5
9868 9868 s         PUSH    DE              ; Save code string address
9869 9869 d 2b
9869 9869 s         DEC     HL
986a 986a d 56
986a 986a s         LD      D,(HL)          ; Get MSB of loop statement
986b 986b d 2b
986b 986b s         DEC     HL
986c 986c d 5e
986c 986c s         LD      E,(HL)          ; Get LSB of loop statement
986d 986d d 23
986d 986d s         INC     HL
986e 986e d 23
986e 986e s         INC     HL
986f 986f d e5
986f 986f s         PUSH    HL              ; Save block address
9870 9870 d 2a0cb1
9870 9870 s         LD      HL,(LOOPST)     ; Get address of loop statement
9873 9873 d cd7597
9873 9873 s         CALL    CPDEHL          ; Compare the FOR loops
9876 9876 d e1
9876 9876 s         POP     HL              ; Restore block address
9877 9877 d c26098
9877 9877 s         JP      NZ,FORSLP       ; Different FORs - Find another
987a 987a d d1
987a 987a s         POP     DE              ; Restore code string address
987b 987b d f9
987b 987b s         LD      SP,HL           ; Remove all nested loops
987c 987c s 
987c 987c d eb
987c 987c s FORFND: EX      DE,HL           ; Code string address to HL
987d 987d d 0e08
987d 987d s         LD      C,8
987f 987f d cd8a94
987f 987f s         CALL    CHKSTK          ; Check for 8 levels of stack
9882 9882 d e5
9882 9882 s         PUSH    HL              ; Save code string address
9883 9883 d 2a0cb1
9883 9883 s         LD      HL,(LOOPST)     ; Get first statement of loop
9886 9886 d e3
9886 9886 s         EX      (SP),HL         ; Save and restore code string
9887 9887 d e5
9887 9887 s         PUSH    HL              ; Re-save code string address
9888 9888 d 2aa1b0
9888 9888 s         LD      HL,(LINEAT)     ; Get current line number
988b 988b d e3
988b 988b s         EX      (SP),HL         ; Save and restore code string
988c 988c d cd789d
988c 988c s         CALL    TSTNUM          ; Make sure it's a number
988f 988f d cd7b97
988f 988f s         CALL    CHKSYN          ; Make sure "TO" is next
9892 9892 d a6
9892 9892 s         .BYTE   ZTO          ; "TO" token
9893 9893 d cd759d
9893 9893 s         CALL    GETNUM          ; Get "TO" expression value
9896 9896 d e5
9896 9896 s         PUSH    HL              ; Save code string address
9897 9897 d cda3a7
9897 9897 s         CALL    BCDEFP          ; Move "TO" value to BCDE
989a 989a d e1
989a 989a s         POP     HL              ; Restore code string address
989b 989b d c5
989b 989b s         PUSH    BC              ; Save "TO" value in block
989c 989c d d5
989c 989c s         PUSH    DE
989d 989d d 010081
989d 989d s         LD      BC,8100H        ; BCDE - 1 (default STEP)
98a0 98a0 d 51
98a0 98a0 s         LD      D,C             ; C=0
98a1 98a1 d 5a
98a1 98a1 s         LD      E,D             ; D=0
98a2 98a2 d 7e
98a2 98a2 s         LD      A,(HL)          ; Get next byte in code string
98a3 98a3 d feab
98a3 98a3 s         CP      ZSTEP           ; See if "STEP" is stated
98a5 98a5 d 3e01
98a5 98a5 s         LD      A,1             ; Sign of step = 1
98a7 98a7 d c2b898
98a7 98a7 s         JP      NZ,SAVSTP       ; No STEP given - Default to 1
98aa 98aa d cd0599
98aa 98aa s         CALL    GETCHR          ; Jump over "STEP" token
98ad 98ad d cd759d
98ad 98ad s         CALL    GETNUM          ; Get step value
98b0 98b0 d e5
98b0 98b0 s         PUSH    HL              ; Save code string address
98b1 98b1 d cda3a7
98b1 98b1 s         CALL    BCDEFP          ; Move STEP to BCDE
98b4 98b4 d cd57a7
98b4 98b4 s         CALL    TSTSGN          ; Test sign of FPREG
98b7 98b7 d e1
98b7 98b7 s         POP     HL              ; Restore code string address
98b8 98b8 d c5
98b8 98b8 s SAVSTP: PUSH    BC              ; Save the STEP value in block
98b9 98b9 d d5
98b9 98b9 s         PUSH    DE
98ba 98ba d f5
98ba 98ba s         PUSH    AF              ; Save sign of STEP
98bb 98bb d 33
98bb 98bb s         INC     SP              ; Don't save flags
98bc 98bc d e5
98bc 98bc s         PUSH    HL              ; Save code string address
98bd 98bd d 2a13b1
98bd 98bd s         LD      HL,(BRKLIN)     ; Get address of index variable
98c0 98c0 d e3
98c0 98c0 s         EX      (SP),HL         ; Save and restore code string
98c1 98c1 d 0681
98c1 98c1 s PUTFID: LD      B,ZFOR          ; "FOR" block marker
98c3 98c3 d c5
98c3 98c3 s         PUSH    BC              ; Save it
98c4 98c4 d 33
98c4 98c4 s         INC     SP              ; Don't save C
98c5 98c5 s 
98c5 98c5 d cd3099
98c5 98c5 s RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
98c8 98c8 d 2213b1
98c8 98c8 s         LD      (BRKLIN),HL     ; Save code address for break
98cb 98cb d 7e
98cb 98cb s         LD      A,(HL)          ; Get next byte in code string
98cc 98cc d fe3a
98cc 98cc s         CP      ':'             ; Multi statement line?
98ce 98ce d cae598
98ce 98ce s         JP      Z,EXCUTE        ; Yes - Execute it
98d1 98d1 d b7
98d1 98d1 s         OR      A               ; End of line?
98d2 98d2 d c2ad94
98d2 98d2 s         JP      NZ,SNERR        ; No - Syntax error
98d5 98d5 d 23
98d5 98d5 s         INC     HL              ; Point to address of next line
98d6 98d6 d 7e
98d6 98d6 s         LD      A,(HL)          ; Get LSB of line pointer
98d7 98d7 d 23
98d7 98d7 s         INC     HL
98d8 98d8 d b6
98d8 98d8 s         OR      (HL)            ; Is it zero (End of prog)?
98d9 98d9 d ca5a99
98d9 98d9 s         JP      Z,ENDPRG        ; Yes - Terminate execution
98dc 98dc d 23
98dc 98dc s         INC     HL              ; Point to line number
98dd 98dd d 5e
98dd 98dd s         LD      E,(HL)          ; Get LSB of line number
98de 98de d 23
98de 98de s         INC     HL
98df 98df d 56
98df 98df s         LD      D,(HL)          ; Get MSB of line number
98e0 98e0 d eb
98e0 98e0 s         EX      DE,HL           ; Line number to HL
98e1 98e1 d 22a1b0
98e1 98e1 s         LD      (LINEAT),HL     ; Save as current line number
98e4 98e4 d eb
98e4 98e4 s         EX      DE,HL           ; Line number back to DE
98e5 98e5 d cd0599
98e5 98e5 s EXCUTE: CALL    GETCHR          ; Get key word
98e8 98e8 d 11c598
98e8 98e8 s         LD      DE,RUNCNT       ; Where to RETurn to
98eb 98eb d d5
98eb 98eb s         PUSH    DE              ; Save for RETurn
98ec 98ec d c8
98ec 98ec s IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
98ed 98ed d d680
98ed 98ed s ONJMP:  SUB     ZEND            ; Is it a token?
98ef 98ef d dab69a
98ef 98ef s         JP      C,LET           ; No - try to assign it
98f2 98f2 d fe25
98f2 98f2 s         CP      ZNEW+1-ZEND     ; END to NEW ?
98f4 98f4 d d2ad94
98f4 98f4 s         JP      NC,SNERR        ; Not a key word - ?SN Error
98f7 98f7 d 07
98f7 98f7 s         RLCA                    ; Double it
98f8 98f8 d 4f
98f8 98f8 s         LD      C,A             ; BC = Offset into table
98f9 98f9 d 0600
98f9 98f9 s         LD      B,0
98fb 98fb d eb
98fb 98fb s         EX      DE,HL           ; Save code string address
98fc 98fc d 215593
98fc 98fc s         LD      HL,WORDTB       ; Keyword address table
98ff 98ff d 09
98ff 98ff s         ADD     HL,BC           ; Point to routine address
9900 9900 d 4e
9900 9900 s         LD      C,(HL)          ; Get LSB of routine address
9901 9901 d 23
9901 9901 s         INC     HL
9902 9902 d 46
9902 9902 s         LD      B,(HL)          ; Get MSB of routine address
9903 9903 d c5
9903 9903 s         PUSH    BC              ; Save routine address
9904 9904 d eb
9904 9904 s         EX      DE,HL           ; Restore code string address
9905 9905 s 
9905 9905 d 23
9905 9905 s GETCHR: INC     HL              ; Point to next character
9906 9906 d 7e
9906 9906 s         LD      A,(HL)          ; Get next code string byte
9907 9907 d fe3a
9907 9907 s         CP      ':'             ; Z if ':'
9909 9909 d d0
9909 9909 s         RET     NC              ; NC if > "9"
990a 990a d fe20
990a 990a s         CP      ' '
990c 990c d ca0599
990c 990c s         JP      Z,GETCHR        ; Skip over spaces
990f 990f d fe30
990f 990f s         CP      '0'
9911 9911 d 3f
9911 9911 s         CCF                     ; NC if < '0'
9912 9912 d 3c
9912 9912 s         INC     A               ; Test for zero - Leave carry
9913 9913 d 3d
9913 9913 s         DEC     A               ; Z if Null
9914 9914 d c9
9914 9914 s         RET
9915 9915 s 
9915 9915 d eb
9915 9915 s RESTOR: EX      DE,HL           ; Save code string address
9916 9916 d 2aa3b0
9916 9916 s         LD      HL,(BASTXT)     ; Point to start of program
9919 9919 d ca2a99
9919 9919 s         JP      Z,RESTNL        ; Just RESTORE - reset pointer
991c 991c d eb
991c 991c s         EX      DE,HL           ; Restore code string address
991d 991d d cdd499
991d 991d s         CALL    ATOH            ; Get line number to DE
9920 9920 d e5
9920 9920 s         PUSH    HL              ; Save code string address
9921 9921 d cd9995
9921 9921 s         CALL    SRCHLN          ; Search for line number in DE
9924 9924 d 60
9924 9924 s         LD      H,B             ; HL = Address of line
9925 9925 d 69
9925 9925 s         LD      L,C
9926 9926 d d1
9926 9926 s         POP     DE              ; Restore code string address
9927 9927 d d2759a
9927 9927 s         JP      NC,ULERR        ; ?UL Error if not found
992a 992a d 2b
992a 992a s RESTNL: DEC     HL              ; Byte before DATA statement
992b 992b d 2221b1
992b 992b s UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
992e 992e d eb
992e 992e s         EX      DE,HL           ; Restore code string address
992f 992f d c9
992f 992f s         RET
9930 9930 s 
9930 9930 s ;;; <ESH> edit a bit to check for break, then read character
9930 9930 s ;TSTBRK: RST     18H             ; Check input status
9930 9930 s ;        RET     Z               ; No key, go back
9930 9930 s ;        RST     10H             ; Get the key into A
9930 9930 s 
9930 9930 d cd7fad
9930 9930 s TSTBRK:	call	umon_chkbrk	;<ESH> check for break, then input char
9933 9933 d c8
9933 9933 s         RET     Z               ; No key, go back
9934 9934 d fe1b
9934 9934 s         CP      ESC             ; Escape key?
9936 9936 d 2813
9936 9936 s         JR      Z,BRK           ; Yes, break
9938 9938 d fe03
9938 9938 s         CP      CTRLC           ; <Ctrl-C>
993a 993a d 280f
993a 993a s         JR      Z,BRK           ; Yes, break
993c 993c d fe13
993c 993c s         CP      CTRLS           ; Stop scrolling?
993e 993e d c0
993e 993e s         RET     NZ              ; Other key, ignore
993f 993f s 
993f 993f s ;STALL:  RST     10H             ; Wait for key <FIXME>
993f 993f d cd8fad
993f 993f s STALL:  call	umon_getc	;<ESH> read serial
9942 9942 d fe11
9942 9942 s         CP      CTRLQ           ; Resume scrolling?
9944 9944 d c8
9944 9944 s         RET      Z              ; Release the chokehold
9945 9945 d fe03
9945 9945 s         CP      CTRLC           ; Second break?
9947 9947 d 2807
9947 9947 s         JR      Z,STOP          ; Break during hold exits prog
9949 9949 d 18f4
9949 9949 s         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
994b 994b s 
994b 994b d 3eff
994b 994b s BRK     LD      A,$FF           ; Set BRKFLG
994d 994d d 3292b0
994d 994d s         LD      (BRKFLG),A      ; Store it
9950 9950 s 
9950 9950 s 
9950 9950 d c0
9950 9950 s STOP:   RET     NZ              ; Exit if anything else
9951 9951 d f6
9951 9951 s         .BYTE   0F6H            ; Flag "STOP"
9952 9952 d c0
9952 9952 s PEND:   RET     NZ              ; Exit if anything else
9953 9953 d 2213b1
9953 9953 s         LD      (BRKLIN),HL     ; Save point of break
9956 9956 d 21
9956 9956 s         .BYTE   21H             ; Skip "OR 11111111B"
9957 9957 d f6ff
9957 9957 s INPBRK: OR      11111111B       ; Flag "Break" wanted
9959 9959 d c1
9959 9959 s         POP     BC              ; Return not needed and more
995a 995a d 2aa1b0
995a 995a s ENDPRG: LD      HL,(LINEAT)     ; Get current line number
995d 995d d f5
995d 995d s         PUSH    AF              ; Save STOP / END status
995e 995e d 7d
995e 995e s         LD      A,L             ; Is it direct break?
995f 995f d a4
995f 995f s         AND     H
9960 9960 d 3c
9960 9960 s         INC     A               ; Line is -1 if direct break
9961 9961 d ca6d99
9961 9961 s         JP      Z,NOLIN         ; Yes - No line number
9964 9964 d 2217b1
9964 9964 s         LD      (ERRLIN),HL     ; Save line of break
9967 9967 d 2a13b1
9967 9967 s         LD      HL,(BRKLIN)     ; Get point of break
996a 996a d 2219b1
996a 996a s         LD      (CONTAD),HL     ; Save point to CONTinue
996d 996d d af
996d 996d s NOLIN:  XOR     A
996e 996e d 328ab0
996e 996e s         LD      (CTLOFG),A      ; Enable output
9971 9971 d cda39b
9971 9971 s         CALL    STTLIN          ; Start a new line
9974 9974 d f1
9974 9974 s         POP     AF              ; Restore STOP / END status
9975 9975 d 215094
9975 9975 s         LD      HL,BRKMSG       ; "Break" message
9978 9978 d c2e194
9978 9978 s         JP      NZ,ERRIN        ; "in line" wanted?
997b 997b d c3f894
997b 997b s         JP      PRNTOK          ; Go to command mode
997e 997e s 
997e 997e d 2a19b1
997e 997e s CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
9981 9981 d 7c
9981 9981 s         LD      A,H             ; Is it zero?
9982 9982 d b5
9982 9982 s         OR      L
9983 9983 d 1e20
9983 9983 s         LD      E,CN            ; ?CN Error
9985 9985 d cac194
9985 9985 s         JP      Z,ERROR         ; Yes - output "?CN Error"
9988 9988 d eb
9988 9988 s         EX      DE,HL           ; Save code string address
9989 9989 d 2a17b1
9989 9989 s         LD      HL,(ERRLIN)     ; Get line of last break
998c 998c d 22a1b0
998c 998c s         LD      (LINEAT),HL     ; Set up current line number
998f 998f d eb
998f 998f s         EX      DE,HL           ; Restore code string address
9990 9990 d c9
9990 9990 s         RET                     ; CONTinue where left off
9991 9991 s 
9991 9991 d cdd6a4
9991 9991 s NULL:   CALL    GETINT          ; Get integer 0-255
9994 9994 d c0
9994 9994 s         RET     NZ              ; Return if bad value
9995 9995 d 3286b0
9995 9995 s         LD      (NULLS),A       ; Set nulls number
9998 9998 d c9
9998 9998 s         RET
9999 9999 s 
9999 9999 s 
9999 9999 d e5
9999 9999 s ACCSUM: PUSH    HL              ; Save address in array
999a 999a d 2a8fb0
999a 999a s         LD      HL,(CHKSUM)     ; Get check sum
999d 999d d 0600
999d 999d s         LD      B,0             ; BC - Value of byte
999f 999f d 4f
999f 999f s         LD      C,A
99a0 99a0 d 09
99a0 99a0 s         ADD     HL,BC           ; Add byte to check sum
99a1 99a1 d 228fb0
99a1 99a1 s         LD      (CHKSUM),HL     ; Re-save check sum
99a4 99a4 d e1
99a4 99a4 s         POP     HL              ; Restore address in array
99a5 99a5 d c9
99a5 99a5 s         RET
99a6 99a6 s 
99a6 99a6 d 7e
99a6 99a6 s CHKLTR: LD      A,(HL)          ; Get byte
99a7 99a7 d fe41
99a7 99a7 s         CP      'A'             ; < 'a' ?
99a9 99a9 d d8
99a9 99a9 s         RET     C               ; Carry set if not letter
99aa 99aa d fe5b
99aa 99aa s         CP      'Z'+1           ; > 'z' ?
99ac 99ac d 3f
99ac 99ac s         CCF
99ad 99ad d c9
99ad 99ad s         RET                     ; Carry set if not letter
99ae 99ae s 
99ae 99ae d cd0599
99ae 99ae s FPSINT: CALL    GETCHR          ; Get next character
99b1 99b1 d cd759d
99b1 99b1 s POSINT: CALL    GETNUM          ; Get integer 0 to 32767
99b4 99b4 d cd57a7
99b4 99b4 s DEPINT: CALL    TSTSGN          ; Test sign of FPREG
99b7 99b7 d facf99
99b7 99b7 s         JP      M,FCERR         ; Negative - ?FC Error
99ba 99ba d 3a2cb1
99ba 99ba s DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
99bd 99bd d fe90
99bd 99bd s         CP      80H+16          ; Exponent in range (16 bits)?
99bf 99bf d daffa7
99bf 99bf s         JP      C,FPINT         ; Yes - convert it
99c2 99c2 d 018090
99c2 99c2 s         LD      BC,9080H        ; BCDE = -32768
99c5 99c5 d 110000
99c5 99c5 s         LD      DE,0000
99c8 99c8 d e5
99c8 99c8 s         PUSH    HL              ; Save code string address
99c9 99c9 d cdd2a7
99c9 99c9 s         CALL    CMPNUM          ; Compare FPREG with BCDE
99cc 99cc d e1
99cc 99cc s         POP     HL              ; Restore code string address
99cd 99cd d 51
99cd 99cd s         LD      D,C             ; MSB to D
99ce 99ce d c8
99ce 99ce s         RET     Z               ; Return if in range
99cf 99cf d 1e08
99cf 99cf s FCERR:  LD      E,FC            ; ?FC Error
99d1 99d1 d c3c194
99d1 99d1 s         JP      ERROR           ; Output error-
99d4 99d4 s 
99d4 99d4 d 2b
99d4 99d4 s ATOH:   DEC     HL              ; ASCII number to DE binary
99d5 99d5 d 110000
99d5 99d5 s GETLN:  LD      DE,0            ; Get number to DE
99d8 99d8 d cd0599
99d8 99d8 s GTLNLP: CALL    GETCHR          ; Get next character
99db 99db d d0
99db 99db s         RET     NC              ; Exit if not a digit
99dc 99dc d e5
99dc 99dc s         PUSH    HL              ; Save code string address
99dd 99dd d f5
99dd 99dd s         PUSH    AF              ; Save digit
99de 99de d 219819
99de 99de s         LD      HL,65529/10     ; Largest number 65529
99e1 99e1 d cd7597
99e1 99e1 s         CALL    CPDEHL          ; Number in range?
99e4 99e4 d daad94
99e4 99e4 s         JP      C,SNERR         ; No - ?SN Error
99e7 99e7 d 62
99e7 99e7 s         LD      H,D             ; HL = Number
99e8 99e8 d 6b
99e8 99e8 s         LD      L,E
99e9 99e9 d 19
99e9 99e9 s         ADD     HL,DE           ; Times 2
99ea 99ea d 29
99ea 99ea s         ADD     HL,HL           ; Times 4
99eb 99eb d 19
99eb 99eb s         ADD     HL,DE           ; Times 5
99ec 99ec d 29
99ec 99ec s         ADD     HL,HL           ; Times 10
99ed 99ed d f1
99ed 99ed s         POP     AF              ; Restore digit
99ee 99ee d d630
99ee 99ee s         SUB     '0'             ; Make it 0 to 9
99f0 99f0 d 5f
99f0 99f0 s         LD      E,A             ; DE = Value of digit
99f1 99f1 d 1600
99f1 99f1 s         LD      D,0
99f3 99f3 d 19
99f3 99f3 s         ADD     HL,DE           ; Add to number
99f4 99f4 d eb
99f4 99f4 s         EX      DE,HL           ; Number to DE
99f5 99f5 d e1
99f5 99f5 s         POP     HL              ; Restore code string address
99f6 99f6 d c3d899
99f6 99f6 s         JP      GTLNLP          ; Go to next character
99f9 99f9 s 
99f9 99f9 d cac995
99f9 99f9 s CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
99fc 99fc d cdb199
99fc 99fc s         CALL    POSINT          ; Get integer 0 to 32767 to DE
99ff 99ff d 2b
99ff 99ff s         DEC     HL              ; Cancel increment
9a00 9a00 d cd0599
9a00 9a00 s         CALL    GETCHR          ; Get next character
9a03 9a03 d e5
9a03 9a03 s         PUSH    HL              ; Save code string address
9a04 9a04 d 2af4b0
9a04 9a04 s         LD      HL,(LSTRAM)     ; Get end of RAM
9a07 9a07 d ca1c9a
9a07 9a07 s         JP      Z,STORED        ; No value given - Use stored
9a0a 9a0a d e1
9a0a 9a0a s         POP     HL              ; Restore code string address
9a0b 9a0b d cd7b97
9a0b 9a0b s         CALL    CHKSYN          ; Check for comma
9a0e 9a0e d 2c
9a0e 9a0e s         .BYTE      ','
9a0f 9a0f d d5
9a0f 9a0f s         PUSH    DE              ; Save number
9a10 9a10 d cdb199
9a10 9a10 s         CALL    POSINT          ; Get integer 0 to 32767
9a13 9a13 d 2b
9a13 9a13 s         DEC     HL              ; Cancel increment
9a14 9a14 d cd0599
9a14 9a14 s         CALL    GETCHR          ; Get next character
9a17 9a17 d c2ad94
9a17 9a17 s         JP      NZ,SNERR        ; ?SN Error if more on line
9a1a 9a1a d e3
9a1a 9a1a s         EX      (SP),HL         ; Save code string address
9a1b 9a1b d eb
9a1b 9a1b s         EX      DE,HL           ; Number to DE
9a1c 9a1c d 7d
9a1c 9a1c s STORED: LD      A,L             ; Get LSB of new RAM top
9a1d 9a1d d 93
9a1d 9a1d s         SUB     E               ; Subtract LSB of string space
9a1e 9a1e d 5f
9a1e 9a1e s         LD      E,A             ; Save LSB
9a1f 9a1f d 7c
9a1f 9a1f s         LD      A,H             ; Get MSB of new RAM top
9a20 9a20 d 9a
9a20 9a20 s         SBC     A,D             ; Subtract MSB of string space
9a21 9a21 d 57
9a21 9a21 s         LD      D,A             ; Save MSB
9a22 9a22 d daa294
9a22 9a22 s         JP      C,OMERR         ; ?OM Error if not enough mem
9a25 9a25 d e5
9a25 9a25 s         PUSH    HL              ; Save RAM top
9a26 9a26 d 2a1bb1
9a26 9a26 s         LD      HL,(PROGND)     ; Get program end
9a29 9a29 d 012800
9a29 9a29 s         LD      BC,40           ; 40 Bytes minimum working RAM
9a2c 9a2c d 09
9a2c 9a2c s         ADD     HL,BC           ; Get lowest address
9a2d 9a2d d cd7597
9a2d 9a2d s         CALL    CPDEHL          ; Enough memory?
9a30 9a30 d d2a294
9a30 9a30 s         JP      NC,OMERR        ; No - ?OM Error
9a33 9a33 d eb
9a33 9a33 s         EX      DE,HL           ; RAM top to HL
9a34 9a34 d 229fb0
9a34 9a34 s         LD      (STRSPC),HL     ; Set new string space
9a37 9a37 d e1
9a37 9a37 s         POP     HL              ; End of memory to use
9a38 9a38 d 22f4b0
9a38 9a38 s         LD      (LSTRAM),HL     ; Set new top of RAM
9a3b 9a3b d e1
9a3b 9a3b s         POP     HL              ; Restore code string address
9a3c 9a3c d c3c995
9a3c 9a3c s         JP      INTVAR          ; Initialise variables
9a3f 9a3f s 
9a3f 9a3f d cac595
9a3f 9a3f s RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
9a42 9a42 d cdc995
9a42 9a42 s         CALL    INTVAR          ; Initialise variables
9a45 9a45 d 01c598
9a45 9a45 s         LD      BC,RUNCNT       ; Execution driver loop
9a48 9a48 d c35b9a
9a48 9a48 s         JP      RUNLIN          ; RUN from line number
9a4b 9a4b s 
9a4b 9a4b d 0e03
9a4b 9a4b s GOSUB:  LD      C,3             ; 3 Levels of stack needed
9a4d 9a4d d cd8a94
9a4d 9a4d s         CALL    CHKSTK          ; Check for 3 levels of stack
9a50 9a50 d c1
9a50 9a50 s         POP     BC              ; Get return address
9a51 9a51 d e5
9a51 9a51 s         PUSH    HL              ; Save code string for RETURN
9a52 9a52 d e5
9a52 9a52 s         PUSH    HL              ; And for GOSUB routine
9a53 9a53 d 2aa1b0
9a53 9a53 s         LD      HL,(LINEAT)     ; Get current line
9a56 9a56 d e3
9a56 9a56 s         EX      (SP),HL         ; Into stack - Code string out
9a57 9a57 d 3e8c
9a57 9a57 s         LD      A,ZGOSUB        ; "GOSUB" token
9a59 9a59 d f5
9a59 9a59 s         PUSH    AF              ; Save token
9a5a 9a5a d 33
9a5a 9a5a s         INC     SP              ; Don't save flags
9a5b 9a5b s 
9a5b 9a5b d c5
9a5b 9a5b s RUNLIN: PUSH    BC              ; Save return address
9a5c 9a5c d cdd499
9a5c 9a5c s GOTO:   CALL    ATOH            ; ASCII number to DE binary
9a5f 9a5f d cda19a
9a5f 9a5f s         CALL    REM             ; Get end of line
9a62 9a62 d e5
9a62 9a62 s         PUSH    HL              ; Save end of line
9a63 9a63 d 2aa1b0
9a63 9a63 s         LD      HL,(LINEAT)     ; Get current line
9a66 9a66 d cd7597
9a66 9a66 s         CALL    CPDEHL          ; Line after current?
9a69 9a69 d e1
9a69 9a69 s         POP     HL              ; Restore end of line
9a6a 9a6a d 23
9a6a 9a6a s         INC     HL              ; Start of next line
9a6b 9a6b d dc9c95
9a6b 9a6b s         CALL    C,SRCHLP        ; Line is after current line
9a6e 9a6e d d49995
9a6e 9a6e s         CALL    NC,SRCHLN       ; Line is before current line
9a71 9a71 d 60
9a71 9a71 s         LD      H,B             ; Set up code string address
9a72 9a72 d 69
9a72 9a72 s         LD      L,C
9a73 9a73 d 2b
9a73 9a73 s         DEC     HL              ; Incremented after
9a74 9a74 d d8
9a74 9a74 s         RET     C               ; Line found
9a75 9a75 d 1e0e
9a75 9a75 s ULERR:  LD      E,UL            ; ?UL Error
9a77 9a77 d c3c194
9a77 9a77 s         JP      ERROR           ; Output error message
9a7a 9a7a s 
9a7a 9a7a d c0
9a7a 9a7a s RETURN: RET     NZ              ; Return if not just RETURN
9a7b 9a7b d 16ff
9a7b 9a7b s         LD      D,-1            ; Flag "GOSUB" search
9a7d 9a7d d cd5694
9a7d 9a7d s         CALL    BAKSTK          ; Look "GOSUB" block
9a80 9a80 d f9
9a80 9a80 s         LD      SP,HL           ; Kill all FORs in subroutine
9a81 9a81 d fe8c
9a81 9a81 s         CP      ZGOSUB          ; Test for "GOSUB" token
9a83 9a83 d 1e04
9a83 9a83 s         LD      E,RG            ; ?RG Error
9a85 9a85 d c2c194
9a85 9a85 s         JP      NZ,ERROR        ; Error if no "GOSUB" found
9a88 9a88 d e1
9a88 9a88 s         POP     HL              ; Get RETURN line number
9a89 9a89 d 22a1b0
9a89 9a89 s         LD      (LINEAT),HL     ; Save as current
9a8c 9a8c d 23
9a8c 9a8c s         INC     HL              ; Was it from direct statement?
9a8d 9a8d d 7c
9a8d 9a8d s         LD      A,H
9a8e 9a8e d b5
9a8e 9a8e s         OR      L               ; Return to line
9a8f 9a8f d c2999a
9a8f 9a8f s         JP      NZ,RETLIN       ; No - Return to line
9a92 9a92 d 3a11b1
9a92 9a92 s         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
9a95 9a95 d b7
9a95 9a95 s         OR      A               ; If so buffer is corrupted
9a96 9a96 d c2f794
9a96 9a96 s         JP      NZ,POPNOK       ; Yes - Go to command mode
9a99 9a99 d 21c598
9a99 9a99 s RETLIN: LD      HL,RUNCNT       ; Execution driver loop
9a9c 9a9c d e3
9a9c 9a9c s         EX      (SP),HL         ; Into stack - Code string out
9a9d 9a9d d 3e
9a9d 9a9d s         .BYTE      3EH             ; Skip "POP HL"
9a9e 9a9e d e1
9a9e 9a9e s NXTDTA: POP     HL              ; Restore code string address
9a9f 9a9f s 
9a9f 9a9f d 013a
9a9f 9a9f s DATA:   .BYTE      01H,3AH         ; ':' End of statement
9aa1 9aa1 d 0e00
9aa1 9aa1 s REM:    LD      C,0             ; 00  End of statement
9aa3 9aa3 d 0600
9aa3 9aa3 s         LD      B,0
9aa5 9aa5 d 79
9aa5 9aa5 s NXTSTL: LD      A,C             ; Statement and byte
9aa6 9aa6 d 48
9aa6 9aa6 s         LD      C,B
9aa7 9aa7 d 47
9aa7 9aa7 s         LD      B,A             ; Statement end byte
9aa8 9aa8 d 7e
9aa8 9aa8 s NXTSTT: LD      A,(HL)          ; Get byte
9aa9 9aa9 d b7
9aa9 9aa9 s         OR      A               ; End of line?
9aaa 9aaa d c8
9aaa 9aaa s         RET     Z               ; Yes - Exit
9aab 9aab d b8
9aab 9aab s         CP      B               ; End of statement?
9aac 9aac d c8
9aac 9aac s         RET     Z               ; Yes - Exit
9aad 9aad d 23
9aad 9aad s         INC     HL              ; Next byte
9aae 9aae d fe22
9aae 9aae s         CP      '"'             ; Literal string?
9ab0 9ab0 d caa59a
9ab0 9ab0 s         JP      Z,NXTSTL        ; Yes - Look for another '"'
9ab3 9ab3 d c3a89a
9ab3 9ab3 s         JP      NXTSTT          ; Keep looking
9ab6 9ab6 s 
9ab6 9ab6 d cd6b9f
9ab6 9ab6 s LET:    CALL    GETVAR          ; Get variable name
9ab9 9ab9 d cd7b97
9ab9 9ab9 s         CALL    CHKSYN          ; Make sure "=" follows
9abc 9abc d b4
9abc 9abc s         .BYTE      ZEQUAL          ; "=" token
9abd 9abd d d5
9abd 9abd s         PUSH    DE              ; Save address of variable
9abe 9abe d 3af2b0
9abe 9abe s         LD      A,(TYPE)        ; Get data type
9ac1 9ac1 d f5
9ac1 9ac1 s         PUSH    AF              ; Save type
9ac2 9ac2 d cd879d
9ac2 9ac2 s         CALL    EVAL            ; Evaluate expression
9ac5 9ac5 d f1
9ac5 9ac5 s         POP     AF              ; Restore type
9ac6 9ac6 d e3
9ac6 9ac6 s         EX      (SP),HL         ; Save code - Get var addr
9ac7 9ac7 d 2213b1
9ac7 9ac7 s         LD      (BRKLIN),HL     ; Save address of variable
9aca 9aca d 1f
9aca 9aca s         RRA                     ; Adjust type
9acb 9acb d cd7a9d
9acb 9acb s         CALL    CHKTYP          ; Check types are the same
9ace 9ace d ca099b
9ace 9ace s         JP      Z,LETNUM        ; Numeric - Move value
9ad1 9ad1 d e5
9ad1 9ad1 s LETSTR: PUSH    HL              ; Save address of string var
9ad2 9ad2 d 2a29b1
9ad2 9ad2 s         LD      HL,(FPREG)      ; Pointer to string entry
9ad5 9ad5 d e5
9ad5 9ad5 s         PUSH    HL              ; Save it on stack
9ad6 9ad6 d 23
9ad6 9ad6 s         INC     HL              ; Skip over length
9ad7 9ad7 d 23
9ad7 9ad7 s         INC     HL
9ad8 9ad8 d 5e
9ad8 9ad8 s         LD      E,(HL)          ; LSB of string address
9ad9 9ad9 d 23
9ad9 9ad9 s         INC     HL
9ada 9ada d 56
9ada 9ada s         LD      D,(HL)          ; MSB of string address
9adb 9adb d 2aa3b0
9adb 9adb s         LD      HL,(BASTXT)     ; Point to start of program
9ade 9ade d cd7597
9ade 9ade s         CALL    CPDEHL          ; Is string before program?
9ae1 9ae1 d d2f89a
9ae1 9ae1 s         JP      NC,CRESTR       ; Yes - Create string entry
9ae4 9ae4 d 2a9fb0
9ae4 9ae4 s         LD      HL,(STRSPC)     ; Point to string space
9ae7 9ae7 d cd7597
9ae7 9ae7 s         CALL    CPDEHL          ; Is string literal in program?
9aea 9aea d d1
9aea 9aea s         POP     DE              ; Restore address of string
9aeb 9aeb d d2009b
9aeb 9aeb s         JP      NC,MVSTPT       ; Yes - Set up pointer
9aee 9aee d 2104b1
9aee 9aee s         LD      HL,TMPSTR       ; Temporary string pool
9af1 9af1 d cd7597
9af1 9af1 s         CALL    CPDEHL          ; Is string in temporary pool?
9af4 9af4 d d2009b
9af4 9af4 s         JP      NC,MVSTPT       ; No - Set up pointer
9af7 9af7 d 3e
9af7 9af7 s         .BYTE   3EH             ; Skip "POP DE"
9af8 9af8 d d1
9af8 9af8 s CRESTR: POP     DE              ; Restore address of string
9af9 9af9 d cdafa3
9af9 9af9 s         CALL    BAKTMP          ; Back to last tmp-str entry
9afc 9afc d eb
9afc 9afc s         EX      DE,HL           ; Address of string entry
9afd 9afd d cde8a1
9afd 9afd s         CALL    SAVSTR          ; Save string in string area
9b00 9b00 d cdafa3
9b00 9b00 s MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
9b03 9b03 d e1
9b03 9b03 s         POP     HL              ; Get string pointer
9b04 9b04 d cdb2a7
9b04 9b04 s         CALL    DETHL4          ; Move string pointer to var
9b07 9b07 d e1
9b07 9b07 s         POP     HL              ; Restore code string address
9b08 9b08 d c9
9b08 9b08 s         RET
9b09 9b09 s 
9b09 9b09 d e5
9b09 9b09 s LETNUM: PUSH    HL              ; Save address of variable
9b0a 9b0a d cdafa7
9b0a 9b0a s         CALL    FPTHL           ; Move value to variable
9b0d 9b0d d d1
9b0d 9b0d s         POP     DE              ; Restore address of variable
9b0e 9b0e d e1
9b0e 9b0e s         POP     HL              ; Restore code string address
9b0f 9b0f d c9
9b0f 9b0f s         RET
9b10 9b10 s 
9b10 9b10 d cdd6a4
9b10 9b10 s ON:     CALL    GETINT          ; Get integer 0-255
9b13 9b13 d 7e
9b13 9b13 s         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
9b14 9b14 d 47
9b14 9b14 s         LD      B,A             ; Save in B
9b15 9b15 d fe8c
9b15 9b15 s         CP      ZGOSUB          ; "GOSUB" token?
9b17 9b17 d ca1f9b
9b17 9b17 s         JP      Z,ONGO          ; Yes - Find line number
9b1a 9b1a d cd7b97
9b1a 9b1a s         CALL    CHKSYN          ; Make sure it's "GOTO"
9b1d 9b1d d 88
9b1d 9b1d s         .BYTE   ZGOTO           ; "GOTO" token
9b1e 9b1e d 2b
9b1e 9b1e s         DEC     HL              ; Cancel increment
9b1f 9b1f d 4b
9b1f 9b1f s ONGO:   LD      C,E             ; Integer of branch value
9b20 9b20 d 0d
9b20 9b20 s ONGOLP: DEC     C               ; Count branches
9b21 9b21 d 78
9b21 9b21 s         LD      A,B             ; Get "GOTO" or "GOSUB" token
9b22 9b22 d caed98
9b22 9b22 s         JP      Z,ONJMP         ; Go to that line if right one
9b25 9b25 d cdd599
9b25 9b25 s         CALL    GETLN           ; Get line number to DE
9b28 9b28 d fe2c
9b28 9b28 s         CP      ','             ; Another line number?
9b2a 9b2a d c0
9b2a 9b2a s         RET     NZ              ; No - Drop through
9b2b 9b2b d c3209b
9b2b 9b2b s         JP      ONGOLP          ; Yes - loop
9b2e 9b2e s 
9b2e 9b2e d cd879d
9b2e 9b2e s IF:     CALL    EVAL            ; Evaluate expression
9b31 9b31 d 7e
9b31 9b31 s         LD      A,(HL)          ; Get token
9b32 9b32 d fe88
9b32 9b32 s         CP      ZGOTO           ; "GOTO" token?
9b34 9b34 d ca3c9b
9b34 9b34 s         JP      Z,IFGO          ; Yes - Get line
9b37 9b37 d cd7b97
9b37 9b37 s         CALL    CHKSYN          ; Make sure it's "THEN"
9b3a 9b3a d a9
9b3a 9b3a s         .BYTE      ZTHEN           ; "THEN" token
9b3b 9b3b d 2b
9b3b 9b3b s         DEC     HL              ; Cancel increment
9b3c 9b3c d cd789d
9b3c 9b3c s IFGO:   CALL    TSTNUM          ; Make sure it's numeric
9b3f 9b3f d cd57a7
9b3f 9b3f s         CALL    TSTSGN          ; Test state of expression
9b42 9b42 d caa19a
9b42 9b42 s         JP      Z,REM           ; False - Drop through
9b45 9b45 d cd0599
9b45 9b45 s         CALL    GETCHR          ; Get next character
9b48 9b48 d da5c9a
9b48 9b48 s         JP      C,GOTO          ; Number - GOTO that line
9b4b 9b4b d c3ec98
9b4b 9b4b s         JP      IFJMP           ; Otherwise do statement
9b4e 9b4e s 
9b4e 9b4e d 2b
9b4e 9b4e s MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
9b4f 9b4f d cd0599
9b4f 9b4f s         CALL    GETCHR          ; Get next character
9b52 9b52 d cab09b
9b52 9b52 s PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
9b55 9b55 d c8
9b55 9b55 s PRNTLP: RET     Z               ; End of list - Exit
9b56 9b56 d fea5
9b56 9b56 s         CP      ZTAB            ; "TAB(" token?
9b58 9b58 d cae39b
9b58 9b58 s         JP      Z,DOTAB         ; Yes - Do TAB routine
9b5b 9b5b d fea8
9b5b 9b5b s         CP      ZSPC            ; "SPC(" token?
9b5d 9b5d d cae39b
9b5d 9b5d s         JP      Z,DOTAB         ; Yes - Do SPC routine
9b60 9b60 d e5
9b60 9b60 s         PUSH    HL              ; Save code string address
9b61 9b61 d fe2c
9b61 9b61 s         CP      ','             ; Comma?
9b63 9b63 d cacc9b
9b63 9b63 s         JP      Z,DOCOM         ; Yes - Move to next zone
9b66 9b66 d fe3b
9b66 9b66 s         CP      59 ;";"         ; Semi-colon?
9b68 9b68 d ca069c
9b68 9b68 s         JP      Z,NEXITM        ; Do semi-colon routine
9b6b 9b6b d c1
9b6b 9b6b s         POP     BC              ; Code string address to BC
9b6c 9b6c d cd879d
9b6c 9b6c s         CALL    EVAL            ; Evaluate expression
9b6f 9b6f d e5
9b6f 9b6f s         PUSH    HL              ; Save code string address
9b70 9b70 d 3af2b0
9b70 9b70 s         LD      A,(TYPE)        ; Get variable type
9b73 9b73 d b7
9b73 9b73 s         OR      A               ; Is it a string variable?
9b74 9b74 d c29c9b
9b74 9b74 s         JP      NZ,PRNTST       ; Yes - Output string contents
9b77 9b77 d cdfca8
9b77 9b77 s         CALL    NUMASC          ; Convert number to text
9b7a 9b7a d cd0ca2
9b7a 9b7a s         CALL    CRTST           ; Create temporary string
9b7d 9b7d d 3620
9b7d 9b7d s         LD      (HL),' '        ; Followed by a space
9b7f 9b7f d 2a29b1
9b7f 9b7f s         LD      HL,(FPREG)      ; Get length of output
9b82 9b82 d 34
9b82 9b82 s         INC     (HL)            ; Plus 1 for the space
9b83 9b83 d 2a29b1
9b83 9b83 s         LD      HL,(FPREG)      ; < Not needed >
9b86 9b86 d 3a87b0
9b86 9b86 s         LD      A,(LWIDTH)      ; Get width of line
9b89 9b89 d 47
9b89 9b89 s         LD      B,A             ; To B
9b8a 9b8a d 04
9b8a 9b8a s         INC     B               ; Width 255 (No limit)?
9b8b 9b8b d ca989b
9b8b 9b8b s         JP      Z,PRNTNB        ; Yes - Output number string
9b8e 9b8e d 04
9b8e 9b8e s         INC     B               ; Adjust it
9b8f 9b8f d 3af0b0
9b8f 9b8f s         LD      A,(CURPOS)      ; Get cursor position
9b92 9b92 d 86
9b92 9b92 s         ADD     A,(HL)          ; Add length of string
9b93 9b93 d 3d
9b93 9b93 s         DEC     A               ; Adjust it
9b94 9b94 d b8
9b94 9b94 s         CP      B               ; Will output fit on this line?
9b95 9b95 d d4b09b
9b95 9b95 s         CALL    NC,PRNTCRLF     ; No - CRLF first
9b98 9b98 d cd51a2
9b98 9b98 s PRNTNB: CALL    PRS1            ; Output string at (HL)
9b9b 9b9b d af
9b9b 9b9b s         XOR     A               ; Skip CALL by setting 'z' flag
9b9c 9b9c d c451a2
9b9c 9b9c s PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
9b9f 9b9f d e1
9b9f 9b9f s         POP     HL              ; Restore code string address
9ba0 9ba0 d c34e9b
9ba0 9ba0 s         JP      MRPRNT          ; See if more to PRINT
9ba3 9ba3 s 
9ba3 9ba3 d 3af0b0
9ba3 9ba3 s STTLIN: LD      A,(CURPOS)      ; Make sure on new line
9ba6 9ba6 d b7
9ba6 9ba6 s         OR      A               ; Already at start?
9ba7 9ba7 d c8
9ba7 9ba7 s         RET     Z               ; Yes - Do nothing
9ba8 9ba8 d c3b09b
9ba8 9ba8 s         JP      PRNTCRLF        ; Start a new line
9bab 9bab s 
9bab 9bab d 3600
9bab 9bab s ENDINP: LD      (HL),0          ; Mark end of buffer
9bad 9bad d 21a5b0
9bad 9bad s         LD      HL,BUFFER-1     ; Point to buffer
9bb0 9bb0 d 3e0d
9bb0 9bb0 s PRNTCRLF: LD    A,CR            ; Load a CR
9bb2 9bb2 d cd8697
9bb2 9bb2 s         CALL    OUTC            ; Output character
9bb5 9bb5 d 3e0a
9bb5 9bb5 s         LD      A,LF            ; Load a LF
9bb7 9bb7 d cd8697
9bb7 9bb7 s         CALL    OUTC            ; Output character
9bba 9bba d af
9bba 9bba s DONULL: XOR     A               ; Set to position 0
9bbb 9bbb d 32f0b0
9bbb 9bbb s         LD      (CURPOS),A      ; Store it
9bbe 9bbe d 3a86b0
9bbe 9bbe s         LD      A,(NULLS)       ; Get number of nulls
9bc1 9bc1 d 3d
9bc1 9bc1 s NULLP:  DEC     A               ; Count them
9bc2 9bc2 d c8
9bc2 9bc2 s         RET     Z               ; Return if done
9bc3 9bc3 d f5
9bc3 9bc3 s         PUSH    AF              ; Save count
9bc4 9bc4 d af
9bc4 9bc4 s         XOR     A               ; Load a null
9bc5 9bc5 d cd8697
9bc5 9bc5 s         CALL    OUTC            ; Output it
9bc8 9bc8 d f1
9bc8 9bc8 s         POP     AF              ; Restore count
9bc9 9bc9 d c3c19b
9bc9 9bc9 s         JP      NULLP           ; Keep counting
9bcc 9bcc s 
9bcc 9bcc d 3a88b0
9bcc 9bcc s DOCOM:  LD      A,(COMMAN)      ; Get comma width
9bcf 9bcf d 47
9bcf 9bcf s         LD      B,A             ; Save in B
9bd0 9bd0 d 3af0b0
9bd0 9bd0 s         LD      A,(CURPOS)      ; Get current position
9bd3 9bd3 d b8
9bd3 9bd3 s         CP      B               ; Within the limit?
9bd4 9bd4 d d4b09b
9bd4 9bd4 s         CALL    NC,PRNTCRLF     ; No - output CRLF
9bd7 9bd7 d d2069c
9bd7 9bd7 s         JP      NC,NEXITM       ; Get next item
9bda 9bda d d60e
9bda 9bda s ZONELP: SUB     14              ; Next zone of 14 characters
9bdc 9bdc d d2da9b
9bdc 9bdc s         JP      NC,ZONELP       ; Repeat if more zones
9bdf 9bdf d 2f
9bdf 9bdf s         CPL                     ; Number of spaces to output
9be0 9be0 d c3fb9b
9be0 9be0 s         JP      ASPCS           ; Output them
9be3 9be3 s 
9be3 9be3 d f5
9be3 9be3 s DOTAB:  PUSH    AF              ; Save token
9be4 9be4 d cdd3a4
9be4 9be4 s         CALL    FNDNUM          ; Evaluate expression
9be7 9be7 d cd7b97
9be7 9be7 s         CALL    CHKSYN          ; Make sure ")" follows
9bea 9bea d 29
9bea 9bea s         .BYTE   ")"
9beb 9beb d 2b
9beb 9beb s         DEC     HL              ; Back space on to ")"
9bec 9bec d f1
9bec 9bec s         POP     AF              ; Restore token
9bed 9bed d d6a8
9bed 9bed s         SUB     ZSPC            ; Was it "SPC(" ?
9bef 9bef d e5
9bef 9bef s         PUSH    HL              ; Save code string address
9bf0 9bf0 d caf69b
9bf0 9bf0 s         JP      Z,DOSPC         ; Yes - Do 'E' spaces
9bf3 9bf3 d 3af0b0
9bf3 9bf3 s         LD      A,(CURPOS)      ; Get current position
9bf6 9bf6 d 2f
9bf6 9bf6 s DOSPC:  CPL                     ; Number of spaces to print to
9bf7 9bf7 d 83
9bf7 9bf7 s         ADD     A,E             ; Total number to print
9bf8 9bf8 d d2069c
9bf8 9bf8 s         JP      NC,NEXITM       ; TAB < Current POS(X)
9bfb 9bfb d 3c
9bfb 9bfb s ASPCS:  INC     A               ; Output A spaces
9bfc 9bfc d 47
9bfc 9bfc s         LD      B,A             ; Save number to print
9bfd 9bfd d 3e20
9bfd 9bfd s         LD      A,' '           ; Space
9bff 9bff d cd8697
9bff 9bff s SPCLP:  CALL    OUTC            ; Output character in A
9c02 9c02 d 05
9c02 9c02 s         DEC     B               ; Count them
9c03 9c03 d c2ff9b
9c03 9c03 s         JP      NZ,SPCLP        ; Repeat if more
9c06 9c06 d e1
9c06 9c06 s NEXITM: POP     HL              ; Restore code string address
9c07 9c07 d cd0599
9c07 9c07 s         CALL    GETCHR          ; Get next character
9c0a 9c0a d c3559b
9c0a 9c0a s         JP      PRNTLP          ; More to print
9c0d 9c0d s 
9c0d 9c0d d 3f5265646f2066726f6d2073746172740d0a00
9c0d 9c0d s REDO:   .BYTE   "?Redo from start",CR,LF,0
9c20 9c20 s 
9c20 9c20 d 3a12b1
9c20 9c20 s BADINP: LD      A,(READFG)      ; READ or INPUT?
9c23 9c23 d b7
9c23 9c23 s         OR      A
9c24 9c24 d c2a794
9c24 9c24 s         JP      NZ,DATSNR       ; READ - ?SN Error
9c27 9c27 d c1
9c27 9c27 s         POP     BC              ; Throw away code string addr
9c28 9c28 d 210d9c
9c28 9c28 s         LD      HL,REDO         ; "Redo from start" message
9c2b 9c2b d cd4ea2
9c2b 9c2b s         CALL    PRS             ; Output string
9c2e 9c2e d c3f895
9c2e 9c2e s         JP      DOAGN           ; Do last INPUT again
9c31 9c31 s 
9c31 9c31 d cdb9a1
9c31 9c31 s INPUT:  CALL    IDTEST          ; Test for illegal direct
9c34 9c34 d 7e
9c34 9c34 s         LD      A,(HL)          ; Get character after "INPUT"
9c35 9c35 d fe22
9c35 9c35 s         CP      '"'             ; Is there a prompt string?
9c37 9c37 d 3e00
9c37 9c37 s         LD      A,0             ; Clear A and leave flags
9c39 9c39 d 328ab0
9c39 9c39 s         LD      (CTLOFG),A      ; Enable output
9c3c 9c3c d c24b9c
9c3c 9c3c s         JP      NZ,NOPMPT       ; No prompt - get input
9c3f 9c3f d cd0da2
9c3f 9c3f s         CALL    QTSTR           ; Get string terminated by '"'
9c42 9c42 d cd7b97
9c42 9c42 s         CALL    CHKSYN          ; Check for ';' after prompt
9c45 9c45 d 3b
9c45 9c45 s         .BYTE   ';'
9c46 9c46 d e5
9c46 9c46 s         PUSH    HL              ; Save code string address
9c47 9c47 d cd51a2
9c47 9c47 s         CALL    PRS1            ; Output prompt string
9c4a 9c4a d 3e
9c4a 9c4a s         .BYTE   3EH             ; Skip "PUSH HL"
9c4b 9c4b d e5
9c4b 9c4b s NOPMPT: PUSH    HL              ; Save code string address
9c4c 9c4c d cdfc95
9c4c 9c4c s         CALL    PROMPT          ; Get input with "? " prompt
9c4f 9c4f d c1
9c4f 9c4f s         POP     BC              ; Restore code string address
9c50 9c50 d da5799
9c50 9c50 s         JP      C,INPBRK        ; Break pressed - Exit
9c53 9c53 d 23
9c53 9c53 s         INC     HL              ; Next byte
9c54 9c54 d 7e
9c54 9c54 s         LD      A,(HL)          ; Get it
9c55 9c55 d b7
9c55 9c55 s         OR      A               ; End of line?
9c56 9c56 d 2b
9c56 9c56 s         DEC     HL              ; Back again
9c57 9c57 d c5
9c57 9c57 s         PUSH    BC              ; Re-save code string address
9c58 9c58 d ca9e9a
9c58 9c58 s         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
9c5b 9c5b d 362c
9c5b 9c5b s         LD      (HL),','        ; Store comma as separator
9c5d 9c5d d c3659c
9c5d 9c5d s         JP      NXTITM          ; Get next item
9c60 9c60 s 
9c60 9c60 d e5
9c60 9c60 s READ:   PUSH    HL              ; Save code string address
9c61 9c61 d 2a21b1
9c61 9c61 s         LD      HL,(NXTDAT)     ; Next DATA statement
9c64 9c64 d f6
9c64 9c64 s         .BYTE   0F6H            ; Flag "READ"
9c65 9c65 d af
9c65 9c65 s NXTITM: XOR     A               ; Flag "INPUT"
9c66 9c66 d 3212b1
9c66 9c66 s         LD      (READFG),A      ; Save "READ"/"INPUT" flag
9c69 9c69 d e3
9c69 9c69 s         EX      (SP),HL         ; Get code str' , Save pointer
9c6a 9c6a d c3719c
9c6a 9c6a s         JP      GTVLUS          ; Get values
9c6d 9c6d s 
9c6d 9c6d d cd7b97
9c6d 9c6d s NEDMOR: CALL    CHKSYN          ; Check for comma between items
9c70 9c70 d 2c
9c70 9c70 s         .BYTE      ','
9c71 9c71 d cd6b9f
9c71 9c71 s GTVLUS: CALL    GETVAR          ; Get variable name
9c74 9c74 d e3
9c74 9c74 s         EX      (SP),HL         ; Save code str" , Get pointer
9c75 9c75 d d5
9c75 9c75 s         PUSH    DE              ; Save variable address
9c76 9c76 d 7e
9c76 9c76 s         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
9c77 9c77 d fe2c
9c77 9c77 s         CP      ','             ; Comma?
9c79 9c79 d ca999c
9c79 9c79 s         JP      Z,ANTVLU        ; Yes - Get another value
9c7c 9c7c d 3a12b1
9c7c 9c7c s         LD      A,(READFG)      ; Is it READ?
9c7f 9c7f d b7
9c7f 9c7f s         OR      A
9c80 9c80 d c2069d
9c80 9c80 s         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
9c83 9c83 d 3e3f
9c83 9c83 s         LD      A,'?'           ; More INPUT needed
9c85 9c85 d cd8697
9c85 9c85 s         CALL    OUTC            ; Output character
9c88 9c88 d cdfc95
9c88 9c88 s         CALL    PROMPT          ; Get INPUT with prompt
9c8b 9c8b d d1
9c8b 9c8b s         POP     DE              ; Variable address
9c8c 9c8c d c1
9c8c 9c8c s         POP     BC              ; Code string address
9c8d 9c8d d da5799
9c8d 9c8d s         JP      C,INPBRK        ; Break pressed
9c90 9c90 d 23
9c90 9c90 s         INC     HL              ; Point to next DATA byte
9c91 9c91 d 7e
9c91 9c91 s         LD      A,(HL)          ; Get byte
9c92 9c92 d b7
9c92 9c92 s         OR      A               ; Is it zero (No input) ?
9c93 9c93 d 2b
9c93 9c93 s         DEC     HL              ; Back space INPUT pointer
9c94 9c94 d c5
9c94 9c94 s         PUSH    BC              ; Save code string address
9c95 9c95 d ca9e9a
9c95 9c95 s         JP      Z,NXTDTA        ; Find end of buffer
9c98 9c98 d d5
9c98 9c98 s         PUSH    DE              ; Save variable address
9c99 9c99 d 3af2b0
9c99 9c99 s ANTVLU: LD      A,(TYPE)        ; Check data type
9c9c 9c9c d b7
9c9c 9c9c s         OR      A               ; Is it numeric?
9c9d 9c9d d cac39c
9c9d 9c9d s         JP      Z,INPBIN        ; Yes - Convert to binary
9ca0 9ca0 d cd0599
9ca0 9ca0 s         CALL    GETCHR          ; Get next character
9ca3 9ca3 d 57
9ca3 9ca3 s         LD      D,A             ; Save input character
9ca4 9ca4 d 47
9ca4 9ca4 s         LD      B,A             ; Again
9ca5 9ca5 d fe22
9ca5 9ca5 s         CP      '"'             ; Start of literal sting?
9ca7 9ca7 d cab79c
9ca7 9ca7 s         JP      Z,STRENT        ; Yes - Create string entry
9caa 9caa d 3a12b1
9caa 9caa s         LD      A,(READFG)      ; "READ" or "INPUT" ?
9cad 9cad d b7
9cad 9cad s         OR      A
9cae 9cae d 57
9cae 9cae s         LD      D,A             ; Save 00 if "INPUT"
9caf 9caf d cab49c
9caf 9caf s         JP      Z,ITMSEP        ; "INPUT" - End with 00
9cb2 9cb2 d 163a
9cb2 9cb2 s         LD      D,':'           ; "DATA" - End with 00 or ':'
9cb4 9cb4 d 062c
9cb4 9cb4 s ITMSEP: LD      B,','           ; Item separator
9cb6 9cb6 d 2b
9cb6 9cb6 s         DEC     HL              ; Back space for DTSTR
9cb7 9cb7 d cd10a2
9cb7 9cb7 s STRENT: CALL    DTSTR           ; Get string terminated by D
9cba 9cba d eb
9cba 9cba s         EX      DE,HL           ; String address to DE
9cbb 9cbb d 21ce9c
9cbb 9cbb s         LD      HL,LTSTND       ; Where to go after LETSTR
9cbe 9cbe d e3
9cbe 9cbe s         EX      (SP),HL         ; Save HL , get input pointer
9cbf 9cbf d d5
9cbf 9cbf s         PUSH    DE              ; Save address of string
9cc0 9cc0 d c3d19a
9cc0 9cc0 s         JP      LETSTR          ; Assign string to variable
9cc3 9cc3 s 
9cc3 9cc3 d cd0599
9cc3 9cc3 s INPBIN: CALL    GETCHR          ; Get next character
9cc6 9cc6 d cd5ea8
9cc6 9cc6 s         CALL    ASCTFP          ; Convert ASCII to FP number
9cc9 9cc9 d e3
9cc9 9cc9 s         EX      (SP),HL         ; Save input ptr, Get var addr
9cca 9cca d cdafa7
9cca 9cca s         CALL    FPTHL           ; Move FPREG to variable
9ccd 9ccd d e1
9ccd 9ccd s         POP     HL              ; Restore input pointer
9cce 9cce d 2b
9cce 9cce s LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
9ccf 9ccf d cd0599
9ccf 9ccf s         CALL    GETCHR          ; Get next character
9cd2 9cd2 d cada9c
9cd2 9cd2 s         JP      Z,MORDT         ; End of line - More needed?
9cd5 9cd5 d fe2c
9cd5 9cd5 s         CP      ','             ; Another value?
9cd7 9cd7 d c2209c
9cd7 9cd7 s         JP      NZ,BADINP       ; No - Bad input
9cda 9cda d e3
9cda 9cda s MORDT:  EX      (SP),HL         ; Get code string address
9cdb 9cdb d 2b
9cdb 9cdb s         DEC     HL              ; DEC 'cos GETCHR INCs
9cdc 9cdc d cd0599
9cdc 9cdc s         CALL    GETCHR          ; Get next character
9cdf 9cdf d c26d9c
9cdf 9cdf s         JP      NZ,NEDMOR       ; More needed - Get it
9ce2 9ce2 d d1
9ce2 9ce2 s         POP     DE              ; Restore DATA pointer
9ce3 9ce3 d 3a12b1
9ce3 9ce3 s         LD      A,(READFG)      ; "READ" or "INPUT" ?
9ce6 9ce6 d b7
9ce6 9ce6 s         OR      A
9ce7 9ce7 d eb
9ce7 9ce7 s         EX      DE,HL           ; DATA pointer to HL
9ce8 9ce8 d c22b99
9ce8 9ce8 s         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
9ceb 9ceb d d5
9ceb 9ceb s         PUSH    DE              ; Save code string address
9cec 9cec d b6
9cec 9cec s         OR      (HL)            ; More input given?
9ced 9ced d 21f59c
9ced 9ced s         LD      HL,EXTIG        ; "?Extra ignored" message
9cf0 9cf0 d c44ea2
9cf0 9cf0 s         CALL    NZ,PRS          ; Output string if extra given
9cf3 9cf3 d e1
9cf3 9cf3 s         POP     HL              ; Restore code string address
9cf4 9cf4 d c9
9cf4 9cf4 s         RET
9cf5 9cf5 s 
9cf5 9cf5 d 3f45787472612069676e6f7265640d0a00
9cf5 9cf5 s EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
9d06 9d06 s 
9d06 9d06 d cd9f9a
9d06 9d06 s FDTLP:  CALL    DATA            ; Get next statement
9d09 9d09 d b7
9d09 9d09 s         OR      A               ; End of line?
9d0a 9d0a d c21f9d
9d0a 9d0a s         JP      NZ,FANDT        ; No - See if DATA statement
9d0d 9d0d d 23
9d0d 9d0d s         INC     HL
9d0e 9d0e d 7e
9d0e 9d0e s         LD      A,(HL)          ; End of program?
9d0f 9d0f d 23
9d0f 9d0f s         INC     HL
9d10 9d10 d b6
9d10 9d10 s         OR      (HL)            ; 00 00 Ends program
9d11 9d11 d 1e06
9d11 9d11 s         LD      E,OD            ; ?OD Error
9d13 9d13 d cac194
9d13 9d13 s         JP      Z,ERROR         ; Yes - Out of DATA
9d16 9d16 d 23
9d16 9d16 s         INC     HL
9d17 9d17 d 5e
9d17 9d17 s         LD      E,(HL)          ; LSB of line number
9d18 9d18 d 23
9d18 9d18 s         INC     HL
9d19 9d19 d 56
9d19 9d19 s         LD      D,(HL)          ; MSB of line number
9d1a 9d1a d eb
9d1a 9d1a s         EX      DE,HL
9d1b 9d1b d 220eb1
9d1b 9d1b s         LD      (DATLIN),HL     ; Set line of current DATA item
9d1e 9d1e d eb
9d1e 9d1e s         EX      DE,HL
9d1f 9d1f d cd0599
9d1f 9d1f s FANDT:  CALL    GETCHR          ; Get next character
9d22 9d22 d fe83
9d22 9d22 s         CP      ZDATA           ; "DATA" token
9d24 9d24 d c2069d
9d24 9d24 s         JP      NZ,FDTLP        ; No "DATA" - Keep looking
9d27 9d27 d c3999c
9d27 9d27 s         JP      ANTVLU          ; Found - Convert input
9d2a 9d2a s 
9d2a 9d2a d 110000
9d2a 9d2a s NEXT:   LD      DE,0            ; In case no index given
9d2d 9d2d d c46b9f
9d2d 9d2d s NEXT1:  CALL    NZ,GETVAR       ; Get index address
9d30 9d30 d 2213b1
9d30 9d30 s         LD      (BRKLIN),HL     ; Save code string address
9d33 9d33 d cd5694
9d33 9d33 s         CALL    BAKSTK          ; Look for "FOR" block
9d36 9d36 d c2b394
9d36 9d36 s         JP      NZ,NFERR        ; No "FOR" - ?NF Error
9d39 9d39 d f9
9d39 9d39 s         LD      SP,HL           ; Clear nested loops
9d3a 9d3a d d5
9d3a 9d3a s         PUSH    DE              ; Save index address
9d3b 9d3b d 7e
9d3b 9d3b s         LD      A,(HL)          ; Get sign of STEP
9d3c 9d3c d 23
9d3c 9d3c s         INC     HL
9d3d 9d3d d f5
9d3d 9d3d s         PUSH    AF              ; Save sign of STEP
9d3e 9d3e d d5
9d3e 9d3e s         PUSH    DE              ; Save index address
9d3f 9d3f d cd95a7
9d3f 9d3f s         CALL    PHLTFP          ; Move index value to FPREG
9d42 9d42 d e3
9d42 9d42 s         EX      (SP),HL         ; Save address of TO value
9d43 9d43 d e5
9d43 9d43 s         PUSH    HL              ; Save address of index
9d44 9d44 d cd02a5
9d44 9d44 s         CALL    ADDPHL          ; Add STEP to index value
9d47 9d47 d e1
9d47 9d47 s         POP     HL              ; Restore address of index
9d48 9d48 d cdafa7
9d48 9d48 s         CALL    FPTHL           ; Move value to index variable
9d4b 9d4b d e1
9d4b 9d4b s         POP     HL              ; Restore address of TO value
9d4c 9d4c d cda6a7
9d4c 9d4c s         CALL    LOADFP          ; Move TO value to BCDE
9d4f 9d4f d e5
9d4f 9d4f s         PUSH    HL              ; Save address of line of FOR
9d50 9d50 d cdd2a7
9d50 9d50 s         CALL    CMPNUM          ; Compare index with TO value
9d53 9d53 d e1
9d53 9d53 s         POP     HL              ; Restore address of line num
9d54 9d54 d c1
9d54 9d54 s         POP     BC              ; Address of sign of STEP
9d55 9d55 d 90
9d55 9d55 s         SUB     B               ; Compare with expected sign
9d56 9d56 d cda6a7
9d56 9d56 s         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
9d59 9d59 d ca659d
9d59 9d59 s         JP      Z,KILFOR        ; Loop finished - Terminate it
9d5c 9d5c d eb
9d5c 9d5c s         EX      DE,HL           ; Loop statement line number
9d5d 9d5d d 22a1b0
9d5d 9d5d s         LD      (LINEAT),HL     ; Set loop line number
9d60 9d60 d 69
9d60 9d60 s         LD      L,C             ; Set code string to loop
9d61 9d61 d 60
9d61 9d61 s         LD      H,B
9d62 9d62 d c3c198
9d62 9d62 s         JP      PUTFID          ; Put back "FOR" and continue
9d65 9d65 s 
9d65 9d65 d f9
9d65 9d65 s KILFOR: LD      SP,HL           ; Remove "FOR" block
9d66 9d66 d 2a13b1
9d66 9d66 s         LD      HL,(BRKLIN)     ; Code string after "NEXT"
9d69 9d69 d 7e
9d69 9d69 s         LD      A,(HL)          ; Get next byte in code string
9d6a 9d6a d fe2c
9d6a 9d6a s         CP      ','             ; More NEXTs ?
9d6c 9d6c d c2c598
9d6c 9d6c s         JP      NZ,RUNCNT       ; No - Do next statement
9d6f 9d6f d cd0599
9d6f 9d6f s         CALL    GETCHR          ; Position to index name
9d72 9d72 d cd2d9d
9d72 9d72 s         CALL    NEXT1           ; Re-enter NEXT routine
9d75 9d75 s ; < will not RETurn to here , Exit to RUNCNT or Loop >
9d75 9d75 s 
9d75 9d75 d cd879d
9d75 9d75 s GETNUM: CALL    EVAL            ; Get a numeric expression
9d78 9d78 d f6
9d78 9d78 s TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
9d79 9d79 d 37
9d79 9d79 s TSTSTR: SCF                     ; Set carry (string)
9d7a 9d7a d 3af2b0
9d7a 9d7a s CHKTYP: LD      A,(TYPE)        ; Check types match
9d7d 9d7d d 8f
9d7d 9d7d s         ADC     A,A             ; Expected + actual
9d7e 9d7e d b7
9d7e 9d7e s         OR      A               ; Clear carry , set parity
9d7f 9d7f d e8
9d7f 9d7f s         RET     PE              ; Even parity - Types match
9d80 9d80 d c3bf94
9d80 9d80 s         JP      TMERR           ; Different types - Error
9d83 9d83 s 
9d83 9d83 d cd7b97
9d83 9d83 s OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
9d86 9d86 d 28
9d86 9d86 s         .BYTE   "("
9d87 9d87 d 2b
9d87 9d87 s EVAL:   DEC     HL              ; Evaluate expression & save
9d88 9d88 d 1600
9d88 9d88 s         LD      D,0             ; Precedence value
9d8a 9d8a d d5
9d8a 9d8a s EVAL1:  PUSH    DE              ; Save precedence
9d8b 9d8b d 0e01
9d8b 9d8b s         LD      C,1
9d8d 9d8d d cd8a94
9d8d 9d8d s         CALL    CHKSTK          ; Check for 1 level of stack
9d90 9d90 d cdfe9d
9d90 9d90 s         CALL    OPRND           ; Get next expression value
9d93 9d93 d 2215b1
9d93 9d93 s EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
9d96 9d96 d 2a15b1
9d96 9d96 s EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
9d99 9d99 d c1
9d99 9d99 s         POP     BC              ; Precedence value and operator
9d9a 9d9a d 78
9d9a 9d9a s         LD      A,B             ; Get precedence value
9d9b 9d9b d fe78
9d9b 9d9b s         CP      78H             ; "AND" or "OR" ?
9d9d 9d9d d d4789d
9d9d 9d9d s         CALL    NC,TSTNUM       ; No - Make sure it's a number
9da0 9da0 d 7e
9da0 9da0 s         LD      A,(HL)          ; Get next operator / function
9da1 9da1 d 1600
9da1 9da1 s         LD      D,0             ; Clear Last relation
9da3 9da3 d d6b3
9da3 9da3 s RLTLP:  SUB     ZGTR            ; ">" Token
9da5 9da5 d dabf9d
9da5 9da5 s         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
9da8 9da8 d fe03
9da8 9da8 s         CP      ZLTH+1-ZGTR     ; < = >
9daa 9daa d d2bf9d
9daa 9daa s         JP      NC,FOPRND       ; Function - Call it
9dad 9dad d fe01
9dad 9dad s         CP      ZEQUAL-ZGTR     ; "="
9daf 9daf d 17
9daf 9daf s         RLA                     ; <- Test for legal
9db0 9db0 d aa
9db0 9db0 s         XOR     D               ; <- combinations of < = >
9db1 9db1 d ba
9db1 9db1 s         CP      D               ; <- by combining last token
9db2 9db2 d 57
9db2 9db2 s         LD      D,A             ; <- with current one
9db3 9db3 d daad94
9db3 9db3 s         JP      C,SNERR         ; Error if "<<' '==" or ">>"
9db6 9db6 d 220ab1
9db6 9db6 s         LD      (CUROPR),HL     ; Save address of current token
9db9 9db9 d cd0599
9db9 9db9 s         CALL    GETCHR          ; Get next character
9dbc 9dbc d c3a39d
9dbc 9dbc s         JP      RLTLP           ; Treat the two as one
9dbf 9dbf s 
9dbf 9dbf d 7a
9dbf 9dbf s FOPRND: LD      A,D             ; < = > found ?
9dc0 9dc0 d b7
9dc0 9dc0 s         OR      A
9dc1 9dc1 d c2e69e
9dc1 9dc1 s         JP      NZ,TSTRED       ; Yes - Test for reduction
9dc4 9dc4 d 7e
9dc4 9dc4 s         LD      A,(HL)          ; Get operator token
9dc5 9dc5 d 220ab1
9dc5 9dc5 s         LD      (CUROPR),HL     ; Save operator address
9dc8 9dc8 d d6ac
9dc8 9dc8 s         SUB     ZPLUS           ; Operator or function?
9dca 9dca d d8
9dca 9dca s         RET     C               ; Neither - Exit
9dcb 9dcb d fe07
9dcb 9dcb s         CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
9dcd 9dcd d d0
9dcd 9dcd s         RET     NC              ; No - Exit
9dce 9dce d 5f
9dce 9dce s         LD      E,A             ; Coded operator
9dcf 9dcf d 3af2b0
9dcf 9dcf s         LD      A,(TYPE)        ; Get data type
9dd2 9dd2 d 3d
9dd2 9dd2 s         DEC     A               ; FF = numeric , 00 = string
9dd3 9dd3 d b3
9dd3 9dd3 s         OR      E               ; Combine with coded operator
9dd4 9dd4 d 7b
9dd4 9dd4 s         LD      A,E             ; Get coded operator
9dd5 9dd5 d ca44a3
9dd5 9dd5 s         JP      Z,CONCAT        ; String concatenation
9dd8 9dd8 d 07
9dd8 9dd8 s         RLCA                    ; Times 2
9dd9 9dd9 d 83
9dd9 9dd9 s         ADD     A,E             ; Times 3
9dda 9dda d 5f
9dda 9dda s         LD      E,A             ; To DE (D is 0)
9ddb 9ddb d 219f93
9ddb 9ddb s         LD      HL,PRITAB       ; Precedence table
9dde 9dde d 19
9dde 9dde s         ADD     HL,DE           ; To the operator concerned
9ddf 9ddf d 78
9ddf 9ddf s         LD      A,B             ; Last operator precedence
9de0 9de0 d 56
9de0 9de0 s         LD      D,(HL)          ; Get evaluation precedence
9de1 9de1 d ba
9de1 9de1 s         CP      D               ; Compare with eval precedence
9de2 9de2 d d0
9de2 9de2 s         RET     NC              ; Exit if higher precedence
9de3 9de3 d 23
9de3 9de3 s         INC     HL              ; Point to routine address
9de4 9de4 d cd789d
9de4 9de4 s         CALL    TSTNUM          ; Make sure it's a number
9de7 9de7 s 
9de7 9de7 d c5
9de7 9de7 s STKTHS: PUSH    BC              ; Save last precedence & token
9de8 9de8 d 01969d
9de8 9de8 s         LD      BC,EVAL3        ; Where to go on prec' break
9deb 9deb d c5
9deb 9deb s         PUSH    BC              ; Save on stack for return
9dec 9dec d 43
9dec 9dec s         LD      B,E             ; Save operator
9ded 9ded d 4a
9ded 9ded s         LD      C,D             ; Save precedence
9dee 9dee d cd88a7
9dee 9dee s         CALL    STAKFP          ; Move value to stack
9df1 9df1 d 58
9df1 9df1 s         LD      E,B             ; Restore operator
9df2 9df2 d 51
9df2 9df2 s         LD      D,C             ; Restore precedence
9df3 9df3 d 4e
9df3 9df3 s         LD      C,(HL)          ; Get LSB of routine address
9df4 9df4 d 23
9df4 9df4 s         INC     HL
9df5 9df5 d 46
9df5 9df5 s         LD      B,(HL)          ; Get MSB of routine address
9df6 9df6 d 23
9df6 9df6 s         INC     HL
9df7 9df7 d c5
9df7 9df7 s         PUSH    BC              ; Save routine address
9df8 9df8 d 2a0ab1
9df8 9df8 s         LD      HL,(CUROPR)     ; Address of current operator
9dfb 9dfb d c38a9d
9dfb 9dfb s         JP      EVAL1           ; Loop until prec' break
9dfe 9dfe s 
9dfe 9dfe d af
9dfe 9dfe s OPRND:  XOR     A               ; Get operand routine
9dff 9dff d 32f2b0
9dff 9dff s         LD      (TYPE),A        ; Set numeric expected
9e02 9e02 d cd0599
9e02 9e02 s         CALL    GETCHR          ; Get next character
9e05 9e05 d 1e24
9e05 9e05 s         LD      E,MO            ; ?MO Error
9e07 9e07 d cac194
9e07 9e07 s         JP      Z,ERROR         ; No operand - Error
9e0a 9e0a d da5ea8
9e0a 9e0a s         JP      C,ASCTFP        ; Number - Get value
9e0d 9e0d d cda699
9e0d 9e0d s         CALL    CHKLTR          ; See if a letter
9e10 9e10 d d2659e
9e10 9e10 s         JP      NC,CONVAR       ; Letter - Find variable
9e13 9e13 d fe26
9e13 9e13 s         CP		'&'				; &H = HEX, &B = BINARY
9e15 9e15 d 2012
9e15 9e15 s         JR		NZ, NOTAMP
9e17 9e17 d cd0599
9e17 9e17 s         CALL    GETCHR          ; Get next character
9e1a 9e1a d fe48
9e1a 9e1a s         CP      'H'             ; Hex number indicated? [function added]
9e1c 9e1c d caa4ac
9e1c 9e1c s         JP      Z,HEXTFP        ; Convert Hex to FPREG
9e1f 9e1f d fe42
9e1f 9e1f s         CP      'B'             ; Binary number indicated? [function added]
9e21 9e21 d ca14ad
9e21 9e21 s         JP      Z,BINTFP        ; Convert Bin to FPREG
9e24 9e24 d 1e02
9e24 9e24 s         LD      E,SN            ; If neither then a ?SN Error
9e26 9e26 d cac194
9e26 9e26 s         JP      Z,ERROR         ; 
9e29 9e29 d feac
9e29 9e29 s NOTAMP: CP      ZPLUS           ; '+' Token ?
9e2b 9e2b d cafe9d
9e2b 9e2b s         JP      Z,OPRND         ; Yes - Look for operand
9e2e 9e2e d fe2e
9e2e 9e2e s         CP      '.'             ; '.' ?
9e30 9e30 d ca5ea8
9e30 9e30 s         JP      Z,ASCTFP        ; Yes - Create FP number
9e33 9e33 d fead
9e33 9e33 s         CP      ZMINUS          ; '-' Token ?
9e35 9e35 d ca549e
9e35 9e35 s         JP      Z,MINUS         ; Yes - Do minus
9e38 9e38 d fe22
9e38 9e38 s         CP      '"'             ; Literal string ?
9e3a 9e3a d ca0da2
9e3a 9e3a s         JP      Z,QTSTR         ; Get string terminated by '"'
9e3d 9e3d d feaa
9e3d 9e3d s         CP      ZNOT            ; "NOT" Token ?
9e3f 9e3f d ca469f
9e3f 9e3f s         JP      Z,EVNOT         ; Yes - Eval NOT expression
9e42 9e42 d fea7
9e42 9e42 s         CP      ZFN             ; "FN" Token ?
9e44 9e44 d ca71a1
9e44 9e44 s         JP      Z,DOFN          ; Yes - Do FN routine
9e47 9e47 d d6b6
9e47 9e47 s         SUB     ZSGN            ; Is it a function?
9e49 9e49 d d2769e
9e49 9e49 s         JP      NC,FNOFST       ; Yes - Evaluate function
9e4c 9e4c d cd839d
9e4c 9e4c s EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
9e4f 9e4f d cd7b97
9e4f 9e4f s         CALL    CHKSYN          ; Make sure ")" follows
9e52 9e52 d 29
9e52 9e52 s         .BYTE   ")"
9e53 9e53 d c9
9e53 9e53 s         RET
9e54 9e54 s 
9e54 9e54 d 167d
9e54 9e54 s MINUS:  LD      D,7DH           ; '-' precedence
9e56 9e56 d cd8a9d
9e56 9e56 s         CALL    EVAL1           ; Evaluate until prec' break
9e59 9e59 d 2a15b1
9e59 9e59 s         LD      HL,(NXTOPR)     ; Get next operator address
9e5c 9e5c d e5
9e5c 9e5c s         PUSH    HL              ; Save next operator address
9e5d 9e5d d cd80a7
9e5d 9e5d s         CALL    INVSGN          ; Negate value
9e60 9e60 d cd789d
9e60 9e60 s RETNUM: CALL    TSTNUM          ; Make sure it's a number
9e63 9e63 d e1
9e63 9e63 s         POP     HL              ; Restore next operator address
9e64 9e64 d c9
9e64 9e64 s         RET
9e65 9e65 s 
9e65 9e65 d cd6b9f
9e65 9e65 s CONVAR: CALL    GETVAR          ; Get variable address to DE
9e68 9e68 d e5
9e68 9e68 s FRMEVL: PUSH    HL              ; Save code string address
9e69 9e69 d eb
9e69 9e69 s         EX      DE,HL           ; Variable address to HL
9e6a 9e6a d 2229b1
9e6a 9e6a s         LD      (FPREG),HL      ; Save address of variable
9e6d 9e6d d 3af2b0
9e6d 9e6d s         LD      A,(TYPE)        ; Get type
9e70 9e70 d b7
9e70 9e70 s         OR      A               ; Numeric?
9e71 9e71 d cc95a7
9e71 9e71 s         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
9e74 9e74 d e1
9e74 9e74 s         POP     HL              ; Restore code string address
9e75 9e75 d c9
9e75 9e75 s         RET
9e76 9e76 s 
9e76 9e76 d 0600
9e76 9e76 s FNOFST: LD      B,0             ; Get address of function
9e78 9e78 d 07
9e78 9e78 s         RLCA                    ; Double function offset
9e79 9e79 d 4f
9e79 9e79 s         LD      C,A             ; BC = Offset in function table
9e7a 9e7a d c5
9e7a 9e7a s         PUSH    BC              ; Save adjusted token value
9e7b 9e7b d cd0599
9e7b 9e7b s         CALL    GETCHR          ; Get next character
9e7e 9e7e d 79
9e7e 9e7e s         LD      A,C             ; Get adjusted token value
9e7f 9e7f d fe31
9e7f 9e7f s         CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
9e81 9e81 d da9d9e
9e81 9e81 s         JP      C,FNVAL         ; No - Do function
9e84 9e84 d cd839d
9e84 9e84 s         CALL    OPNPAR          ; Evaluate expression  (X,...
9e87 9e87 d cd7b97
9e87 9e87 s         CALL    CHKSYN          ; Make sure ',' follows
9e8a 9e8a d 2c
9e8a 9e8a s         .BYTE      ','
9e8b 9e8b d cd799d
9e8b 9e8b s         CALL    TSTSTR          ; Make sure it's a string
9e8e 9e8e d eb
9e8e 9e8e s         EX      DE,HL           ; Save code string address
9e8f 9e8f d 2a29b1
9e8f 9e8f s         LD      HL,(FPREG)      ; Get address of string
9e92 9e92 d e3
9e92 9e92 s         EX      (SP),HL         ; Save address of string
9e93 9e93 d e5
9e93 9e93 s         PUSH    HL              ; Save adjusted token value
9e94 9e94 d eb
9e94 9e94 s         EX      DE,HL           ; Restore code string address
9e95 9e95 d cdd6a4
9e95 9e95 s         CALL    GETINT          ; Get integer 0-255
9e98 9e98 d eb
9e98 9e98 s         EX      DE,HL           ; Save code string address
9e99 9e99 d e3
9e99 9e99 s         EX      (SP),HL         ; Save integer,HL = adj' token
9e9a 9e9a d c3a59e
9e9a 9e9a s         JP      GOFUNC          ; Jump to string function
9e9d 9e9d s 
9e9d 9e9d d cd4c9e
9e9d 9e9d s FNVAL:  CALL    EVLPAR          ; Evaluate expression
9ea0 9ea0 d e3
9ea0 9ea0 s         EX      (SP),HL         ; HL = Adjusted token value
9ea1 9ea1 d 11609e
9ea1 9ea1 s         LD      DE,RETNUM       ; Return number from function
9ea4 9ea4 d d5
9ea4 9ea4 s         PUSH    DE              ; Save on stack
9ea5 9ea5 d 01fe91
9ea5 9ea5 s GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
9ea8 9ea8 d 09
9ea8 9ea8 s         ADD     HL,BC           ; Point to right address
9ea9 9ea9 d 4e
9ea9 9ea9 s         LD      C,(HL)          ; Get LSB of address
9eaa 9eaa d 23
9eaa 9eaa s         INC     HL              ;
9eab 9eab d 66
9eab 9eab s         LD      H,(HL)          ; Get MSB of address
9eac 9eac d 69
9eac 9eac s         LD      L,C             ; Address to HL
9ead 9ead d e9
9ead 9ead s         JP      (HL)            ; Jump to function
9eae 9eae s 
9eae 9eae d 15
9eae 9eae s SGNEXP: DEC     D               ; Dee to flag negative exponent
9eaf 9eaf d fead
9eaf 9eaf s         CP      ZMINUS          ; '-' token ?
9eb1 9eb1 d c8
9eb1 9eb1 s         RET     Z               ; Yes - Return
9eb2 9eb2 d fe2d
9eb2 9eb2 s         CP      '-'             ; '-' ASCII ?
9eb4 9eb4 d c8
9eb4 9eb4 s         RET     Z               ; Yes - Return
9eb5 9eb5 d 14
9eb5 9eb5 s         INC     D               ; Inc to flag positive exponent
9eb6 9eb6 d fe2b
9eb6 9eb6 s         CP      '+'             ; '+' ASCII ?
9eb8 9eb8 d c8
9eb8 9eb8 s         RET     Z               ; Yes - Return
9eb9 9eb9 d feac
9eb9 9eb9 s         CP      ZPLUS           ; '+' token ?
9ebb 9ebb d c8
9ebb 9ebb s         RET     Z               ; Yes - Return
9ebc 9ebc d 2b
9ebc 9ebc s         DEC     HL              ; DEC 'cos GETCHR INCs
9ebd 9ebd d c9
9ebd 9ebd s         RET                     ; Return "NZ"
9ebe 9ebe s 
9ebe 9ebe d f6
9ebe 9ebe s POR:    .BYTE      0F6H            ; Flag "OR"
9ebf 9ebf d af
9ebf 9ebf s PAND:   XOR     A               ; Flag "AND"
9ec0 9ec0 d f5
9ec0 9ec0 s         PUSH    AF              ; Save "AND" / "OR" flag
9ec1 9ec1 d cd789d
9ec1 9ec1 s         CALL    TSTNUM          ; Make sure it's a number
9ec4 9ec4 d cdba99
9ec4 9ec4 s         CALL    DEINT           ; Get integer -32768 to 32767
9ec7 9ec7 d f1
9ec7 9ec7 s         POP     AF              ; Restore "AND" / "OR" flag
9ec8 9ec8 d eb
9ec8 9ec8 s         EX      DE,HL           ; <- Get last
9ec9 9ec9 d c1
9ec9 9ec9 s         POP     BC              ; <-  value
9eca 9eca d e3
9eca 9eca s         EX      (SP),HL         ; <-  from
9ecb 9ecb d eb
9ecb 9ecb s         EX      DE,HL           ; <-  stack
9ecc 9ecc d cd98a7
9ecc 9ecc s         CALL    FPBCDE          ; Move last value to FPREG
9ecf 9ecf d f5
9ecf 9ecf s         PUSH    AF              ; Save "AND" / "OR" flag
9ed0 9ed0 d cdba99
9ed0 9ed0 s         CALL    DEINT           ; Get integer -32768 to 32767
9ed3 9ed3 d f1
9ed3 9ed3 s         POP     AF              ; Restore "AND" / "OR" flag
9ed4 9ed4 d c1
9ed4 9ed4 s         POP     BC              ; Get value
9ed5 9ed5 d 79
9ed5 9ed5 s         LD      A,C             ; Get LSB
9ed6 9ed6 d 212fa1
9ed6 9ed6 s         LD      HL,ACPASS       ; Address of save AC as current
9ed9 9ed9 d c2e19e
9ed9 9ed9 s         JP      NZ,POR1         ; Jump if OR
9edc 9edc d a3
9edc 9edc s         AND     E               ; "AND" LSBs
9edd 9edd d 4f
9edd 9edd s         LD      C,A             ; Save LSB
9ede 9ede d 78
9ede 9ede s         LD      A,B             ; Get MBS
9edf 9edf d a2
9edf 9edf s         AND     D               ; "AND" MSBs
9ee0 9ee0 d e9
9ee0 9ee0 s         JP      (HL)            ; Save AC as current (ACPASS)
9ee1 9ee1 s 
9ee1 9ee1 d b3
9ee1 9ee1 s POR1:   OR      E               ; "OR" LSBs
9ee2 9ee2 d 4f
9ee2 9ee2 s         LD      C,A             ; Save LSB
9ee3 9ee3 d 78
9ee3 9ee3 s         LD      A,B             ; Get MSB
9ee4 9ee4 d b2
9ee4 9ee4 s         OR      D               ; "OR" MSBs
9ee5 9ee5 d e9
9ee5 9ee5 s         JP      (HL)            ; Save AC as current (ACPASS)
9ee6 9ee6 s 
9ee6 9ee6 d 21f89e
9ee6 9ee6 s TSTRED: LD      HL,CMPLOG       ; Logical compare routine
9ee9 9ee9 d 3af2b0
9ee9 9ee9 s         LD      A,(TYPE)        ; Get data type
9eec 9eec d 1f
9eec 9eec s         RRA                     ; Carry set = string
9eed 9eed d 7a
9eed 9eed s         LD      A,D             ; Get last precedence value
9eee 9eee d 17
9eee 9eee s         RLA                     ; Times 2 plus carry
9eef 9eef d 5f
9eef 9eef s         LD      E,A             ; To E
9ef0 9ef0 d 1664
9ef0 9ef0 s         LD      D,64H           ; Relational precedence
9ef2 9ef2 d 78
9ef2 9ef2 s         LD      A,B             ; Get current precedence
9ef3 9ef3 d ba
9ef3 9ef3 s         CP      D               ; Compare with last
9ef4 9ef4 d d0
9ef4 9ef4 s         RET     NC              ; Eval if last was rel' or log'
9ef5 9ef5 d c3e79d
9ef5 9ef5 s         JP      STKTHS          ; Stack this one and get next
9ef8 9ef8 s 
9ef8 9ef8 d fa9e
9ef8 9ef8 s CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
9efa 9efa d 79
9efa 9efa s CMPLG1: LD      A,C             ; Get data type
9efb 9efb d b7
9efb 9efb s         OR      A
9efc 9efc d 1f
9efc 9efc s         RRA
9efd 9efd d c1
9efd 9efd s         POP     BC              ; Get last expression to BCDE
9efe 9efe d d1
9efe 9efe s         POP     DE
9eff 9eff d f5
9eff 9eff s         PUSH    AF              ; Save status
9f00 9f00 d cd7a9d
9f00 9f00 s         CALL    CHKTYP          ; Check that types match
9f03 9f03 d 213c9f
9f03 9f03 s         LD      HL,CMPRES       ; Result to comparison
9f06 9f06 d e5
9f06 9f06 s         PUSH    HL              ; Save for RETurn
9f07 9f07 d cad2a7
9f07 9f07 s         JP      Z,CMPNUM        ; Compare values if numeric
9f0a 9f0a d af
9f0a 9f0a s         XOR     A               ; Compare two strings
9f0b 9f0b d 32f2b0
9f0b 9f0b s         LD      (TYPE),A        ; Set type to numeric
9f0e 9f0e d d5
9f0e 9f0e s         PUSH    DE              ; Save string name
9f0f 9f0f d cd91a3
9f0f 9f0f s         CALL    GSTRCU          ; Get current string
9f12 9f12 d 7e
9f12 9f12 s         LD      A,(HL)          ; Get length of string
9f13 9f13 d 23
9f13 9f13 s         INC     HL
9f14 9f14 d 23
9f14 9f14 s         INC     HL
9f15 9f15 d 4e
9f15 9f15 s         LD      C,(HL)          ; Get LSB of address
9f16 9f16 d 23
9f16 9f16 s         INC     HL
9f17 9f17 d 46
9f17 9f17 s         LD      B,(HL)          ; Get MSB of address
9f18 9f18 d d1
9f18 9f18 s         POP     DE              ; Restore string name
9f19 9f19 d c5
9f19 9f19 s         PUSH    BC              ; Save address of string
9f1a 9f1a d f5
9f1a 9f1a s         PUSH    AF              ; Save length of string
9f1b 9f1b d cd95a3
9f1b 9f1b s         CALL    GSTRDE          ; Get second string
9f1e 9f1e d cda6a7
9f1e 9f1e s         CALL    LOADFP          ; Get address of second string
9f21 9f21 d f1
9f21 9f21 s         POP     AF              ; Restore length of string 1
9f22 9f22 d 57
9f22 9f22 s         LD      D,A             ; Length to D
9f23 9f23 d e1
9f23 9f23 s         POP     HL              ; Restore address of string 1
9f24 9f24 d 7b
9f24 9f24 s CMPSTR: LD      A,E             ; Bytes of string 2 to do
9f25 9f25 d b2
9f25 9f25 s         OR      D               ; Bytes of string 1 to do
9f26 9f26 d c8
9f26 9f26 s         RET     Z               ; Exit if all bytes compared
9f27 9f27 d 7a
9f27 9f27 s         LD      A,D             ; Get bytes of string 1 to do
9f28 9f28 d d601
9f28 9f28 s         SUB     1
9f2a 9f2a d d8
9f2a 9f2a s         RET     C               ; Exit if end of string 1
9f2b 9f2b d af
9f2b 9f2b s         XOR     A
9f2c 9f2c d bb
9f2c 9f2c s         CP      E               ; Bytes of string 2 to do
9f2d 9f2d d 3c
9f2d 9f2d s         INC     A
9f2e 9f2e d d0
9f2e 9f2e s         RET     NC              ; Exit if end of string 2
9f2f 9f2f d 15
9f2f 9f2f s         DEC     D               ; Count bytes in string 1
9f30 9f30 d 1d
9f30 9f30 s         DEC     E               ; Count bytes in string 2
9f31 9f31 d 0a
9f31 9f31 s         LD      A,(BC)          ; Byte in string 2
9f32 9f32 d be
9f32 9f32 s         CP      (HL)            ; Compare to byte in string 1
9f33 9f33 d 23
9f33 9f33 s         INC     HL              ; Move up string 1
9f34 9f34 d 03
9f34 9f34 s         INC     BC              ; Move up string 2
9f35 9f35 d ca249f
9f35 9f35 s         JP      Z,CMPSTR        ; Same - Try next bytes
9f38 9f38 d 3f
9f38 9f38 s         CCF                     ; Flag difference (">" or "<")
9f39 9f39 d c362a7
9f39 9f39 s         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
9f3c 9f3c s 
9f3c 9f3c d 3c
9f3c 9f3c s CMPRES: INC     A               ; Increment current value
9f3d 9f3d d 8f
9f3d 9f3d s         ADC     A,A             ; Double plus carry
9f3e 9f3e d c1
9f3e 9f3e s         POP     BC              ; Get other value
9f3f 9f3f d a0
9f3f 9f3f s         AND     B               ; Combine them
9f40 9f40 d c6ff
9f40 9f40 s         ADD     A,-1            ; Carry set if different
9f42 9f42 d 9f
9f42 9f42 s         SBC     A,A             ; 00 - Equal , FF - Different
9f43 9f43 d c369a7
9f43 9f43 s         JP      FLGREL          ; Set current value & continue
9f46 9f46 s 
9f46 9f46 d 165a
9f46 9f46 s EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
9f48 9f48 d cd8a9d
9f48 9f48 s         CALL    EVAL1           ; Eval until precedence break
9f4b 9f4b d cd789d
9f4b 9f4b s         CALL    TSTNUM          ; Make sure it's a number
9f4e 9f4e d cdba99
9f4e 9f4e s         CALL    DEINT           ; Get integer -32768 - 32767
9f51 9f51 d 7b
9f51 9f51 s         LD      A,E             ; Get LSB
9f52 9f52 d 2f
9f52 9f52 s         CPL                     ; Invert LSB
9f53 9f53 d 4f
9f53 9f53 s         LD      C,A             ; Save "NOT" of LSB
9f54 9f54 d 7a
9f54 9f54 s         LD      A,D             ; Get MSB
9f55 9f55 d 2f
9f55 9f55 s         CPL                     ; Invert MSB
9f56 9f56 d cd2fa1
9f56 9f56 s         CALL    ACPASS          ; Save AC as current
9f59 9f59 d c1
9f59 9f59 s         POP     BC              ; Clean up stack
9f5a 9f5a d c3969d
9f5a 9f5a s         JP      EVAL3           ; Continue evaluation
9f5d 9f5d s 
9f5d 9f5d d 2b
9f5d 9f5d s DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
9f5e 9f5e d cd0599
9f5e 9f5e s         CALL    GETCHR          ; Get next character
9f61 9f61 d c8
9f61 9f61 s         RET     Z               ; End of DIM statement
9f62 9f62 d cd7b97
9f62 9f62 s         CALL    CHKSYN          ; Make sure ',' follows
9f65 9f65 d 2c
9f65 9f65 s         .BYTE      ','
9f66 9f66 d 015d9f
9f66 9f66 s DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
9f69 9f69 d c5
9f69 9f69 s         PUSH    BC              ; Save on stack
9f6a 9f6a d f6
9f6a 9f6a s         .BYTE      0F6H            ; Flag "Create" variable
9f6b 9f6b d af
9f6b 9f6b s GETVAR: XOR     A               ; Find variable address,to DE
9f6c 9f6c d 32f1b0
9f6c 9f6c s         LD      (LCRFLG),A      ; Set locate / create flag
9f6f 9f6f d 46
9f6f 9f6f s         LD      B,(HL)          ; Get First byte of name
9f70 9f70 d cda699
9f70 9f70 s GTFNAM: CALL    CHKLTR          ; See if a letter
9f73 9f73 d daad94
9f73 9f73 s         JP      C,SNERR         ; ?SN Error if not a letter
9f76 9f76 d af
9f76 9f76 s         XOR     A
9f77 9f77 d 4f
9f77 9f77 s         LD      C,A             ; Clear second byte of name
9f78 9f78 d 32f2b0
9f78 9f78 s         LD      (TYPE),A        ; Set type to numeric
9f7b 9f7b d cd0599
9f7b 9f7b s         CALL    GETCHR          ; Get next character
9f7e 9f7e d da879f
9f7e 9f7e s         JP      C,SVNAM2        ; Numeric - Save in name
9f81 9f81 d cda699
9f81 9f81 s         CALL    CHKLTR          ; See if a letter
9f84 9f84 d da949f
9f84 9f84 s         JP      C,CHARTY        ; Not a letter - Check type
9f87 9f87 d 4f
9f87 9f87 s SVNAM2: LD      C,A             ; Save second byte of name
9f88 9f88 d cd0599
9f88 9f88 s ENDNAM: CALL    GETCHR          ; Get next character
9f8b 9f8b d da889f
9f8b 9f8b s         JP      C,ENDNAM        ; Numeric - Get another
9f8e 9f8e d cda699
9f8e 9f8e s         CALL    CHKLTR          ; See if a letter
9f91 9f91 d d2889f
9f91 9f91 s         JP      NC,ENDNAM       ; Letter - Get another
9f94 9f94 d d624
9f94 9f94 s CHARTY: SUB     '$'             ; String variable?
9f96 9f96 d c2a39f
9f96 9f96 s         JP      NZ,NOTSTR       ; No - Numeric variable
9f99 9f99 d 3c
9f99 9f99 s         INC     A               ; A = 1 (string type)
9f9a 9f9a d 32f2b0
9f9a 9f9a s         LD      (TYPE),A        ; Set type to string
9f9d 9f9d d 0f
9f9d 9f9d s         RRCA                    ; A = 80H , Flag for string
9f9e 9f9e d 81
9f9e 9f9e s         ADD     A,C             ; 2nd byte of name has bit 7 on
9f9f 9f9f d 4f
9f9f 9f9f s         LD      C,A             ; Resave second byte on name
9fa0 9fa0 d cd0599
9fa0 9fa0 s         CALL    GETCHR          ; Get next character
9fa3 9fa3 d 3a10b1
9fa3 9fa3 s NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
9fa6 9fa6 d 3d
9fa6 9fa6 s         DEC     A
9fa7 9fa7 d ca50a0
9fa7 9fa7 s         JP      Z,ARLDSV        ; Yes - Get array name
9faa 9faa d f2b39f
9faa 9faa s         JP      P,NSCFOR        ; No array with "FOR" or "FN"
9fad 9fad d 7e
9fad 9fad s         LD      A,(HL)          ; Get byte again
9fae 9fae d d628
9fae 9fae s         SUB     '('             ; Subscripted variable?
9fb0 9fb0 d ca28a0
9fb0 9fb0 s         JP      Z,SBSCPT        ; Yes - Sort out subscript
9fb3 9fb3 s 
9fb3 9fb3 d af
9fb3 9fb3 s NSCFOR: XOR     A               ; Simple variable
9fb4 9fb4 d 3210b1
9fb4 9fb4 s         LD      (FORFLG),A      ; Clear "FOR" flag
9fb7 9fb7 d e5
9fb7 9fb7 s         PUSH    HL              ; Save code string address
9fb8 9fb8 d 50
9fb8 9fb8 s         LD      D,B             ; DE = Variable name to find
9fb9 9fb9 d 59
9fb9 9fb9 s         LD      E,C
9fba 9fba d 2a23b1
9fba 9fba s         LD      HL,(FNRGNM)     ; FN argument name
9fbd 9fbd d cd7597
9fbd 9fbd s         CALL    CPDEHL          ; Is it the FN argument?
9fc0 9fc0 d 1125b1
9fc0 9fc0 s         LD      DE,FNARG        ; Point to argument value
9fc3 9fc3 d ca98a6
9fc3 9fc3 s         JP      Z,POPHRT        ; Yes - Return FN argument value
9fc6 9fc6 d 2a1db1
9fc6 9fc6 s         LD      HL,(VAREND)     ; End of variables
9fc9 9fc9 d eb
9fc9 9fc9 s         EX      DE,HL           ; Address of end of search
9fca 9fca d 2a1bb1
9fca 9fca s         LD      HL,(PROGND)     ; Start of variables address
9fcd 9fcd d cd7597
9fcd 9fcd s FNDVAR: CALL    CPDEHL          ; End of variable list table?
9fd0 9fd0 d cae69f
9fd0 9fd0 s         JP      Z,CFEVAL        ; Yes - Called from EVAL?
9fd3 9fd3 d 79
9fd3 9fd3 s         LD      A,C             ; Get second byte of name
9fd4 9fd4 d 96
9fd4 9fd4 s         SUB     (HL)            ; Compare with name in list
9fd5 9fd5 d 23
9fd5 9fd5 s         INC     HL              ; Move on to first byte
9fd6 9fd6 d c2db9f
9fd6 9fd6 s         JP      NZ,FNTHR        ; Different - Find another
9fd9 9fd9 d 78
9fd9 9fd9 s         LD      A,B             ; Get first byte of name
9fda 9fda d 96
9fda 9fda s         SUB     (HL)            ; Compare with name in list
9fdb 9fdb d 23
9fdb 9fdb s FNTHR:  INC     HL              ; Move on to LSB of value
9fdc 9fdc d ca1aa0
9fdc 9fdc s         JP      Z,RETADR        ; Found - Return address
9fdf 9fdf d 23
9fdf 9fdf s         INC     HL              ; <- Skip
9fe0 9fe0 d 23
9fe0 9fe0 s         INC     HL              ; <- over
9fe1 9fe1 d 23
9fe1 9fe1 s         INC     HL              ; <- F.P.
9fe2 9fe2 d 23
9fe2 9fe2 s         INC     HL              ; <- value
9fe3 9fe3 d c3cd9f
9fe3 9fe3 s         JP      FNDVAR          ; Keep looking
9fe6 9fe6 s 
9fe6 9fe6 d e1
9fe6 9fe6 s CFEVAL: POP     HL              ; Restore code string address
9fe7 9fe7 d e3
9fe7 9fe7 s         EX      (SP),HL         ; Get return address
9fe8 9fe8 d d5
9fe8 9fe8 s         PUSH    DE              ; Save address of variable
9fe9 9fe9 d 11689e
9fe9 9fe9 s         LD      DE,FRMEVL       ; Return address in EVAL
9fec 9fec d cd7597
9fec 9fec s         CALL    CPDEHL          ; Called from EVAL ?
9fef 9fef d d1
9fef 9fef s         POP     DE              ; Restore address of variable
9ff0 9ff0 d ca1da0
9ff0 9ff0 s         JP      Z,RETNUL        ; Yes - Return null variable
9ff3 9ff3 d e3
9ff3 9ff3 s         EX      (SP),HL         ; Put back return
9ff4 9ff4 d e5
9ff4 9ff4 s         PUSH    HL              ; Save code string address
9ff5 9ff5 d c5
9ff5 9ff5 s         PUSH    BC              ; Save variable name
9ff6 9ff6 d 010600
9ff6 9ff6 s         LD      BC,6            ; 2 byte name plus 4 byte data
9ff9 9ff9 d 2a1fb1
9ff9 9ff9 s         LD      HL,(ARREND)     ; End of arrays
9ffc 9ffc d e5
9ffc 9ffc s         PUSH    HL              ; Save end of arrays
9ffd 9ffd d 09
9ffd 9ffd s         ADD     HL,BC           ; Move up 6 bytes
9ffe 9ffe d c1
9ffe 9ffe s         POP     BC              ; Source address in BC
9fff 9fff d e5
9fff 9fff s         PUSH    HL              ; Save new end address
a000 a000 d cd7994
a000 a000 s         CALL    MOVUP           ; Move arrays up
a003 a003 d e1
a003 a003 s         POP     HL              ; Restore new end address
a004 a004 d 221fb1
a004 a004 s         LD      (ARREND),HL     ; Set new end address
a007 a007 d 60
a007 a007 s         LD      H,B             ; End of variables to HL
a008 a008 d 69
a008 a008 s         LD      L,C
a009 a009 d 221db1
a009 a009 s         LD      (VAREND),HL     ; Set new end address
a00c a00c s 
a00c a00c d 2b
a00c a00c s ZEROLP: DEC     HL              ; Back through to zero variable
a00d a00d d 3600
a00d a00d s         LD      (HL),0          ; Zero byte in variable
a00f a00f d cd7597
a00f a00f s         CALL    CPDEHL          ; Done them all?
a012 a012 d c20ca0
a012 a012 s         JP      NZ,ZEROLP       ; No - Keep on going
a015 a015 d d1
a015 a015 s         POP     DE              ; Get variable name
a016 a016 d 73
a016 a016 s         LD      (HL),E          ; Store second character
a017 a017 d 23
a017 a017 s         INC     HL
a018 a018 d 72
a018 a018 s         LD      (HL),D          ; Store first character
a019 a019 d 23
a019 a019 s         INC     HL
a01a a01a d eb
a01a a01a s RETADR: EX      DE,HL           ; Address of variable in DE
a01b a01b d e1
a01b a01b s         POP     HL              ; Restore code string address
a01c a01c d c9
a01c a01c s         RET
a01d a01d s 
a01d a01d d 322cb1
a01d a01d s RETNUL: LD      (FPEXP),A       ; Set result to zero
a020 a020 d 214994
a020 a020 s         LD      HL,ZERBYT       ; Also set a null string
a023 a023 d 2229b1
a023 a023 s         LD      (FPREG),HL      ; Save for EVAL
a026 a026 d e1
a026 a026 s         POP     HL              ; Restore code string address
a027 a027 d c9
a027 a027 s         RET
a028 a028 s 
a028 a028 d e5
a028 a028 s SBSCPT: PUSH    HL              ; Save code string address
a029 a029 d 2af1b0
a029 a029 s         LD      HL,(LCRFLG)     ; Locate/Create and Type
a02c a02c d e3
a02c a02c s         EX      (SP),HL         ; Save and get code string
a02d a02d d 57
a02d a02d s         LD      D,A             ; Zero number of dimensions
a02e a02e d d5
a02e a02e s SCPTLP: PUSH    DE              ; Save number of dimensions
a02f a02f d c5
a02f a02f s         PUSH    BC              ; Save array name
a030 a030 d cdae99
a030 a030 s         CALL    FPSINT          ; Get subscript (0-32767)
a033 a033 d c1
a033 a033 s         POP     BC              ; Restore array name
a034 a034 d f1
a034 a034 s         POP     AF              ; Get number of dimensions
a035 a035 d eb
a035 a035 s         EX      DE,HL
a036 a036 d e3
a036 a036 s         EX      (SP),HL         ; Save subscript value
a037 a037 d e5
a037 a037 s         PUSH    HL              ; Save LCRFLG and TYPE
a038 a038 d eb
a038 a038 s         EX      DE,HL
a039 a039 d 3c
a039 a039 s         INC     A               ; Count dimensions
a03a a03a d 57
a03a a03a s         LD      D,A             ; Save in D
a03b a03b d 7e
a03b a03b s         LD      A,(HL)          ; Get next byte in code string
a03c a03c d fe2c
a03c a03c s         CP      ','             ; Comma (more to come)?
a03e a03e d ca2ea0
a03e a03e s         JP      Z,SCPTLP        ; Yes - More subscripts
a041 a041 d cd7b97
a041 a041 s         CALL    CHKSYN          ; Make sure ")" follows
a044 a044 d 29
a044 a044 s         .BYTE      ")"
a045 a045 d 2215b1
a045 a045 s         LD      (NXTOPR),HL     ; Save code string address
a048 a048 d e1
a048 a048 s         POP     HL              ; Get LCRFLG and TYPE
a049 a049 d 22f1b0
a049 a049 s         LD      (LCRFLG),HL     ; Restore Locate/create & type
a04c a04c d 1e00
a04c a04c s         LD      E,0             ; Flag not CSAVE* or CLOAD*
a04e a04e d d5
a04e a04e s         PUSH    DE              ; Save number of dimensions (D)
a04f a04f d 11
a04f a04f s         .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
a050 a050 s 
a050 a050 d e5
a050 a050 s ARLDSV: PUSH    HL              ; Save code string address
a051 a051 d f5
a051 a051 s         PUSH    AF              ; A = 00 , Flags set = Z,N
a052 a052 d 2a1db1
a052 a052 s         LD      HL,(VAREND)     ; Start of arrays
a055 a055 d 3e
a055 a055 s         .BYTE      3EH             ; Skip "ADD HL,DE"
a056 a056 d 19
a056 a056 s FNDARY: ADD     HL,DE           ; Move to next array start
a057 a057 d eb
a057 a057 s         EX      DE,HL
a058 a058 d 2a1fb1
a058 a058 s         LD      HL,(ARREND)     ; End of arrays
a05b a05b d eb
a05b a05b s         EX      DE,HL           ; Current array pointer
a05c a05c d cd7597
a05c a05c s         CALL    CPDEHL          ; End of arrays found?
a05f a05f d ca88a0
a05f a05f s         JP      Z,CREARY        ; Yes - Create array
a062 a062 d 7e
a062 a062 s         LD      A,(HL)          ; Get second byte of name
a063 a063 d b9
a063 a063 s         CP      C               ; Compare with name given
a064 a064 d 23
a064 a064 s         INC     HL              ; Move on
a065 a065 d c26aa0
a065 a065 s         JP      NZ,NXTARY       ; Different - Find next array
a068 a068 d 7e
a068 a068 s         LD      A,(HL)          ; Get first byte of name
a069 a069 d b8
a069 a069 s         CP      B               ; Compare with name given
a06a a06a d 23
a06a a06a s NXTARY: INC     HL              ; Move on
a06b a06b d 5e
a06b a06b s         LD      E,(HL)          ; Get LSB of next array address
a06c a06c d 23
a06c a06c s         INC     HL
a06d a06d d 56
a06d a06d s         LD      D,(HL)          ; Get MSB of next array address
a06e a06e d 23
a06e a06e s         INC     HL
a06f a06f d c256a0
a06f a06f s         JP      NZ,FNDARY       ; Not found - Keep looking
a072 a072 d 3af1b0
a072 a072 s         LD      A,(LCRFLG)      ; Found Locate or Create it?
a075 a075 d b7
a075 a075 s         OR      A
a076 a076 d c2b694
a076 a076 s         JP      NZ,DDERR        ; Create - ?DD Error
a079 a079 d f1
a079 a079 s         POP     AF              ; Locate - Get number of dim'ns
a07a a07a d 44
a07a a07a s         LD      B,H             ; BC Points to array dim'ns
a07b a07b d 4d
a07b a07b s         LD      C,L
a07c a07c d ca98a6
a07c a07c s         JP      Z,POPHRT        ; Jump if array load/save
a07f a07f d 96
a07f a07f s         SUB     (HL)            ; Same number of dimensions?
a080 a080 d cae6a0
a080 a080 s         JP      Z,FINDEL        ; Yes - Find element
a083 a083 d 1e10
a083 a083 s BSERR:  LD      E,BS            ; ?BS Error
a085 a085 d c3c194
a085 a085 s         JP      ERROR           ; Output error
a088 a088 s 
a088 a088 d 110400
a088 a088 s CREARY: LD      DE,4            ; 4 Bytes per entry
a08b a08b d f1
a08b a08b s         POP     AF              ; Array to save or 0 dim'ns?
a08c a08c d cacf99
a08c a08c s         JP      Z,FCERR         ; Yes - ?FC Error
a08f a08f d 71
a08f a08f s         LD      (HL),C          ; Save second byte of name
a090 a090 d 23
a090 a090 s         INC     HL
a091 a091 d 70
a091 a091 s         LD      (HL),B          ; Save first byte of name
a092 a092 d 23
a092 a092 s         INC     HL
a093 a093 d 4f
a093 a093 s         LD      C,A             ; Number of dimensions to C
a094 a094 d cd8a94
a094 a094 s         CALL    CHKSTK          ; Check if enough memory
a097 a097 d 23
a097 a097 s         INC     HL              ; Point to number of dimensions
a098 a098 d 23
a098 a098 s         INC     HL
a099 a099 d 220ab1
a099 a099 s         LD      (CUROPR),HL     ; Save address of pointer
a09c a09c d 71
a09c a09c s         LD      (HL),C          ; Set number of dimensions
a09d a09d d 23
a09d a09d s         INC     HL
a09e a09e d 3af1b0
a09e a09e s         LD      A,(LCRFLG)      ; Locate of Create?
a0a1 a0a1 d 17
a0a1 a0a1 s         RLA                     ; Carry set = Create
a0a2 a0a2 d 79
a0a2 a0a2 s         LD      A,C             ; Get number of dimensions
a0a3 a0a3 d 010b00
a0a3 a0a3 s CRARLP: LD      BC,10+1         ; Default dimension size 10
a0a6 a0a6 d d2aba0
a0a6 a0a6 s         JP      NC,DEFSIZ       ; Locate - Set default size
a0a9 a0a9 d c1
a0a9 a0a9 s         POP     BC              ; Get specified dimension size
a0aa a0aa d 03
a0aa a0aa s         INC     BC              ; Include zero element
a0ab a0ab d 71
a0ab a0ab s DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
a0ac a0ac d 23
a0ac a0ac s         INC     HL
a0ad a0ad d 70
a0ad a0ad s         LD      (HL),B          ; Save MSB of dimension size
a0ae a0ae d 23
a0ae a0ae s         INC     HL
a0af a0af d f5
a0af a0af s         PUSH    AF              ; Save num' of dim'ns an status
a0b0 a0b0 d e5
a0b0 a0b0 s         PUSH    HL              ; Save address of dim'n size
a0b1 a0b1 d cd43a8
a0b1 a0b1 s         CALL    MLDEBC          ; Multiply DE by BC to find
a0b4 a0b4 d eb
a0b4 a0b4 s         EX      DE,HL           ; amount of mem needed (to DE)
a0b5 a0b5 d e1
a0b5 a0b5 s         POP     HL              ; Restore address of dimension
a0b6 a0b6 d f1
a0b6 a0b6 s         POP     AF              ; Restore number of dimensions
a0b7 a0b7 d 3d
a0b7 a0b7 s         DEC     A               ; Count them
a0b8 a0b8 d c2a3a0
a0b8 a0b8 s         JP      NZ,CRARLP       ; Do next dimension if more
a0bb a0bb d f5
a0bb a0bb s         PUSH    AF              ; Save locate/create flag
a0bc a0bc d 42
a0bc a0bc s         LD      B,D             ; MSB of memory needed
a0bd a0bd d 4b
a0bd a0bd s         LD      C,E             ; LSB of memory needed
a0be a0be d eb
a0be a0be s         EX      DE,HL
a0bf a0bf d 19
a0bf a0bf s         ADD     HL,DE           ; Add bytes to array start
a0c0 a0c0 d daa294
a0c0 a0c0 s         JP      C,OMERR         ; Too big - Error
a0c3 a0c3 d cd9394
a0c3 a0c3 s         CALL    ENFMEM          ; See if enough memory
a0c6 a0c6 d 221fb1
a0c6 a0c6 s         LD      (ARREND),HL     ; Save new end of array
a0c9 a0c9 s 
a0c9 a0c9 d 2b
a0c9 a0c9 s ZERARY: DEC     HL              ; Back through array data
a0ca a0ca d 3600
a0ca a0ca s         LD      (HL),0          ; Set array element to zero
a0cc a0cc d cd7597
a0cc a0cc s         CALL    CPDEHL          ; All elements zeroed?
a0cf a0cf d c2c9a0
a0cf a0cf s         JP      NZ,ZERARY       ; No - Keep on going
a0d2 a0d2 d 03
a0d2 a0d2 s         INC     BC              ; Number of bytes + 1
a0d3 a0d3 d 57
a0d3 a0d3 s         LD      D,A             ; A=0
a0d4 a0d4 d 2a0ab1
a0d4 a0d4 s         LD      HL,(CUROPR)     ; Get address of array
a0d7 a0d7 d 5e
a0d7 a0d7 s         LD      E,(HL)          ; Number of dimensions
a0d8 a0d8 d eb
a0d8 a0d8 s         EX      DE,HL           ; To HL
a0d9 a0d9 d 29
a0d9 a0d9 s         ADD     HL,HL           ; Two bytes per dimension size
a0da a0da d 09
a0da a0da s         ADD     HL,BC           ; Add number of bytes
a0db a0db d eb
a0db a0db s         EX      DE,HL           ; Bytes needed to DE
a0dc a0dc d 2b
a0dc a0dc s         DEC     HL
a0dd a0dd d 2b
a0dd a0dd s         DEC     HL
a0de a0de d 73
a0de a0de s         LD      (HL),E          ; Save LSB of bytes needed
a0df a0df d 23
a0df a0df s         INC     HL
a0e0 a0e0 d 72
a0e0 a0e0 s         LD      (HL),D          ; Save MSB of bytes needed
a0e1 a0e1 d 23
a0e1 a0e1 s         INC     HL
a0e2 a0e2 d f1
a0e2 a0e2 s         POP     AF              ; Locate / Create?
a0e3 a0e3 d da0aa1
a0e3 a0e3 s         JP      C,ENDDIM        ; A is 0 , End if create
a0e6 a0e6 d 47
a0e6 a0e6 s FINDEL: LD      B,A             ; Find array element
a0e7 a0e7 d 4f
a0e7 a0e7 s         LD      C,A
a0e8 a0e8 d 7e
a0e8 a0e8 s         LD      A,(HL)          ; Number of dimensions
a0e9 a0e9 d 23
a0e9 a0e9 s         INC     HL
a0ea a0ea d 16
a0ea a0ea s         .BYTE      16H             ; Skip "POP HL"
a0eb a0eb d e1
a0eb a0eb s FNDELP: POP     HL              ; Address of next dim' size
a0ec a0ec d 5e
a0ec a0ec s         LD      E,(HL)          ; Get LSB of dim'n size
a0ed a0ed d 23
a0ed a0ed s         INC     HL
a0ee a0ee d 56
a0ee a0ee s         LD      D,(HL)          ; Get MSB of dim'n size
a0ef a0ef d 23
a0ef a0ef s         INC     HL
a0f0 a0f0 d e3
a0f0 a0f0 s         EX      (SP),HL         ; Save address - Get index
a0f1 a0f1 d f5
a0f1 a0f1 s         PUSH    AF              ; Save number of dim'ns
a0f2 a0f2 d cd7597
a0f2 a0f2 s         CALL    CPDEHL          ; Dimension too large?
a0f5 a0f5 d d283a0
a0f5 a0f5 s         JP      NC,BSERR        ; Yes - ?BS Error
a0f8 a0f8 d e5
a0f8 a0f8 s         PUSH    HL              ; Save index
a0f9 a0f9 d cd43a8
a0f9 a0f9 s         CALL    MLDEBC          ; Multiply previous by size
a0fc a0fc d d1
a0fc a0fc s         POP     DE              ; Index supplied to DE
a0fd a0fd d 19
a0fd a0fd s         ADD     HL,DE           ; Add index to pointer
a0fe a0fe d f1
a0fe a0fe s         POP     AF              ; Number of dimensions
a0ff a0ff d 3d
a0ff a0ff s         DEC     A               ; Count them
a100 a100 d 44
a100 a100 s         LD      B,H             ; MSB of pointer
a101 a101 d 4d
a101 a101 s         LD      C,L             ; LSB of pointer
a102 a102 d c2eba0
a102 a102 s         JP      NZ,FNDELP       ; More - Keep going
a105 a105 d 29
a105 a105 s         ADD     HL,HL           ; 4 Bytes per element
a106 a106 d 29
a106 a106 s         ADD     HL,HL
a107 a107 d c1
a107 a107 s         POP     BC              ; Start of array
a108 a108 d 09
a108 a108 s         ADD     HL,BC           ; Point to element
a109 a109 d eb
a109 a109 s         EX      DE,HL           ; Address of element to DE
a10a a10a d 2a15b1
a10a a10a s ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
a10d a10d d c9
a10d a10d s         RET
a10e a10e s 
a10e a10e d 2a1fb1
a10e a10e s FRE:    LD      HL,(ARREND)     ; Start of free memory
a111 a111 d eb
a111 a111 s         EX      DE,HL           ; To DE
a112 a112 d 210000
a112 a112 s         LD      HL,0            ; End of free memory
a115 a115 d 39
a115 a115 s         ADD     HL,SP           ; Current stack value
a116 a116 d 3af2b0
a116 a116 s         LD      A,(TYPE)        ; Dummy argument type
a119 a119 d b7
a119 a119 s         OR      A
a11a a11a d ca2aa1
a11a a11a s         JP      Z,FRENUM        ; Numeric - Free variable space
a11d a11d d cd91a3
a11d a11d s         CALL    GSTRCU          ; Current string to pool
a120 a120 d cd91a2
a120 a120 s         CALL    GARBGE          ; Garbage collection
a123 a123 d 2a9fb0
a123 a123 s         LD      HL,(STRSPC)     ; Bottom of string space in use
a126 a126 d eb
a126 a126 s         EX      DE,HL           ; To DE
a127 a127 d 2a08b1
a127 a127 s         LD      HL,(STRBOT)     ; Bottom of string space
a12a a12a d 7d
a12a a12a s FRENUM: LD      A,L             ; Get LSB of end
a12b a12b d 93
a12b a12b s         SUB     E               ; Subtract LSB of beginning
a12c a12c d 4f
a12c a12c s         LD      C,A             ; Save difference if C
a12d a12d d 7c
a12d a12d s         LD      A,H             ; Get MSB of end
a12e a12e d 9a
a12e a12e s         SBC     A,D             ; Subtract MSB of beginning
a12f a12f d 41
a12f a12f s ACPASS: LD      B,C             ; Return integer AC
a130 a130 d 50
a130 a130 s ABPASS: LD      D,B             ; Return integer AB
a131 a131 d 1e00
a131 a131 s         LD      E,0
a133 a133 d 21f2b0
a133 a133 s         LD      HL,TYPE         ; Point to type
a136 a136 d 73
a136 a136 s         LD      (HL),E          ; Set type to numeric
a137 a137 d 0690
a137 a137 s         LD      B,80H+16        ; 16 bit integer
a139 a139 d c36ea7
a139 a139 s         JP      RETINT          ; Return the integr
a13c a13c s 
a13c a13c d 3af0b0
a13c a13c s POS:    LD      A,(CURPOS)      ; Get cursor position
a13f a13f d 47
a13f a13f s PASSA:  LD      B,A             ; Put A into AB
a140 a140 d af
a140 a140 s         XOR     A               ; Zero A
a141 a141 d c330a1
a141 a141 s         JP      ABPASS          ; Return integer AB
a144 a144 s 
a144 a144 d cdc7a1
a144 a144 s DEF:    CALL    CHEKFN          ; Get "FN" and name
a147 a147 d cdb9a1
a147 a147 s         CALL    IDTEST          ; Test for illegal direct
a14a a14a d 019f9a
a14a a14a s         LD      BC,DATA         ; To get next statement
a14d a14d d c5
a14d a14d s         PUSH    BC              ; Save address for RETurn
a14e a14e d d5
a14e a14e s         PUSH    DE              ; Save address of function ptr
a14f a14f d cd7b97
a14f a14f s         CALL    CHKSYN          ; Make sure "(" follows
a152 a152 d 28
a152 a152 s         .BYTE      "("
a153 a153 d cd6b9f
a153 a153 s         CALL    GETVAR          ; Get argument variable name
a156 a156 d e5
a156 a156 s         PUSH    HL              ; Save code string address
a157 a157 d eb
a157 a157 s         EX      DE,HL           ; Argument address to HL
a158 a158 d 2b
a158 a158 s         DEC     HL
a159 a159 d 56
a159 a159 s         LD      D,(HL)          ; Get first byte of arg name
a15a a15a d 2b
a15a a15a s         DEC     HL
a15b a15b d 5e
a15b a15b s         LD      E,(HL)          ; Get second byte of arg name
a15c a15c d e1
a15c a15c s         POP     HL              ; Restore code string address
a15d a15d d cd789d
a15d a15d s         CALL    TSTNUM          ; Make sure numeric argument
a160 a160 d cd7b97
a160 a160 s         CALL    CHKSYN          ; Make sure ")" follows
a163 a163 d 29
a163 a163 s         .BYTE      ")"
a164 a164 d cd7b97
a164 a164 s         CALL    CHKSYN          ; Make sure "=" follows
a167 a167 d b4
a167 a167 s         .BYTE      ZEQUAL          ; "=" token
a168 a168 d 44
a168 a168 s         LD      B,H             ; Code string address to BC
a169 a169 d 4d
a169 a169 s         LD      C,L
a16a a16a d e3
a16a a16a s         EX      (SP),HL         ; Save code str , Get FN ptr
a16b a16b d 71
a16b a16b s         LD      (HL),C          ; Save LSB of FN code string
a16c a16c d 23
a16c a16c s         INC     HL
a16d a16d d 70
a16d a16d s         LD      (HL),B          ; Save MSB of FN code string
a16e a16e d c306a2
a16e a16e s         JP      SVSTAD          ; Save address and do function
a171 a171 s 
a171 a171 d cdc7a1
a171 a171 s DOFN:   CALL    CHEKFN          ; Make sure FN follows
a174 a174 d d5
a174 a174 s         PUSH    DE              ; Save function pointer address
a175 a175 d cd4c9e
a175 a175 s         CALL    EVLPAR          ; Evaluate expression in "()"
a178 a178 d cd789d
a178 a178 s         CALL    TSTNUM          ; Make sure numeric result
a17b a17b d e3
a17b a17b s         EX      (SP),HL         ; Save code str , Get FN ptr
a17c a17c d 5e
a17c a17c s         LD      E,(HL)          ; Get LSB of FN code string
a17d a17d d 23
a17d a17d s         INC     HL
a17e a17e d 56
a17e a17e s         LD      D,(HL)          ; Get MSB of FN code string
a17f a17f d 23
a17f a17f s         INC     HL
a180 a180 d 7a
a180 a180 s         LD      A,D             ; And function DEFined?
a181 a181 d b3
a181 a181 s         OR      E
a182 a182 d cab994
a182 a182 s         JP      Z,UFERR         ; No - ?UF Error
a185 a185 d 7e
a185 a185 s         LD      A,(HL)          ; Get LSB of argument address
a186 a186 d 23
a186 a186 s         INC     HL
a187 a187 d 66
a187 a187 s         LD      H,(HL)          ; Get MSB of argument address
a188 a188 d 6f
a188 a188 s         LD      L,A             ; HL = Arg variable address
a189 a189 d e5
a189 a189 s         PUSH    HL              ; Save it
a18a a18a d 2a23b1
a18a a18a s         LD      HL,(FNRGNM)     ; Get old argument name
a18d a18d d e3
a18d a18d s         EX      (SP),HL ;       ; Save old , Get new
a18e a18e d 2223b1
a18e a18e s         LD      (FNRGNM),HL     ; Set new argument name
a191 a191 d 2a27b1
a191 a191 s         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
a194 a194 d e5
a194 a194 s         PUSH    HL              ; Save it
a195 a195 d 2a25b1
a195 a195 s         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
a198 a198 d e5
a198 a198 s         PUSH    HL              ; Save it
a199 a199 d 2125b1
a199 a199 s         LD      HL,FNARG        ; HL = Value of argument
a19c a19c d d5
a19c a19c s         PUSH    DE              ; Save FN code string address
a19d a19d d cdafa7
a19d a19d s         CALL    FPTHL           ; Move FPREG to argument
a1a0 a1a0 d e1
a1a0 a1a0 s         POP     HL              ; Get FN code string address
a1a1 a1a1 d cd759d
a1a1 a1a1 s         CALL    GETNUM          ; Get value from function
a1a4 a1a4 d 2b
a1a4 a1a4 s         DEC     HL              ; DEC 'cos GETCHR INCs
a1a5 a1a5 d cd0599
a1a5 a1a5 s         CALL    GETCHR          ; Get next character
a1a8 a1a8 d c2ad94
a1a8 a1a8 s         JP      NZ,SNERR        ; Bad character in FN - Error
a1ab a1ab d e1
a1ab a1ab s         POP     HL              ; Get MSB,EXP of old arg
a1ac a1ac d 2225b1
a1ac a1ac s         LD      (FNARG),HL      ; Restore it
a1af a1af d e1
a1af a1af s         POP     HL              ; Get LSB,NLSB of old arg
a1b0 a1b0 d 2227b1
a1b0 a1b0 s         LD      (FNARG+2),HL    ; Restore it
a1b3 a1b3 d e1
a1b3 a1b3 s         POP     HL              ; Get name of old arg
a1b4 a1b4 d 2223b1
a1b4 a1b4 s         LD      (FNRGNM),HL     ; Restore it
a1b7 a1b7 d e1
a1b7 a1b7 s         POP     HL              ; Restore code string address
a1b8 a1b8 d c9
a1b8 a1b8 s         RET
a1b9 a1b9 s 
a1b9 a1b9 d e5
a1b9 a1b9 s IDTEST: PUSH    HL              ; Save code string address
a1ba a1ba d 2aa1b0
a1ba a1ba s         LD      HL,(LINEAT)     ; Get current line number
a1bd a1bd d 23
a1bd a1bd s         INC     HL              ; -1 means direct statement
a1be a1be d 7c
a1be a1be s         LD      A,H
a1bf a1bf d b5
a1bf a1bf s         OR      L
a1c0 a1c0 d e1
a1c0 a1c0 s         POP     HL              ; Restore code string address
a1c1 a1c1 d c0
a1c1 a1c1 s         RET     NZ              ; Return if in program
a1c2 a1c2 d 1e16
a1c2 a1c2 s         LD      E,ID            ; ?ID Error
a1c4 a1c4 d c3c194
a1c4 a1c4 s         JP      ERROR
a1c7 a1c7 s 
a1c7 a1c7 d cd7b97
a1c7 a1c7 s CHEKFN: CALL    CHKSYN          ; Make sure FN follows
a1ca a1ca d a7
a1ca a1ca s         .BYTE      ZFN             ; "FN" token
a1cb a1cb d 3e80
a1cb a1cb s         LD      A,80H
a1cd a1cd d 3210b1
a1cd a1cd s         LD      (FORFLG),A      ; Flag FN name to find
a1d0 a1d0 d b6
a1d0 a1d0 s         OR      (HL)            ; FN name has bit 7 set
a1d1 a1d1 d 47
a1d1 a1d1 s         LD      B,A             ; in first byte of name
a1d2 a1d2 d cd709f
a1d2 a1d2 s         CALL    GTFNAM          ; Get FN name
a1d5 a1d5 d c3789d
a1d5 a1d5 s         JP      TSTNUM          ; Make sure numeric function
a1d8 a1d8 s 
a1d8 a1d8 d cd789d
a1d8 a1d8 s STR:    CALL    TSTNUM          ; Make sure it's a number
a1db a1db d cdfca8
a1db a1db s         CALL    NUMASC          ; Turn number into text
a1de a1de d cd0ca2
a1de a1de s STR1:   CALL    CRTST           ; Create string entry for it
a1e1 a1e1 d cd91a3
a1e1 a1e1 s         CALL    GSTRCU          ; Current string to pool
a1e4 a1e4 d 01eca3
a1e4 a1e4 s         LD      BC,TOPOOL       ; Save in string pool
a1e7 a1e7 d c5
a1e7 a1e7 s         PUSH    BC              ; Save address on stack
a1e8 a1e8 s 
a1e8 a1e8 d 7e
a1e8 a1e8 s SAVSTR: LD      A,(HL)          ; Get string length
a1e9 a1e9 d 23
a1e9 a1e9 s         INC     HL
a1ea a1ea d 23
a1ea a1ea s         INC     HL
a1eb a1eb d e5
a1eb a1eb s         PUSH    HL              ; Save pointer to string
a1ec a1ec d cd67a2
a1ec a1ec s         CALL    TESTR           ; See if enough string space
a1ef a1ef d e1
a1ef a1ef s         POP     HL              ; Restore pointer to string
a1f0 a1f0 d 4e
a1f0 a1f0 s         LD      C,(HL)          ; Get LSB of address
a1f1 a1f1 d 23
a1f1 a1f1 s         INC     HL
a1f2 a1f2 d 46
a1f2 a1f2 s         LD      B,(HL)          ; Get MSB of address
a1f3 a1f3 d cd00a2
a1f3 a1f3 s         CALL    CRTMST          ; Create string entry
a1f6 a1f6 d e5
a1f6 a1f6 s         PUSH    HL              ; Save pointer to MSB of addr
a1f7 a1f7 d 6f
a1f7 a1f7 s         LD      L,A             ; Length of string
a1f8 a1f8 d cd84a3
a1f8 a1f8 s         CALL    TOSTRA          ; Move to string area
a1fb a1fb d d1
a1fb a1fb s         POP     DE              ; Restore pointer to MSB
a1fc a1fc d c9
a1fc a1fc s         RET
a1fd a1fd s 
a1fd a1fd d cd67a2
a1fd a1fd s MKTMST: CALL    TESTR           ; See if enough string space
a200 a200 d 2104b1
a200 a200 s CRTMST: LD      HL,TMPSTR       ; Temporary string
a203 a203 d e5
a203 a203 s         PUSH    HL              ; Save it
a204 a204 d 77
a204 a204 s         LD      (HL),A          ; Save length of string
a205 a205 d 23
a205 a205 s         INC     HL
a206 a206 d 23
a206 a206 s SVSTAD: INC     HL
a207 a207 d 73
a207 a207 s         LD      (HL),E          ; Save LSB of address
a208 a208 d 23
a208 a208 s         INC     HL
a209 a209 d 72
a209 a209 s         LD      (HL),D          ; Save MSB of address
a20a a20a d e1
a20a a20a s         POP     HL              ; Restore pointer
a20b a20b d c9
a20b a20b s         RET
a20c a20c s 
a20c a20c d 2b
a20c a20c s CRTST:  DEC     HL              ; DEC - INCed after
a20d a20d d 0622
a20d a20d s QTSTR:  LD      B,'"'           ; Terminating quote
a20f a20f d 50
a20f a20f s         LD      D,B             ; Quote to D
a210 a210 d e5
a210 a210 s DTSTR:  PUSH    HL              ; Save start
a211 a211 d 0eff
a211 a211 s         LD      C,-1            ; Set counter to -1
a213 a213 d 23
a213 a213 s QTSTLP: INC     HL              ; Move on
a214 a214 d 7e
a214 a214 s         LD      A,(HL)          ; Get byte
a215 a215 d 0c
a215 a215 s         INC     C               ; Count bytes
a216 a216 d b7
a216 a216 s         OR      A               ; End of line?
a217 a217 d ca22a2
a217 a217 s         JP      Z,CRTSTE        ; Yes - Create string entry
a21a a21a d ba
a21a a21a s         CP      D               ; Terminator D found?
a21b a21b d ca22a2
a21b a21b s         JP      Z,CRTSTE        ; Yes - Create string entry
a21e a21e d b8
a21e a21e s         CP      B               ; Terminator B found?
a21f a21f d c213a2
a21f a21f s         JP      NZ,QTSTLP       ; No - Keep looking
a222 a222 d fe22
a222 a222 s CRTSTE: CP      '"'             ; End with '"'?
a224 a224 d cc0599
a224 a224 s         CALL    Z,GETCHR        ; Yes - Get next character
a227 a227 d e3
a227 a227 s         EX      (SP),HL         ; Starting quote
a228 a228 d 23
a228 a228 s         INC     HL              ; First byte of string
a229 a229 d eb
a229 a229 s         EX      DE,HL           ; To DE
a22a a22a d 79
a22a a22a s         LD      A,C             ; Get length
a22b a22b d cd00a2
a22b a22b s         CALL    CRTMST          ; Create string entry
a22e a22e d 1104b1
a22e a22e s TSTOPL: LD      DE,TMPSTR       ; Temporary string
a231 a231 d 2af6b0
a231 a231 s         LD      HL,(TMSTPT)     ; Temporary string pool pointer
a234 a234 d 2229b1
a234 a234 s         LD      (FPREG),HL      ; Save address of string ptr
a237 a237 d 3e01
a237 a237 s         LD      A,1
a239 a239 d 32f2b0
a239 a239 s         LD      (TYPE),A        ; Set type to string
a23c a23c d cdb2a7
a23c a23c s         CALL    DETHL4          ; Move string to pool
a23f a23f d cd7597
a23f a23f s         CALL    CPDEHL          ; Out of string pool?
a242 a242 d 22f6b0
a242 a242 s         LD      (TMSTPT),HL     ; Save new pointer
a245 a245 d e1
a245 a245 s         POP     HL              ; Restore code string address
a246 a246 d 7e
a246 a246 s         LD      A,(HL)          ; Get next code byte
a247 a247 d c0
a247 a247 s         RET     NZ              ; Return if pool OK
a248 a248 d 1e1e
a248 a248 s         LD      E,ST            ; ?ST Error
a24a a24a d c3c194
a24a a24a s         JP      ERROR           ; String pool overflow
a24d a24d s 
a24d a24d d 23
a24d a24d s PRNUMS: INC     HL              ; Skip leading space
a24e a24e d cd0ca2
a24e a24e s PRS:    CALL    CRTST           ; Create string entry for it
a251 a251 d cd91a3
a251 a251 s PRS1:   CALL    GSTRCU          ; Current string to pool
a254 a254 d cda6a7
a254 a254 s         CALL    LOADFP          ; Move string block to BCDE
a257 a257 d 1c
a257 a257 s         INC     E               ; Length + 1
a258 a258 d 1d
a258 a258 s PRSLP:  DEC     E               ; Count characters
a259 a259 d c8
a259 a259 s         RET     Z               ; End of string
a25a a25a d 0a
a25a a25a s         LD      A,(BC)          ; Get byte to output
a25b a25b d cd8697
a25b a25b s         CALL    OUTC            ; Output character in A
a25e a25e d fe0d
a25e a25e s         CP      CR              ; Return?
a260 a260 d ccba9b
a260 a260 s         CALL    Z,DONULL        ; Yes - Do nulls
a263 a263 d 03
a263 a263 s         INC     BC              ; Next byte in string
a264 a264 d c358a2
a264 a264 s         JP      PRSLP           ; More characters to output
a267 a267 s 
a267 a267 d b7
a267 a267 s TESTR:  OR      A               ; Test if enough room
a268 a268 d 0e
a268 a268 s         .BYTE      0EH             ; No garbage collection done
a269 a269 d f1
a269 a269 s GRBDON: POP     AF              ; Garbage collection done
a26a a26a d f5
a26a a26a s         PUSH    AF              ; Save status
a26b a26b d 2a9fb0
a26b a26b s         LD      HL,(STRSPC)     ; Bottom of string space in use
a26e a26e d eb
a26e a26e s         EX      DE,HL           ; To DE
a26f a26f d 2a08b1
a26f a26f s         LD      HL,(STRBOT)     ; Bottom of string area
a272 a272 d 2f
a272 a272 s         CPL                     ; Negate length (Top down)
a273 a273 d 4f
a273 a273 s         LD      C,A             ; -Length to BC
a274 a274 d 06ff
a274 a274 s         LD      B,-1            ; BC = -ve length of string
a276 a276 d 09
a276 a276 s         ADD     HL,BC           ; Add to bottom of space in use
a277 a277 d 23
a277 a277 s         INC     HL              ; Plus one for 2's complement
a278 a278 d cd7597
a278 a278 s         CALL    CPDEHL          ; Below string RAM area?
a27b a27b d da85a2
a27b a27b s         JP      C,TESTOS        ; Tidy up if not done else err
a27e a27e d 2208b1
a27e a27e s         LD      (STRBOT),HL     ; Save new bottom of area
a281 a281 d 23
a281 a281 s         INC     HL              ; Point to first byte of string
a282 a282 d eb
a282 a282 s         EX      DE,HL           ; Address to DE
a283 a283 d f1
a283 a283 s POPAF:  POP     AF              ; Throw away status push
a284 a284 d c9
a284 a284 s         RET
a285 a285 s 
a285 a285 d f1
a285 a285 s TESTOS: POP     AF              ; Garbage collect been done?
a286 a286 d 1e1a
a286 a286 s         LD      E,OS            ; ?OS Error
a288 a288 d cac194
a288 a288 s         JP      Z,ERROR         ; Yes - Not enough string apace
a28b a28b d bf
a28b a28b s         CP      A               ; Flag garbage collect done
a28c a28c d f5
a28c a28c s         PUSH    AF              ; Save status
a28d a28d d 0169a2
a28d a28d s         LD      BC,GRBDON       ; Garbage collection done
a290 a290 d c5
a290 a290 s         PUSH    BC              ; Save for RETurn
a291 a291 d 2af4b0
a291 a291 s GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
a294 a294 d 2208b1
a294 a294 s GARBLP: LD      (STRBOT),HL     ; Reset string pointer
a297 a297 d 210000
a297 a297 s         LD      HL,0
a29a a29a d e5
a29a a29a s         PUSH    HL              ; Flag no string found
a29b a29b d 2a9fb0
a29b a29b s         LD      HL,(STRSPC)     ; Get bottom of string space
a29e a29e d e5
a29e a29e s         PUSH    HL              ; Save bottom of string space
a29f a29f d 21f8b0
a29f a29f s         LD      HL,TMSTPL       ; Temporary string pool
a2a2 a2a2 d eb
a2a2 a2a2 s GRBLP:  EX      DE,HL
a2a3 a2a3 d 2af6b0
a2a3 a2a3 s         LD      HL,(TMSTPT)     ; Temporary string pool pointer
a2a6 a2a6 d eb
a2a6 a2a6 s         EX      DE,HL
a2a7 a2a7 d cd7597
a2a7 a2a7 s         CALL    CPDEHL          ; Temporary string pool done?
a2aa a2aa d 01a2a2
a2aa a2aa s         LD      BC,GRBLP        ; Loop until string pool done
a2ad a2ad d c2f6a2
a2ad a2ad s         JP      NZ,STPOOL       ; No - See if in string area
a2b0 a2b0 d 2a1bb1
a2b0 a2b0 s         LD      HL,(PROGND)     ; Start of simple variables
a2b3 a2b3 d eb
a2b3 a2b3 s SMPVAR: EX      DE,HL
a2b4 a2b4 d 2a1db1
a2b4 a2b4 s         LD      HL,(VAREND)     ; End of simple variables
a2b7 a2b7 d eb
a2b7 a2b7 s         EX      DE,HL
a2b8 a2b8 d cd7597
a2b8 a2b8 s         CALL    CPDEHL          ; All simple strings done?
a2bb a2bb d cac9a2
a2bb a2bb s         JP      Z,ARRLP         ; Yes - Do string arrays
a2be a2be d 7e
a2be a2be s         LD      A,(HL)          ; Get type of variable
a2bf a2bf d 23
a2bf a2bf s         INC     HL
a2c0 a2c0 d 23
a2c0 a2c0 s         INC     HL
a2c1 a2c1 d b7
a2c1 a2c1 s         OR      A               ; "S" flag set if string
a2c2 a2c2 d cdf9a2
a2c2 a2c2 s         CALL    STRADD          ; See if string in string area
a2c5 a2c5 d c3b3a2
a2c5 a2c5 s         JP      SMPVAR          ; Loop until simple ones done
a2c8 a2c8 s 
a2c8 a2c8 d c1
a2c8 a2c8 s GNXARY: POP     BC              ; Scrap address of this array
a2c9 a2c9 d eb
a2c9 a2c9 s ARRLP:  EX      DE,HL
a2ca a2ca d 2a1fb1
a2ca a2ca s         LD      HL,(ARREND)     ; End of string arrays
a2cd a2cd d eb
a2cd a2cd s         EX      DE,HL
a2ce a2ce d cd7597
a2ce a2ce s         CALL    CPDEHL          ; All string arrays done?
a2d1 a2d1 d ca1fa3
a2d1 a2d1 s         JP      Z,SCNEND        ; Yes - Move string if found
a2d4 a2d4 d cda6a7
a2d4 a2d4 s         CALL    LOADFP          ; Get array name to BCDE
a2d7 a2d7 d 7b
a2d7 a2d7 s         LD      A,E             ; Get type of array     
a2d8 a2d8 d e5
a2d8 a2d8 s         PUSH    HL              ; Save address of num of dim'ns
a2d9 a2d9 d 09
a2d9 a2d9 s         ADD     HL,BC           ; Start of next array
a2da a2da d b7
a2da a2da s         OR      A               ; Test type of array
a2db a2db d f2c8a2
a2db a2db s         JP      P,GNXARY        ; Numeric array - Ignore it
a2de a2de d 220ab1
a2de a2de s         LD      (CUROPR),HL     ; Save address of next array
a2e1 a2e1 d e1
a2e1 a2e1 s         POP     HL              ; Get address of num of dim'ns
a2e2 a2e2 d 4e
a2e2 a2e2 s         LD      C,(HL)          ; BC = Number of dimensions
a2e3 a2e3 d 0600
a2e3 a2e3 s         LD      B,0
a2e5 a2e5 d 09
a2e5 a2e5 s         ADD     HL,BC           ; Two bytes per dimension size
a2e6 a2e6 d 09
a2e6 a2e6 s         ADD     HL,BC
a2e7 a2e7 d 23
a2e7 a2e7 s         INC     HL              ; Plus one for number of dim'ns
a2e8 a2e8 d eb
a2e8 a2e8 s GRBARY: EX      DE,HL
a2e9 a2e9 d 2a0ab1
a2e9 a2e9 s         LD      HL,(CUROPR)     ; Get address of next array
a2ec a2ec d eb
a2ec a2ec s         EX      DE,HL
a2ed a2ed d cd7597
a2ed a2ed s         CALL    CPDEHL          ; Is this array finished?
a2f0 a2f0 d cac9a2
a2f0 a2f0 s         JP      Z,ARRLP         ; Yes - Get next one
a2f3 a2f3 d 01e8a2
a2f3 a2f3 s         LD      BC,GRBARY       ; Loop until array all done
a2f6 a2f6 d c5
a2f6 a2f6 s STPOOL: PUSH    BC              ; Save return address
a2f7 a2f7 d f680
a2f7 a2f7 s         OR      80H             ; Flag string type
a2f9 a2f9 d 7e
a2f9 a2f9 s STRADD: LD      A,(HL)          ; Get string length
a2fa a2fa d 23
a2fa a2fa s         INC     HL
a2fb a2fb d 23
a2fb a2fb s         INC     HL
a2fc a2fc d 5e
a2fc a2fc s         LD      E,(HL)          ; Get LSB of string address
a2fd a2fd d 23
a2fd a2fd s         INC     HL
a2fe a2fe d 56
a2fe a2fe s         LD      D,(HL)          ; Get MSB of string address
a2ff a2ff d 23
a2ff a2ff s         INC     HL
a300 a300 d f0
a300 a300 s         RET     P               ; Not a string - Return
a301 a301 d b7
a301 a301 s         OR      A               ; Set flags on string length
a302 a302 d c8
a302 a302 s         RET     Z               ; Null string - Return
a303 a303 d 44
a303 a303 s         LD      B,H             ; Save variable pointer
a304 a304 d 4d
a304 a304 s         LD      C,L
a305 a305 d 2a08b1
a305 a305 s         LD      HL,(STRBOT)     ; Bottom of new area
a308 a308 d cd7597
a308 a308 s         CALL    CPDEHL          ; String been done?
a30b a30b d 60
a30b a30b s         LD      H,B             ; Restore variable pointer
a30c a30c d 69
a30c a30c s         LD      L,C
a30d a30d d d8
a30d a30d s         RET     C               ; String done - Ignore
a30e a30e d e1
a30e a30e s         POP     HL              ; Return address
a30f a30f d e3
a30f a30f s         EX      (SP),HL         ; Lowest available string area
a310 a310 d cd7597
a310 a310 s         CALL    CPDEHL          ; String within string area?
a313 a313 d e3
a313 a313 s         EX      (SP),HL         ; Lowest available string area
a314 a314 d e5
a314 a314 s         PUSH    HL              ; Re-save return address
a315 a315 d 60
a315 a315 s         LD      H,B             ; Restore variable pointer
a316 a316 d 69
a316 a316 s         LD      L,C
a317 a317 d d0
a317 a317 s         RET     NC              ; Outside string area - Ignore
a318 a318 d c1
a318 a318 s         POP     BC              ; Get return , Throw 2 away
a319 a319 d f1
a319 a319 s         POP     AF              ; 
a31a a31a d f1
a31a a31a s         POP     AF              ; 
a31b a31b d e5
a31b a31b s         PUSH    HL              ; Save variable pointer
a31c a31c d d5
a31c a31c s         PUSH    DE              ; Save address of current
a31d a31d d c5
a31d a31d s         PUSH    BC              ; Put back return address
a31e a31e d c9
a31e a31e s         RET                     ; Go to it
a31f a31f s 
a31f a31f d d1
a31f a31f s SCNEND: POP     DE              ; Addresses of strings
a320 a320 d e1
a320 a320 s         POP     HL              ; 
a321 a321 d 7d
a321 a321 s         LD      A,L             ; HL = 0 if no more to do
a322 a322 d b4
a322 a322 s         OR      H
a323 a323 d c8
a323 a323 s         RET     Z               ; No more to do - Return
a324 a324 d 2b
a324 a324 s         DEC     HL
a325 a325 d 46
a325 a325 s         LD      B,(HL)          ; MSB of address of string
a326 a326 d 2b
a326 a326 s         DEC     HL
a327 a327 d 4e
a327 a327 s         LD      C,(HL)          ; LSB of address of string
a328 a328 d e5
a328 a328 s         PUSH    HL              ; Save variable address
a329 a329 d 2b
a329 a329 s         DEC     HL
a32a a32a d 2b
a32a a32a s         DEC     HL
a32b a32b d 6e
a32b a32b s         LD      L,(HL)          ; HL = Length of string
a32c a32c d 2600
a32c a32c s         LD      H,0
a32e a32e d 09
a32e a32e s         ADD     HL,BC           ; Address of end of string+1
a32f a32f d 50
a32f a32f s         LD      D,B             ; String address to DE
a330 a330 d 59
a330 a330 s         LD      E,C
a331 a331 d 2b
a331 a331 s         DEC     HL              ; Last byte in string
a332 a332 d 44
a332 a332 s         LD      B,H             ; Address to BC
a333 a333 d 4d
a333 a333 s         LD      C,L
a334 a334 d 2a08b1
a334 a334 s         LD      HL,(STRBOT)     ; Current bottom of string area
a337 a337 d cd7c94
a337 a337 s         CALL    MOVSTR          ; Move string to new address
a33a a33a d e1
a33a a33a s         POP     HL              ; Restore variable address
a33b a33b d 71
a33b a33b s         LD      (HL),C          ; Save new LSB of address
a33c a33c d 23
a33c a33c s         INC     HL
a33d a33d d 70
a33d a33d s         LD      (HL),B          ; Save new MSB of address
a33e a33e d 69
a33e a33e s         LD      L,C             ; Next string area+1 to HL
a33f a33f d 60
a33f a33f s         LD      H,B
a340 a340 d 2b
a340 a340 s         DEC     HL              ; Next string area address
a341 a341 d c394a2
a341 a341 s         JP      GARBLP          ; Look for more strings
a344 a344 s 
a344 a344 d c5
a344 a344 s CONCAT: PUSH    BC              ; Save prec' opr & code string
a345 a345 d e5
a345 a345 s         PUSH    HL              ; 
a346 a346 d 2a29b1
a346 a346 s         LD      HL,(FPREG)      ; Get first string
a349 a349 d e3
a349 a349 s         EX      (SP),HL         ; Save first string
a34a a34a d cdfe9d
a34a a34a s         CALL    OPRND           ; Get second string
a34d a34d d e3
a34d a34d s         EX      (SP),HL         ; Restore first string
a34e a34e d cd799d
a34e a34e s         CALL    TSTSTR          ; Make sure it's a string
a351 a351 d 7e
a351 a351 s         LD      A,(HL)          ; Get length of second string
a352 a352 d e5
a352 a352 s         PUSH    HL              ; Save first string
a353 a353 d 2a29b1
a353 a353 s         LD      HL,(FPREG)      ; Get second string
a356 a356 d e5
a356 a356 s         PUSH    HL              ; Save second string
a357 a357 d 86
a357 a357 s         ADD     A,(HL)          ; Add length of second string
a358 a358 d 1e1c
a358 a358 s         LD      E,LS            ; ?LS Error
a35a a35a d dac194
a35a a35a s         JP      C,ERROR         ; String too long - Error
a35d a35d d cdfda1
a35d a35d s         CALL    MKTMST          ; Make temporary string
a360 a360 d d1
a360 a360 s         POP     DE              ; Get second string to DE
a361 a361 d cd95a3
a361 a361 s         CALL    GSTRDE          ; Move to string pool if needed
a364 a364 d e3
a364 a364 s         EX      (SP),HL         ; Get first string
a365 a365 d cd94a3
a365 a365 s         CALL    GSTRHL          ; Move to string pool if needed
a368 a368 d e5
a368 a368 s         PUSH    HL              ; Save first string
a369 a369 d 2a06b1
a369 a369 s         LD      HL,(TMPSTR+2)   ; Temporary string address
a36c a36c d eb
a36c a36c s         EX      DE,HL           ; To DE
a36d a36d d cd7ba3
a36d a36d s         CALL    SSTSA           ; First string to string area
a370 a370 d cd7ba3
a370 a370 s         CALL    SSTSA           ; Second string to string area
a373 a373 d 21939d
a373 a373 s         LD      HL,EVAL2        ; Return to evaluation loop
a376 a376 d e3
a376 a376 s         EX      (SP),HL         ; Save return,get code string
a377 a377 d e5
a377 a377 s         PUSH    HL              ; Save code string address
a378 a378 d c32ea2
a378 a378 s         JP      TSTOPL          ; To temporary string to pool
a37b a37b s 
a37b a37b d e1
a37b a37b s SSTSA:  POP     HL              ; Return address
a37c a37c d e3
a37c a37c s         EX      (SP),HL         ; Get string block,save return
a37d a37d d 7e
a37d a37d s         LD      A,(HL)          ; Get length of string
a37e a37e d 23
a37e a37e s         INC     HL
a37f a37f d 23
a37f a37f s         INC     HL
a380 a380 d 4e
a380 a380 s         LD      C,(HL)          ; Get LSB of string address
a381 a381 d 23
a381 a381 s         INC     HL
a382 a382 d 46
a382 a382 s         LD      B,(HL)          ; Get MSB of string address
a383 a383 d 6f
a383 a383 s         LD      L,A             ; Length to L
a384 a384 d 2c
a384 a384 s TOSTRA: INC     L               ; INC - DECed after
a385 a385 d 2d
a385 a385 s TSALP:  DEC     L               ; Count bytes moved
a386 a386 d c8
a386 a386 s         RET     Z               ; End of string - Return
a387 a387 d 0a
a387 a387 s         LD      A,(BC)          ; Get source
a388 a388 d 12
a388 a388 s         LD      (DE),A          ; Save destination
a389 a389 d 03
a389 a389 s         INC     BC              ; Next source
a38a a38a d 13
a38a a38a s         INC     DE              ; Next destination
a38b a38b d c385a3
a38b a38b s         JP      TSALP           ; Loop until string moved
a38e a38e s 
a38e a38e d cd799d
a38e a38e s GETSTR: CALL    TSTSTR          ; Make sure it's a string
a391 a391 d 2a29b1
a391 a391 s GSTRCU: LD      HL,(FPREG)      ; Get current string
a394 a394 d eb
a394 a394 s GSTRHL: EX      DE,HL           ; Save DE
a395 a395 d cdafa3
a395 a395 s GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
a398 a398 d eb
a398 a398 s         EX      DE,HL           ; Restore DE
a399 a399 d c0
a399 a399 s         RET     NZ              ; No - Return
a39a a39a d d5
a39a a39a s         PUSH    DE              ; Save string
a39b a39b d 50
a39b a39b s         LD      D,B             ; String block address to DE
a39c a39c d 59
a39c a39c s         LD      E,C
a39d a39d d 1b
a39d a39d s         DEC     DE              ; Point to length
a39e a39e d 4e
a39e a39e s         LD      C,(HL)          ; Get string length
a39f a39f d 2a08b1
a39f a39f s         LD      HL,(STRBOT)     ; Current bottom of string area
a3a2 a3a2 d cd7597
a3a2 a3a2 s         CALL    CPDEHL          ; Last one in string area?
a3a5 a3a5 d c2ada3
a3a5 a3a5 s         JP      NZ,POPHL        ; No - Return
a3a8 a3a8 d 47
a3a8 a3a8 s         LD      B,A             ; Clear B (A=0)
a3a9 a3a9 d 09
a3a9 a3a9 s         ADD     HL,BC           ; Remove string from str' area
a3aa a3aa d 2208b1
a3aa a3aa s         LD      (STRBOT),HL     ; Save new bottom of str' area
a3ad a3ad d e1
a3ad a3ad s POPHL:  POP     HL              ; Restore string
a3ae a3ae d c9
a3ae a3ae s         RET
a3af a3af s 
a3af a3af d 2af6b0
a3af a3af s BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
a3b2 a3b2 d 2b
a3b2 a3b2 s         DEC     HL              ; Back
a3b3 a3b3 d 46
a3b3 a3b3 s         LD      B,(HL)          ; Get MSB of address
a3b4 a3b4 d 2b
a3b4 a3b4 s         DEC     HL              ; Back
a3b5 a3b5 d 4e
a3b5 a3b5 s         LD      C,(HL)          ; Get LSB of address
a3b6 a3b6 d 2b
a3b6 a3b6 s         DEC     HL              ; Back
a3b7 a3b7 d 2b
a3b7 a3b7 s         DEC     HL              ; Back
a3b8 a3b8 d cd7597
a3b8 a3b8 s         CALL    CPDEHL          ; String last in string pool?
a3bb a3bb d c0
a3bb a3bb s         RET     NZ              ; Yes - Leave it
a3bc a3bc d 22f6b0
a3bc a3bc s         LD      (TMSTPT),HL     ; Save new string pool top
a3bf a3bf d c9
a3bf a3bf s         RET
a3c0 a3c0 s 
a3c0 a3c0 d 013fa1
a3c0 a3c0 s LEN:    LD      BC,PASSA        ; To return integer A
a3c3 a3c3 d c5
a3c3 a3c3 s         PUSH    BC              ; Save address
a3c4 a3c4 d cd8ea3
a3c4 a3c4 s GETLEN: CALL    GETSTR          ; Get string and its length
a3c7 a3c7 d af
a3c7 a3c7 s         XOR     A
a3c8 a3c8 d 57
a3c8 a3c8 s         LD      D,A             ; Clear D
a3c9 a3c9 d 32f2b0
a3c9 a3c9 s         LD      (TYPE),A        ; Set type to numeric
a3cc a3cc d 7e
a3cc a3cc s         LD      A,(HL)          ; Get length of string
a3cd a3cd d b7
a3cd a3cd s         OR      A               ; Set status flags
a3ce a3ce d c9
a3ce a3ce s         RET
a3cf a3cf s 
a3cf a3cf d 013fa1
a3cf a3cf s ASC:    LD      BC,PASSA        ; To return integer A
a3d2 a3d2 d c5
a3d2 a3d2 s         PUSH    BC              ; Save address
a3d3 a3d3 d cdc4a3
a3d3 a3d3 s GTFLNM: CALL    GETLEN          ; Get length of string
a3d6 a3d6 d cacf99
a3d6 a3d6 s         JP      Z,FCERR         ; Null string - Error
a3d9 a3d9 d 23
a3d9 a3d9 s         INC     HL
a3da a3da d 23
a3da a3da s         INC     HL
a3db a3db d 5e
a3db a3db s         LD      E,(HL)          ; Get LSB of address
a3dc a3dc d 23
a3dc a3dc s         INC     HL
a3dd a3dd d 56
a3dd a3dd s         LD      D,(HL)          ; Get MSB of address
a3de a3de d 1a
a3de a3de s         LD      A,(DE)          ; Get first byte of string
a3df a3df d c9
a3df a3df s         RET
a3e0 a3e0 s 
a3e0 a3e0 d 3e01
a3e0 a3e0 s CHR:    LD      A,1             ; One character string
a3e2 a3e2 d cdfda1
a3e2 a3e2 s         CALL    MKTMST          ; Make a temporary string
a3e5 a3e5 d cdd9a4
a3e5 a3e5 s         CALL    MAKINT          ; Make it integer A
a3e8 a3e8 d 2a06b1
a3e8 a3e8 s         LD      HL,(TMPSTR+2)   ; Get address of string
a3eb a3eb d 73
a3eb a3eb s         LD      (HL),E          ; Save character
a3ec a3ec d c1
a3ec a3ec s TOPOOL: POP     BC              ; Clean up stack
a3ed a3ed d c32ea2
a3ed a3ed s         JP      TSTOPL          ; Temporary string to pool
a3f0 a3f0 s 
a3f0 a3f0 d cd89a4
a3f0 a3f0 s LEFT:   CALL    LFRGNM          ; Get number and ending ")"
a3f3 a3f3 d af
a3f3 a3f3 s         XOR     A               ; Start at first byte in string
a3f4 a3f4 d e3
a3f4 a3f4 s RIGHT1: EX      (SP),HL         ; Save code string,Get string
a3f5 a3f5 d 4f
a3f5 a3f5 s         LD      C,A             ; Starting position in string
a3f6 a3f6 d e5
a3f6 a3f6 s MID1:   PUSH    HL              ; Save string block address
a3f7 a3f7 d 7e
a3f7 a3f7 s         LD      A,(HL)          ; Get length of string
a3f8 a3f8 d b8
a3f8 a3f8 s         CP      B               ; Compare with number given
a3f9 a3f9 d dafea3
a3f9 a3f9 s         JP      C,ALLFOL        ; All following bytes required
a3fc a3fc d 78
a3fc a3fc s         LD      A,B             ; Get new length
a3fd a3fd d 11
a3fd a3fd s         .BYTE      11H             ; Skip "LD C,0"
a3fe a3fe d 0e00
a3fe a3fe s ALLFOL: LD      C,0             ; First byte of string
a400 a400 d c5
a400 a400 s         PUSH    BC              ; Save position in string
a401 a401 d cd67a2
a401 a401 s         CALL    TESTR           ; See if enough string space
a404 a404 d c1
a404 a404 s         POP     BC              ; Get position in string
a405 a405 d e1
a405 a405 s         POP     HL              ; Restore string block address
a406 a406 d e5
a406 a406 s         PUSH    HL              ; And re-save it
a407 a407 d 23
a407 a407 s         INC     HL
a408 a408 d 23
a408 a408 s         INC     HL
a409 a409 d 46
a409 a409 s         LD      B,(HL)          ; Get LSB of address
a40a a40a d 23
a40a a40a s         INC     HL
a40b a40b d 66
a40b a40b s         LD      H,(HL)          ; Get MSB of address
a40c a40c d 68
a40c a40c s         LD      L,B             ; HL = address of string
a40d a40d d 0600
a40d a40d s         LD      B,0             ; BC = starting address
a40f a40f d 09
a40f a40f s         ADD     HL,BC           ; Point to that byte
a410 a410 d 44
a410 a410 s         LD      B,H             ; BC = source string
a411 a411 d 4d
a411 a411 s         LD      C,L
a412 a412 d cd00a2
a412 a412 s         CALL    CRTMST          ; Create a string entry
a415 a415 d 6f
a415 a415 s         LD      L,A             ; Length of new string
a416 a416 d cd84a3
a416 a416 s         CALL    TOSTRA          ; Move string to string area
a419 a419 d d1
a419 a419 s         POP     DE              ; Clear stack
a41a a41a d cd95a3
a41a a41a s         CALL    GSTRDE          ; Move to string pool if needed
a41d a41d d c32ea2
a41d a41d s         JP      TSTOPL          ; Temporary string to pool
a420 a420 s 
a420 a420 d cd89a4
a420 a420 s RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
a423 a423 d d1
a423 a423 s         POP     DE              ; Get string length
a424 a424 d d5
a424 a424 s         PUSH    DE              ; And re-save
a425 a425 d 1a
a425 a425 s         LD      A,(DE)          ; Get length
a426 a426 d 90
a426 a426 s         SUB     B               ; Move back N bytes
a427 a427 d c3f4a3
a427 a427 s         JP      RIGHT1          ; Go and get sub-string
a42a a42a s 
a42a a42a d eb
a42a a42a s MID:    EX      DE,HL           ; Get code string address
a42b a42b d 7e
a42b a42b s         LD      A,(HL)          ; Get next byte ',' or ")"
a42c a42c d cd8ea4
a42c a42c s         CALL    MIDNUM          ; Get number supplied
a42f a42f d 04
a42f a42f s         INC     B               ; Is it character zero?
a430 a430 d 05
a430 a430 s         DEC     B
a431 a431 d cacf99
a431 a431 s         JP      Z,FCERR         ; Yes - Error
a434 a434 d c5
a434 a434 s         PUSH    BC              ; Save starting position
a435 a435 d 1eff
a435 a435 s         LD      E,255           ; All of string
a437 a437 d fe29
a437 a437 s         CP      ')'             ; Any length given?
a439 a439 d ca43a4
a439 a439 s         JP      Z,RSTSTR        ; No - Rest of string
a43c a43c d cd7b97
a43c a43c s         CALL    CHKSYN          ; Make sure ',' follows
a43f a43f d 2c
a43f a43f s         .BYTE      ','
a440 a440 d cdd6a4
a440 a440 s         CALL    GETINT          ; Get integer 0-255
a443 a443 d cd7b97
a443 a443 s RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
a446 a446 d 29
a446 a446 s         .BYTE      ")"
a447 a447 d f1
a447 a447 s         POP     AF              ; Restore starting position
a448 a448 d e3
a448 a448 s         EX      (SP),HL         ; Get string,8ave code string
a449 a449 d 01f6a3
a449 a449 s         LD      BC,MID1         ; Continuation of MID$ routine
a44c a44c d c5
a44c a44c s         PUSH    BC              ; Save for return
a44d a44d d 3d
a44d a44d s         DEC     A               ; Starting position-1
a44e a44e d be
a44e a44e s         CP      (HL)            ; Compare with length
a44f a44f d 0600
a44f a44f s         LD      B,0             ; Zero bytes length
a451 a451 d d0
a451 a451 s         RET     NC              ; Null string if start past end
a452 a452 d 4f
a452 a452 s         LD      C,A             ; Save starting position-1
a453 a453 d 7e
a453 a453 s         LD      A,(HL)          ; Get length of string
a454 a454 d 91
a454 a454 s         SUB     C               ; Subtract start
a455 a455 d bb
a455 a455 s         CP      E               ; Enough string for it?
a456 a456 d 47
a456 a456 s         LD      B,A             ; Save maximum length available
a457 a457 d d8
a457 a457 s         RET     C               ; Truncate string if needed
a458 a458 d 43
a458 a458 s         LD      B,E             ; Set specified length
a459 a459 d c9
a459 a459 s         RET                     ; Go and create string
a45a a45a s 
a45a a45a d cdc4a3
a45a a45a s VAL:    CALL    GETLEN          ; Get length of string
a45d a45d d ca77a5
a45d a45d s         JP      Z,RESZER        ; Result zero
a460 a460 d 5f
a460 a460 s         LD      E,A             ; Save length
a461 a461 d 23
a461 a461 s         INC     HL
a462 a462 d 23
a462 a462 s         INC     HL
a463 a463 d 7e
a463 a463 s         LD      A,(HL)          ; Get LSB of address
a464 a464 d 23
a464 a464 s         INC     HL
a465 a465 d 66
a465 a465 s         LD      H,(HL)          ; Get MSB of address
a466 a466 d 6f
a466 a466 s         LD      L,A             ; HL = String address
a467 a467 d e5
a467 a467 s         PUSH    HL              ; Save string address
a468 a468 d 19
a468 a468 s         ADD     HL,DE
a469 a469 d 46
a469 a469 s         LD      B,(HL)          ; Get end of string+1 byte
a46a a46a d 72
a46a a46a s         LD      (HL),D          ; Zero it to terminate
a46b a46b d e3
a46b a46b s         EX      (SP),HL         ; Save string end,get start
a46c a46c d c5
a46c a46c s         PUSH    BC              ; Save end+1 byte
a46d a46d d 7e
a46d a46d s         LD      A,(HL)          ; Get starting byte
a46e a46e d fe24
a46e a46e s     CP	'$'		; Hex number indicated? [function added]
a470 a470 d c278a4
a470 a470 s     JP	NZ,VAL1
a473 a473 d cda4ac
a473 a473 s     CALL	HEXTFP		; Convert Hex to FPREG
a476 a476 d 180d
a476 a476 s     JR	VAL3
a478 a478 d fe25
a478 a478 s VAL1:	CP	'%'		; Binary number indicated? [function added]
a47a a47a d c282a4
a47a a47a s     JP	NZ,VAL2
a47d a47d d cd14ad
a47d a47d s     CALL	BINTFP		; Convert Bin to FPREG
a480 a480 d 1803
a480 a480 s     JR	VAL3
a482 a482 d cd5ea8
a482 a482 s VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
a485 a485 d c1
a485 a485 s VAL3:   POP     BC              ; Restore end+1 byte
a486 a486 d e1
a486 a486 s         POP     HL              ; Restore end+1 address
a487 a487 d 70
a487 a487 s         LD      (HL),B          ; Put back original byte
a488 a488 d c9
a488 a488 s         RET
a489 a489 s 
a489 a489 d eb
a489 a489 s LFRGNM: EX      DE,HL           ; Code string address to HL
a48a a48a d cd7b97
a48a a48a s         CALL    CHKSYN          ; Make sure ")" follows
a48d a48d d 29
a48d a48d s         .BYTE      ")"
a48e a48e d c1
a48e a48e s MIDNUM: POP     BC              ; Get return address
a48f a48f d d1
a48f a48f s         POP     DE              ; Get number supplied
a490 a490 d c5
a490 a490 s         PUSH    BC              ; Re-save return address
a491 a491 d 43
a491 a491 s         LD      B,E             ; Number to B
a492 a492 d c9
a492 a492 s         RET
a493 a493 s 
a493 a493 d cdd9a4
a493 a493 s INP:    CALL    MAKINT          ; Make it integer A
a496 a496 d 3284b0
a496 a496 s         LD      (INPORT),A      ; Set input port
a499 a499 d cd83b0
a499 a499 s         CALL    INPSUB          ; Get input from port
a49c a49c d c33fa1
a49c a49c s         JP      PASSA           ; Return integer A
a49f a49f s 
a49f a49f d cdc3a4
a49f a49f s POUT:   CALL    SETIO           ; Set up port number
a4a2 a4a2 d c34bb0
a4a2 a4a2 s         JP      OUTSUB          ; Output data and return
a4a5 a4a5 s 
a4a5 a4a5 d cdc3a4
a4a5 a4a5 s WAIT:   CALL    SETIO           ; Set up port number
a4a8 a4a8 d f5
a4a8 a4a8 s         PUSH    AF              ; Save AND mask
a4a9 a4a9 d 1e00
a4a9 a4a9 s         LD      E,0             ; Assume zero if none given
a4ab a4ab d 2b
a4ab a4ab s         DEC     HL              ; DEC 'cos GETCHR INCs
a4ac a4ac d cd0599
a4ac a4ac s         CALL    GETCHR          ; Get next character
a4af a4af d cab9a4
a4af a4af s         JP      Z,NOXOR         ; No XOR byte given
a4b2 a4b2 d cd7b97
a4b2 a4b2 s         CALL    CHKSYN          ; Make sure ',' follows
a4b5 a4b5 d 2c
a4b5 a4b5 s         .BYTE      ','
a4b6 a4b6 d cdd6a4
a4b6 a4b6 s         CALL    GETINT          ; Get integer 0-255 to XOR with
a4b9 a4b9 d c1
a4b9 a4b9 s NOXOR:  POP     BC              ; Restore AND mask
a4ba a4ba d cd83b0
a4ba a4ba s WAITLP: CALL    INPSUB          ; Get input
a4bd a4bd d ab
a4bd a4bd s         XOR     E               ; Flip selected bits
a4be a4be d a0
a4be a4be s         AND     B               ; Result non-zero?
a4bf a4bf d cabaa4
a4bf a4bf s         JP      Z,WAITLP        ; No = keep waiting
a4c2 a4c2 d c9
a4c2 a4c2 s         RET
a4c3 a4c3 s 
a4c3 a4c3 d cdd6a4
a4c3 a4c3 s SETIO:  CALL    GETINT          ; Get integer 0-255
a4c6 a4c6 d 3284b0
a4c6 a4c6 s         LD      (INPORT),A      ; Set input port
a4c9 a4c9 d 324cb0
a4c9 a4c9 s         LD      (OTPORT),A      ; Set output port
a4cc a4cc d cd7b97
a4cc a4cc s         CALL    CHKSYN          ; Make sure ',' follows
a4cf a4cf d 2c
a4cf a4cf s         .BYTE      ','
a4d0 a4d0 d c3d6a4
a4d0 a4d0 s         JP      GETINT          ; Get integer 0-255 and return
a4d3 a4d3 s 
a4d3 a4d3 d cd0599
a4d3 a4d3 s FNDNUM: CALL    GETCHR          ; Get next character
a4d6 a4d6 d cd759d
a4d6 a4d6 s GETINT: CALL    GETNUM          ; Get a number from 0 to 255
a4d9 a4d9 d cdb499
a4d9 a4d9 s MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
a4dc a4dc d 7a
a4dc a4dc s         LD      A,D             ; Get MSB of number
a4dd a4dd d b7
a4dd a4dd s         OR      A               ; Zero?
a4de a4de d c2cf99
a4de a4de s         JP      NZ,FCERR        ; No - Error
a4e1 a4e1 d 2b
a4e1 a4e1 s         DEC     HL              ; DEC 'cos GETCHR INCs
a4e2 a4e2 d cd0599
a4e2 a4e2 s         CALL    GETCHR          ; Get next character
a4e5 a4e5 d 7b
a4e5 a4e5 s         LD      A,E             ; Get number to A
a4e6 a4e6 d c9
a4e6 a4e6 s         RET
a4e7 a4e7 s 
a4e7 a4e7 d cdba99
a4e7 a4e7 s PEEK:   CALL    DEINT           ; Get memory address
a4ea a4ea d 1a
a4ea a4ea s         LD      A,(DE)          ; Get byte in memory
a4eb a4eb d c33fa1
a4eb a4eb s         JP      PASSA           ; Return integer A
a4ee a4ee s 
a4ee a4ee d cd759d
a4ee a4ee s POKE:   CALL    GETNUM          ; Get memory address
a4f1 a4f1 d cdba99
a4f1 a4f1 s         CALL    DEINT           ; Get integer -32768 to 3276
a4f4 a4f4 d d5
a4f4 a4f4 s         PUSH    DE              ; Save memory address
a4f5 a4f5 d cd7b97
a4f5 a4f5 s         CALL    CHKSYN          ; Make sure ',' follows
a4f8 a4f8 d 2c
a4f8 a4f8 s         .BYTE      ','
a4f9 a4f9 d cdd6a4
a4f9 a4f9 s         CALL    GETINT          ; Get integer 0-255
a4fc a4fc d d1
a4fc a4fc s         POP     DE              ; Restore memory address
a4fd a4fd d 12
a4fd a4fd s         LD      (DE),A          ; Load it into memory
a4fe a4fe d c9
a4fe a4fe s         RET
a4ff a4ff s 
a4ff a4ff d 21d5a9
a4ff a4ff s ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
a502 a502 d cda6a7
a502 a502 s ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
a505 a505 d c311a5
a505 a505 s         JP      FPADD           ; Add BCDE to FPREG
a508 a508 s 
a508 a508 d cda6a7
a508 a508 s SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
a50b a50b d 21
a50b a50b s         .BYTE      21H             ; Skip "POP BC" and "POP DE"
a50c a50c d c1
a50c a50c s PSUB:   POP     BC              ; Get FP number from stack
a50d a50d d d1
a50d a50d s         POP     DE
a50e a50e d cd80a7
a50e a50e s SUBCDE: CALL    INVSGN          ; Negate FPREG
a511 a511 d 78
a511 a511 s FPADD:  LD      A,B             ; Get FP exponent
a512 a512 d b7
a512 a512 s         OR      A               ; Is number zero?
a513 a513 d c8
a513 a513 s         RET     Z               ; Yes - Nothing to add
a514 a514 d 3a2cb1
a514 a514 s         LD      A,(FPEXP)       ; Get FPREG exponent
a517 a517 d b7
a517 a517 s         OR      A               ; Is this number zero?
a518 a518 d ca98a7
a518 a518 s         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
a51b a51b d 90
a51b a51b s         SUB     B               ; BCDE number larger?
a51c a51c d d22ba5
a51c a51c s         JP      NC,NOSWAP       ; No - Don't swap them
a51f a51f d 2f
a51f a51f s         CPL                     ; Two's complement
a520 a520 d 3c
a520 a520 s         INC     A               ;  FP exponent
a521 a521 d eb
a521 a521 s         EX      DE,HL
a522 a522 d cd88a7
a522 a522 s         CALL    STAKFP          ; Put FPREG on stack
a525 a525 d eb
a525 a525 s         EX      DE,HL
a526 a526 d cd98a7
a526 a526 s         CALL    FPBCDE          ; Move BCDE to FPREG
a529 a529 d c1
a529 a529 s         POP     BC              ; Restore number from stack
a52a a52a d d1
a52a a52a s         POP     DE
a52b a52b d fe19
a52b a52b s NOSWAP: CP      24+1            ; Second number insignificant?
a52d a52d d d0
a52d a52d s         RET     NC              ; Yes - First number is result
a52e a52e d f5
a52e a52e s         PUSH    AF              ; Save number of bits to scale
a52f a52f d cdbda7
a52f a52f s         CALL    SIGNS           ; Set MSBs & sign of result
a532 a532 d 67
a532 a532 s         LD      H,A             ; Save sign of result
a533 a533 d f1
a533 a533 s         POP     AF              ; Restore scaling factor
a534 a534 d cdd6a5
a534 a534 s         CALL    SCALE           ; Scale BCDE to same exponent
a537 a537 d b4
a537 a537 s         OR      H               ; Result to be positive?
a538 a538 d 2129b1
a538 a538 s         LD      HL,FPREG        ; Point to FPREG
a53b a53b d f251a5
a53b a53b s         JP      P,MINCDE        ; No - Subtract FPREG from CDE
a53e a53e d cdb6a5
a53e a53e s         CALL    PLUCDE          ; Add FPREG to CDE
a541 a541 d d297a5
a541 a541 s         JP      NC,RONDUP       ; No overflow - Round it up
a544 a544 d 23
a544 a544 s         INC     HL              ; Point to exponent
a545 a545 d 34
a545 a545 s         INC     (HL)            ; Increment it
a546 a546 d cabc94
a546 a546 s         JP      Z,OVERR         ; Number overflowed - Error
a549 a549 d 2e01
a549 a549 s         LD      L,1             ; 1 bit to shift right
a54b a54b d cdeca5
a54b a54b s         CALL    SHRT1           ; Shift result right
a54e a54e d c397a5
a54e a54e s         JP      RONDUP          ; Round it up
a551 a551 s 
a551 a551 d af
a551 a551 s MINCDE: XOR     A               ; Clear A and carry
a552 a552 d 90
a552 a552 s         SUB     B               ; Negate exponent
a553 a553 d 47
a553 a553 s         LD      B,A             ; Re-save exponent
a554 a554 d 7e
a554 a554 s         LD      A,(HL)          ; Get LSB of FPREG
a555 a555 d 9b
a555 a555 s         SBC     A, E            ; Subtract LSB of BCDE
a556 a556 d 5f
a556 a556 s         LD      E,A             ; Save LSB of BCDE
a557 a557 d 23
a557 a557 s         INC     HL
a558 a558 d 7e
a558 a558 s         LD      A,(HL)          ; Get NMSB of FPREG
a559 a559 d 9a
a559 a559 s         SBC     A,D             ; Subtract NMSB of BCDE
a55a a55a d 57
a55a a55a s         LD      D,A             ; Save NMSB of BCDE
a55b a55b d 23
a55b a55b s         INC     HL
a55c a55c d 7e
a55c a55c s         LD      A,(HL)          ; Get MSB of FPREG
a55d a55d d 99
a55d a55d s         SBC     A,C             ; Subtract MSB of BCDE
a55e a55e d 4f
a55e a55e s         LD      C,A             ; Save MSB of BCDE
a55f a55f d dcc2a5
a55f a55f s CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
a562 a562 s 
a562 a562 d 68
a562 a562 s BNORM:  LD      L,B             ; L = Exponent
a563 a563 d 63
a563 a563 s         LD      H,E             ; H = LSB
a564 a564 d af
a564 a564 s         XOR     A
a565 a565 d 47
a565 a565 s BNRMLP: LD      B,A             ; Save bit count
a566 a566 d 79
a566 a566 s         LD      A,C             ; Get MSB
a567 a567 d b7
a567 a567 s         OR      A               ; Is it zero?
a568 a568 d c284a5
a568 a568 s         JP      NZ,PNORM        ; No - Do it bit at a time
a56b a56b d 4a
a56b a56b s         LD      C,D             ; MSB = NMSB
a56c a56c d 54
a56c a56c s         LD      D,H             ; NMSB= LSB
a56d a56d d 65
a56d a56d s         LD      H,L             ; LSB = VLSB
a56e a56e d 6f
a56e a56e s         LD      L,A             ; VLSB= 0
a56f a56f d 78
a56f a56f s         LD      A,B             ; Get exponent
a570 a570 d d608
a570 a570 s         SUB     8               ; Count 8 bits
a572 a572 d fee0
a572 a572 s         CP      -24-8           ; Was number zero?
a574 a574 d c265a5
a574 a574 s         JP      NZ,BNRMLP       ; No - Keep normalising
a577 a577 d af
a577 a577 s RESZER: XOR     A               ; Result is zero
a578 a578 d 322cb1
a578 a578 s SAVEXP: LD      (FPEXP),A       ; Save result as zero
a57b a57b d c9
a57b a57b s         RET
a57c a57c s 
a57c a57c d 05
a57c a57c s NORMAL: DEC     B               ; Count bits
a57d a57d d 29
a57d a57d s         ADD     HL,HL           ; Shift HL left
a57e a57e d 7a
a57e a57e s         LD      A,D             ; Get NMSB
a57f a57f d 17
a57f a57f s         RLA                     ; Shift left with last bit
a580 a580 d 57
a580 a580 s         LD      D,A             ; Save NMSB
a581 a581 d 79
a581 a581 s         LD      A,C             ; Get MSB
a582 a582 d 8f
a582 a582 s         ADC     A,A             ; Shift left with last bit
a583 a583 d 4f
a583 a583 s         LD      C,A             ; Save MSB
a584 a584 d f27ca5
a584 a584 s PNORM:  JP      P,NORMAL        ; Not done - Keep going
a587 a587 d 78
a587 a587 s         LD      A,B             ; Number of bits shifted
a588 a588 d 5c
a588 a588 s         LD      E,H             ; Save HL in EB
a589 a589 d 45
a589 a589 s         LD      B,L
a58a a58a d b7
a58a a58a s         OR      A               ; Any shifting done?
a58b a58b d ca97a5
a58b a58b s         JP      Z,RONDUP        ; No - Round it up
a58e a58e d 212cb1
a58e a58e s         LD      HL,FPEXP        ; Point to exponent
a591 a591 d 86
a591 a591 s         ADD     A,(HL)          ; Add shifted bits
a592 a592 d 77
a592 a592 s         LD      (HL),A          ; Re-save exponent
a593 a593 d d277a5
a593 a593 s         JP      NC,RESZER       ; Underflow - Result is zero
a596 a596 d c8
a596 a596 s         RET     Z               ; Result is zero
a597 a597 d 78
a597 a597 s RONDUP: LD      A,B             ; Get VLSB of number
a598 a598 d 212cb1
a598 a598 s RONDB:  LD      HL,FPEXP        ; Point to exponent
a59b a59b d b7
a59b a59b s         OR      A               ; Any rounding?
a59c a59c d fca9a5
a59c a59c s         CALL    M,FPROND        ; Yes - Round number up
a59f a59f d 46
a59f a59f s         LD      B,(HL)          ; B = Exponent
a5a0 a5a0 d 23
a5a0 a5a0 s         INC     HL
a5a1 a5a1 d 7e
a5a1 a5a1 s         LD      A,(HL)          ; Get sign of result
a5a2 a5a2 d e680
a5a2 a5a2 s         AND     10000000B       ; Only bit 7 needed
a5a4 a5a4 d a9
a5a4 a5a4 s         XOR     C               ; Set correct sign
a5a5 a5a5 d 4f
a5a5 a5a5 s         LD      C,A             ; Save correct sign in number
a5a6 a5a6 d c398a7
a5a6 a5a6 s         JP      FPBCDE          ; Move BCDE to FPREG
a5a9 a5a9 s 
a5a9 a5a9 d 1c
a5a9 a5a9 s FPROND: INC     E               ; Round LSB
a5aa a5aa d c0
a5aa a5aa s         RET     NZ              ; Return if ok
a5ab a5ab d 14
a5ab a5ab s         INC     D               ; Round NMSB
a5ac a5ac d c0
a5ac a5ac s         RET     NZ              ; Return if ok
a5ad a5ad d 0c
a5ad a5ad s         INC     C               ; Round MSB
a5ae a5ae d c0
a5ae a5ae s         RET     NZ              ; Return if ok
a5af a5af d 0e80
a5af a5af s         LD      C,80H           ; Set normal value
a5b1 a5b1 d 34
a5b1 a5b1 s         INC     (HL)            ; Increment exponent
a5b2 a5b2 d c0
a5b2 a5b2 s         RET     NZ              ; Return if ok
a5b3 a5b3 d c3bc94
a5b3 a5b3 s         JP      OVERR           ; Overflow error
a5b6 a5b6 s 
a5b6 a5b6 d 7e
a5b6 a5b6 s PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
a5b7 a5b7 d 83
a5b7 a5b7 s         ADD     A,E             ; Add LSB of BCDE
a5b8 a5b8 d 5f
a5b8 a5b8 s         LD      E,A             ; Save LSB of BCDE
a5b9 a5b9 d 23
a5b9 a5b9 s         INC     HL
a5ba a5ba d 7e
a5ba a5ba s         LD      A,(HL)          ; Get NMSB of FPREG
a5bb a5bb d 8a
a5bb a5bb s         ADC     A,D             ; Add NMSB of BCDE
a5bc a5bc d 57
a5bc a5bc s         LD      D,A             ; Save NMSB of BCDE
a5bd a5bd d 23
a5bd a5bd s         INC     HL
a5be a5be d 7e
a5be a5be s         LD      A,(HL)          ; Get MSB of FPREG
a5bf a5bf d 89
a5bf a5bf s         ADC     A,C             ; Add MSB of BCDE
a5c0 a5c0 d 4f
a5c0 a5c0 s         LD      C,A             ; Save MSB of BCDE
a5c1 a5c1 d c9
a5c1 a5c1 s         RET
a5c2 a5c2 s 
a5c2 a5c2 d 212db1
a5c2 a5c2 s COMPL:  LD      HL,SGNRES       ; Sign of result
a5c5 a5c5 d 7e
a5c5 a5c5 s         LD      A,(HL)          ; Get sign of result
a5c6 a5c6 d 2f
a5c6 a5c6 s         CPL                     ; Negate it
a5c7 a5c7 d 77
a5c7 a5c7 s         LD      (HL),A          ; Put it back
a5c8 a5c8 d af
a5c8 a5c8 s         XOR     A
a5c9 a5c9 d 6f
a5c9 a5c9 s         LD      L,A             ; Set L to zero
a5ca a5ca d 90
a5ca a5ca s         SUB     B               ; Negate exponent,set carry
a5cb a5cb d 47
a5cb a5cb s         LD      B,A             ; Re-save exponent
a5cc a5cc d 7d
a5cc a5cc s         LD      A,L             ; Load zero
a5cd a5cd d 9b
a5cd a5cd s         SBC     A,E             ; Negate LSB
a5ce a5ce d 5f
a5ce a5ce s         LD      E,A             ; Re-save LSB
a5cf a5cf d 7d
a5cf a5cf s         LD      A,L             ; Load zero
a5d0 a5d0 d 9a
a5d0 a5d0 s         SBC     A,D             ; Negate NMSB
a5d1 a5d1 d 57
a5d1 a5d1 s         LD      D,A             ; Re-save NMSB
a5d2 a5d2 d 7d
a5d2 a5d2 s         LD      A,L             ; Load zero
a5d3 a5d3 d 99
a5d3 a5d3 s         SBC     A,C             ; Negate MSB
a5d4 a5d4 d 4f
a5d4 a5d4 s         LD      C,A             ; Re-save MSB
a5d5 a5d5 d c9
a5d5 a5d5 s         RET
a5d6 a5d6 s 
a5d6 a5d6 d 0600
a5d6 a5d6 s SCALE:  LD      B,0             ; Clear underflow
a5d8 a5d8 d d608
a5d8 a5d8 s SCALLP: SUB     8               ; 8 bits (a whole byte)?
a5da a5da d dae5a5
a5da a5da s         JP      C,SHRITE        ; No - Shift right A bits
a5dd a5dd d 43
a5dd a5dd s         LD      B,E             ; <- Shift
a5de a5de d 5a
a5de a5de s         LD      E,D             ; <- right
a5df a5df d 51
a5df a5df s         LD      D,C             ; <- eight
a5e0 a5e0 d 0e00
a5e0 a5e0 s         LD      C,0             ; <- bits
a5e2 a5e2 d c3d8a5
a5e2 a5e2 s         JP      SCALLP          ; More bits to shift
a5e5 a5e5 s 
a5e5 a5e5 d c609
a5e5 a5e5 s SHRITE: ADD     A,8+1           ; Adjust count
a5e7 a5e7 d 6f
a5e7 a5e7 s         LD      L,A             ; Save bits to shift
a5e8 a5e8 d af
a5e8 a5e8 s SHRLP:  XOR     A               ; Flag for all done
a5e9 a5e9 d 2d
a5e9 a5e9 s         DEC     L               ; All shifting done?
a5ea a5ea d c8
a5ea a5ea s         RET     Z               ; Yes - Return
a5eb a5eb d 79
a5eb a5eb s         LD      A,C             ; Get MSB
a5ec a5ec d 1f
a5ec a5ec s SHRT1:  RRA                     ; Shift it right
a5ed a5ed d 4f
a5ed a5ed s         LD      C,A             ; Re-save
a5ee a5ee d 7a
a5ee a5ee s         LD      A,D             ; Get NMSB
a5ef a5ef d 1f
a5ef a5ef s         RRA                     ; Shift right with last bit
a5f0 a5f0 d 57
a5f0 a5f0 s         LD      D,A             ; Re-save it
a5f1 a5f1 d 7b
a5f1 a5f1 s         LD      A,E             ; Get LSB
a5f2 a5f2 d 1f
a5f2 a5f2 s         RRA                     ; Shift right with last bit
a5f3 a5f3 d 5f
a5f3 a5f3 s         LD      E,A             ; Re-save it
a5f4 a5f4 d 78
a5f4 a5f4 s         LD      A,B             ; Get underflow
a5f5 a5f5 d 1f
a5f5 a5f5 s         RRA                     ; Shift right with last bit
a5f6 a5f6 d 47
a5f6 a5f6 s         LD      B,A             ; Re-save underflow
a5f7 a5f7 d c3e8a5
a5f7 a5f7 s         JP      SHRLP           ; More bits to do
a5fa a5fa s 
a5fa a5fa d 00000081
a5fa a5fa s UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
a5fe a5fe s 
a5fe a5fe d 03
a5fe a5fe s LOGTAB: .BYTE      3                       ; Table used by LOG
a5ff a5ff d aa561980
a5ff a5ff s         .BYTE      0AAH,056H,019H,080H     ; 0.59898
a603 a603 d f1227680
a603 a603 s         .BYTE      0F1H,022H,076H,080H     ; 0.96147
a607 a607 d 45aa3882
a607 a607 s         .BYTE      045H,0AAH,038H,082H     ; 2.88539
a60b a60b s 
a60b a60b d cd57a7
a60b a60b s LOG:    CALL    TSTSGN          ; Test sign of value
a60e a60e d b7
a60e a60e s         OR      A
a60f a60f d eacf99
a60f a60f s         JP      PE,FCERR        ; ?FC Error if <= zero
a612 a612 d 212cb1
a612 a612 s         LD      HL,FPEXP        ; Point to exponent
a615 a615 d 7e
a615 a615 s         LD      A,(HL)          ; Get exponent
a616 a616 d 013580
a616 a616 s         LD      BC,8035H        ; BCDE = SQR(1/2)
a619 a619 d 11f304
a619 a619 s         LD      DE,04F3H
a61c a61c d 90
a61c a61c s         SUB     B               ; Scale value to be < 1
a61d a61d d f5
a61d a61d s         PUSH    AF              ; Save scale factor
a61e a61e d 70
a61e a61e s         LD      (HL),B          ; Save new exponent
a61f a61f d d5
a61f a61f s         PUSH    DE              ; Save SQR(1/2)
a620 a620 d c5
a620 a620 s         PUSH    BC
a621 a621 d cd11a5
a621 a621 s         CALL    FPADD           ; Add SQR(1/2) to value
a624 a624 d c1
a624 a624 s         POP     BC              ; Restore SQR(1/2)
a625 a625 d d1
a625 a625 s         POP     DE
a626 a626 d 04
a626 a626 s         INC     B               ; Make it SQR(2)
a627 a627 d cdada6
a627 a627 s         CALL    DVBCDE          ; Divide by SQR(2)
a62a a62a d 21faa5
a62a a62a s         LD      HL,UNITY        ; Point to 1.
a62d a62d d cd08a5
a62d a62d s         CALL    SUBPHL          ; Subtract FPREG from 1
a630 a630 d 21fea5
a630 a630 s         LD      HL,LOGTAB       ; Coefficient table
a633 a633 d cd9faa
a633 a633 s         CALL    SUMSER          ; Evaluate sum of series
a636 a636 d 018080
a636 a636 s         LD      BC,8080H        ; BCDE = -0.5
a639 a639 d 110000
a639 a639 s         LD      DE,0000H
a63c a63c d cd11a5
a63c a63c s         CALL    FPADD           ; Subtract 0.5 from FPREG
a63f a63f d f1
a63f a63f s         POP     AF              ; Restore scale factor
a640 a640 d cdd2a8
a640 a640 s         CALL    RSCALE          ; Re-scale number
a643 a643 d 013180
a643 a643 s MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
a646 a646 d 111872
a646 a646 s         LD      DE,7218H
a649 a649 d 21
a649 a649 s         .BYTE      21H             ; Skip "POP BC" and "POP DE"
a64a a64a s 
a64a a64a d c1
a64a a64a s MULT:   POP     BC              ; Get number from stack
a64b a64b d d1
a64b a64b s         POP     DE
a64c a64c d cd57a7
a64c a64c s FPMULT: CALL    TSTSGN          ; Test sign of FPREG
a64f a64f d c8
a64f a64f s         RET     Z               ; Return zero if zero
a650 a650 d 2e00
a650 a650 s         LD      L,0             ; Flag add exponents
a652 a652 d cd15a7
a652 a652 s         CALL    ADDEXP          ; Add exponents
a655 a655 d 79
a655 a655 s         LD      A,C             ; Get MSB of multiplier
a656 a656 d 323bb1
a656 a656 s         LD      (MULVAL),A      ; Save MSB of multiplier
a659 a659 d eb
a659 a659 s         EX      DE,HL
a65a a65a d 223cb1
a65a a65a s         LD      (MULVAL+1),HL   ; Save rest of multiplier
a65d a65d d 010000
a65d a65d s         LD      BC,0            ; Partial product (BCDE) = zero
a660 a660 d 50
a660 a660 s         LD      D,B
a661 a661 d 58
a661 a661 s         LD      E,B
a662 a662 d 2162a5
a662 a662 s         LD      HL,BNORM        ; Address of normalise
a665 a665 d e5
a665 a665 s         PUSH    HL              ; Save for return
a666 a666 d 216ea6
a666 a666 s         LD      HL,MULT8        ; Address of 8 bit multiply
a669 a669 d e5
a669 a669 s         PUSH    HL              ; Save for NMSB,MSB
a66a a66a d e5
a66a a66a s         PUSH    HL              ; 
a66b a66b d 2129b1
a66b a66b s         LD      HL,FPREG        ; Point to number
a66e a66e d 7e
a66e a66e s MULT8:  LD      A,(HL)          ; Get LSB of number
a66f a66f d 23
a66f a66f s         INC     HL              ; Point to NMSB
a670 a670 d b7
a670 a670 s         OR      A               ; Test LSB
a671 a671 d ca9aa6
a671 a671 s         JP      Z,BYTSFT        ; Zero - shift to next byte
a674 a674 d e5
a674 a674 s         PUSH    HL              ; Save address of number
a675 a675 d 2e08
a675 a675 s         LD      L,8             ; 8 bits to multiply by
a677 a677 d 1f
a677 a677 s MUL8LP: RRA                     ; Shift LSB right
a678 a678 d 67
a678 a678 s         LD      H,A             ; Save LSB
a679 a679 d 79
a679 a679 s         LD      A,C             ; Get MSB
a67a a67a d d288a6
a67a a67a s         JP      NC,NOMADD       ; Bit was zero - Don't add
a67d a67d d e5
a67d a67d s         PUSH    HL              ; Save LSB and count
a67e a67e d 2a3cb1
a67e a67e s         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
a681 a681 d 19
a681 a681 s         ADD     HL,DE           ; Add NMSB and LSB
a682 a682 d eb
a682 a682 s         EX      DE,HL           ; Leave sum in DE
a683 a683 d e1
a683 a683 s         POP     HL              ; Restore MSB and count
a684 a684 d 3a3bb1
a684 a684 s         LD      A,(MULVAL)      ; Get MSB of multiplier
a687 a687 d 89
a687 a687 s         ADC     A,C             ; Add MSB
a688 a688 d 1f
a688 a688 s NOMADD: RRA                     ; Shift MSB right
a689 a689 d 4f
a689 a689 s         LD      C,A             ; Re-save MSB
a68a a68a d 7a
a68a a68a s         LD      A,D             ; Get NMSB
a68b a68b d 1f
a68b a68b s         RRA                     ; Shift NMSB right
a68c a68c d 57
a68c a68c s         LD      D,A             ; Re-save NMSB
a68d a68d d 7b
a68d a68d s         LD      A,E             ; Get LSB
a68e a68e d 1f
a68e a68e s         RRA                     ; Shift LSB right
a68f a68f d 5f
a68f a68f s         LD      E,A             ; Re-save LSB
a690 a690 d 78
a690 a690 s         LD      A,B             ; Get VLSB
a691 a691 d 1f
a691 a691 s         RRA                     ; Shift VLSB right
a692 a692 d 47
a692 a692 s         LD      B,A             ; Re-save VLSB
a693 a693 d 2d
a693 a693 s         DEC     L               ; Count bits multiplied
a694 a694 d 7c
a694 a694 s         LD      A,H             ; Get LSB of multiplier
a695 a695 d c277a6
a695 a695 s         JP      NZ,MUL8LP       ; More - Do it
a698 a698 d e1
a698 a698 s POPHRT: POP     HL              ; Restore address of number
a699 a699 d c9
a699 a699 s         RET
a69a a69a s 
a69a a69a d 43
a69a a69a s BYTSFT: LD      B,E             ; Shift partial product left
a69b a69b d 5a
a69b a69b s         LD      E,D
a69c a69c d 51
a69c a69c s         LD      D,C
a69d a69d d 4f
a69d a69d s         LD      C,A
a69e a69e d c9
a69e a69e s         RET
a69f a69f s 
a69f a69f d cd88a7
a69f a69f s DIV10:  CALL    STAKFP          ; Save FPREG on stack
a6a2 a6a2 d 012084
a6a2 a6a2 s         LD      BC,8420H        ; BCDE = 10.
a6a5 a6a5 d 110000
a6a5 a6a5 s         LD      DE,0000H
a6a8 a6a8 d cd98a7
a6a8 a6a8 s         CALL    FPBCDE          ; Move 10 to FPREG
a6ab a6ab s 
a6ab a6ab d c1
a6ab a6ab s DIV:    POP     BC              ; Get number from stack
a6ac a6ac d d1
a6ac a6ac s         POP     DE
a6ad a6ad d cd57a7
a6ad a6ad s DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
a6b0 a6b0 d cab094
a6b0 a6b0 s         JP      Z,DZERR         ; Error if division by zero
a6b3 a6b3 d 2eff
a6b3 a6b3 s         LD      L,-1            ; Flag subtract exponents
a6b5 a6b5 d cd15a7
a6b5 a6b5 s         CALL    ADDEXP          ; Subtract exponents
a6b8 a6b8 d 34
a6b8 a6b8 s         INC     (HL)            ; Add 2 to exponent to adjust
a6b9 a6b9 d 34
a6b9 a6b9 s         INC     (HL)
a6ba a6ba d 2b
a6ba a6ba s         DEC     HL              ; Point to MSB
a6bb a6bb d 7e
a6bb a6bb s         LD      A,(HL)          ; Get MSB of dividend
a6bc a6bc d 3257b0
a6bc a6bc s         LD      (DIV3),A        ; Save for subtraction
a6bf a6bf d 2b
a6bf a6bf s         DEC     HL
a6c0 a6c0 d 7e
a6c0 a6c0 s         LD      A,(HL)          ; Get NMSB of dividend
a6c1 a6c1 d 3253b0
a6c1 a6c1 s         LD      (DIV2),A        ; Save for subtraction
a6c4 a6c4 d 2b
a6c4 a6c4 s         DEC     HL
a6c5 a6c5 d 7e
a6c5 a6c5 s         LD      A,(HL)          ; Get MSB of dividend
a6c6 a6c6 d 324fb0
a6c6 a6c6 s         LD      (DIV1),A        ; Save for subtraction
a6c9 a6c9 d 41
a6c9 a6c9 s         LD      B,C             ; Get MSB
a6ca a6ca d eb
a6ca a6ca s         EX      DE,HL           ; NMSB,LSB to HL
a6cb a6cb d af
a6cb a6cb s         XOR     A
a6cc a6cc d 4f
a6cc a6cc s         LD      C,A             ; Clear MSB of quotient
a6cd a6cd d 57
a6cd a6cd s         LD      D,A             ; Clear NMSB of quotient
a6ce a6ce d 5f
a6ce a6ce s         LD      E,A             ; Clear LSB of quotient
a6cf a6cf d 325ab0
a6cf a6cf s         LD      (DIV4),A        ; Clear overflow count
a6d2 a6d2 d e5
a6d2 a6d2 s DIVLP:  PUSH    HL              ; Save divisor
a6d3 a6d3 d c5
a6d3 a6d3 s         PUSH    BC
a6d4 a6d4 d 7d
a6d4 a6d4 s         LD      A,L             ; Get LSB of number
a6d5 a6d5 d cd4eb0
a6d5 a6d5 s         CALL    DIVSUP          ; Subt' divisor from dividend
a6d8 a6d8 d de00
a6d8 a6d8 s         SBC     A,0             ; Count for overflows
a6da a6da d 3f
a6da a6da s         CCF
a6db a6db d d2e5a6
a6db a6db s         JP      NC,RESDIV       ; Restore divisor if borrow
a6de a6de d 325ab0
a6de a6de s         LD      (DIV4),A        ; Re-save overflow count
a6e1 a6e1 d f1
a6e1 a6e1 s         POP     AF              ; Scrap divisor
a6e2 a6e2 d f1
a6e2 a6e2 s         POP     AF
a6e3 a6e3 d 37
a6e3 a6e3 s         SCF                     ; Set carry to
a6e4 a6e4 d d2
a6e4 a6e4 s         .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
a6e5 a6e5 s 
a6e5 a6e5 d c1
a6e5 a6e5 s RESDIV: POP     BC              ; Restore divisor
a6e6 a6e6 d e1
a6e6 a6e6 s         POP     HL
a6e7 a6e7 d 79
a6e7 a6e7 s         LD      A,C             ; Get MSB of quotient
a6e8 a6e8 d 3c
a6e8 a6e8 s         INC     A
a6e9 a6e9 d 3d
a6e9 a6e9 s         DEC     A
a6ea a6ea d 1f
a6ea a6ea s         RRA                     ; Bit 0 to bit 7
a6eb a6eb d fa98a5
a6eb a6eb s         JP      M,RONDB         ; Done - Normalise result
a6ee a6ee d 17
a6ee a6ee s         RLA                     ; Restore carry
a6ef a6ef d 7b
a6ef a6ef s         LD      A,E             ; Get LSB of quotient
a6f0 a6f0 d 17
a6f0 a6f0 s         RLA                     ; Double it
a6f1 a6f1 d 5f
a6f1 a6f1 s         LD      E,A             ; Put it back
a6f2 a6f2 d 7a
a6f2 a6f2 s         LD      A,D             ; Get NMSB of quotient
a6f3 a6f3 d 17
a6f3 a6f3 s         RLA                     ; Double it
a6f4 a6f4 d 57
a6f4 a6f4 s         LD      D,A             ; Put it back
a6f5 a6f5 d 79
a6f5 a6f5 s         LD      A,C             ; Get MSB of quotient
a6f6 a6f6 d 17
a6f6 a6f6 s         RLA                     ; Double it
a6f7 a6f7 d 4f
a6f7 a6f7 s         LD      C,A             ; Put it back
a6f8 a6f8 d 29
a6f8 a6f8 s         ADD     HL,HL           ; Double NMSB,LSB of divisor
a6f9 a6f9 d 78
a6f9 a6f9 s         LD      A,B             ; Get MSB of divisor
a6fa a6fa d 17
a6fa a6fa s         RLA                     ; Double it
a6fb a6fb d 47
a6fb a6fb s         LD      B,A             ; Put it back
a6fc a6fc d 3a5ab0
a6fc a6fc s         LD      A,(DIV4)        ; Get VLSB of quotient
a6ff a6ff d 17
a6ff a6ff s         RLA                     ; Double it
a700 a700 d 325ab0
a700 a700 s         LD      (DIV4),A        ; Put it back
a703 a703 d 79
a703 a703 s         LD      A,C             ; Get MSB of quotient
a704 a704 d b2
a704 a704 s         OR      D               ; Merge NMSB
a705 a705 d b3
a705 a705 s         OR      E               ; Merge LSB
a706 a706 d c2d2a6
a706 a706 s         JP      NZ,DIVLP        ; Not done - Keep dividing
a709 a709 d e5
a709 a709 s         PUSH    HL              ; Save divisor
a70a a70a d 212cb1
a70a a70a s         LD      HL,FPEXP        ; Point to exponent
a70d a70d d 35
a70d a70d s         DEC     (HL)            ; Divide by 2
a70e a70e d e1
a70e a70e s         POP     HL              ; Restore divisor
a70f a70f d c2d2a6
a70f a70f s         JP      NZ,DIVLP        ; Ok - Keep going
a712 a712 d c3bc94
a712 a712 s         JP      OVERR           ; Overflow error
a715 a715 s 
a715 a715 d 78
a715 a715 s ADDEXP: LD      A,B             ; Get exponent of dividend
a716 a716 d b7
a716 a716 s         OR      A               ; Test it
a717 a717 d ca39a7
a717 a717 s         JP      Z,OVTST3        ; Zero - Result zero
a71a a71a d 7d
a71a a71a s         LD      A,L             ; Get add/subtract flag
a71b a71b d 212cb1
a71b a71b s         LD      HL,FPEXP        ; Point to exponent
a71e a71e d ae
a71e a71e s         XOR     (HL)            ; Add or subtract it
a71f a71f d 80
a71f a71f s         ADD     A,B             ; Add the other exponent
a720 a720 d 47
a720 a720 s         LD      B,A             ; Save new exponent
a721 a721 d 1f
a721 a721 s         RRA                     ; Test exponent for overflow
a722 a722 d a8
a722 a722 s         XOR     B
a723 a723 d 78
a723 a723 s         LD      A,B             ; Get exponent
a724 a724 d f238a7
a724 a724 s         JP      P,OVTST2        ; Positive - Test for overflow
a727 a727 d c680
a727 a727 s         ADD     A,80H           ; Add excess 128
a729 a729 d 77
a729 a729 s         LD      (HL),A          ; Save new exponent
a72a a72a d ca98a6
a72a a72a s         JP      Z,POPHRT        ; Zero - Result zero
a72d a72d d cdbda7
a72d a72d s         CALL    SIGNS           ; Set MSBs and sign of result
a730 a730 d 77
a730 a730 s         LD      (HL),A          ; Save new exponent
a731 a731 d 2b
a731 a731 s         DEC     HL              ; Point to MSB
a732 a732 d c9
a732 a732 s         RET
a733 a733 s 
a733 a733 d cd57a7
a733 a733 s OVTST1: CALL    TSTSGN          ; Test sign of FPREG
a736 a736 d 2f
a736 a736 s         CPL                     ; Invert sign
a737 a737 d e1
a737 a737 s         POP     HL              ; Clean up stack
a738 a738 d b7
a738 a738 s OVTST2: OR      A               ; Test if new exponent zero
a739 a739 d e1
a739 a739 s OVTST3: POP     HL              ; Clear off return address
a73a a73a d f277a5
a73a a73a s         JP      P,RESZER        ; Result zero
a73d a73d d c3bc94
a73d a73d s         JP      OVERR           ; Overflow error
a740 a740 s 
a740 a740 d cda3a7
a740 a740 s MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
a743 a743 d 78
a743 a743 s         LD      A,B             ; Get exponent
a744 a744 d b7
a744 a744 s         OR      A               ; Is it zero?
a745 a745 d c8
a745 a745 s         RET     Z               ; Yes - Result is zero
a746 a746 d c602
a746 a746 s         ADD     A,2             ; Multiply by 4
a748 a748 d dabc94
a748 a748 s         JP      C,OVERR         ; Overflow - ?OV Error
a74b a74b d 47
a74b a74b s         LD      B,A             ; Re-save exponent
a74c a74c d cd11a5
a74c a74c s         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
a74f a74f d 212cb1
a74f a74f s         LD      HL,FPEXP        ; Point to exponent
a752 a752 d 34
a752 a752 s         INC     (HL)            ; Double number (Times 10)
a753 a753 d c0
a753 a753 s         RET     NZ              ; Ok - Return
a754 a754 d c3bc94
a754 a754 s         JP      OVERR           ; Overflow error
a757 a757 s 
a757 a757 d 3a2cb1
a757 a757 s TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
a75a a75a d b7
a75a a75a s         OR      A
a75b a75b d c8
a75b a75b s         RET     Z               ; RETurn if number is zero
a75c a75c d 3a2bb1
a75c a75c s         LD      A,(FPREG+2)     ; Get MSB of FPREG
a75f a75f d fe
a75f a75f s         .BYTE      0FEH            ; Test sign
a760 a760 d 2f
a760 a760 s RETREL: CPL                     ; Invert sign
a761 a761 d 17
a761 a761 s         RLA                     ; Sign bit to carry
a762 a762 d 9f
a762 a762 s FLGDIF: SBC     A,A             ; Carry to all bits of A
a763 a763 d c0
a763 a763 s         RET     NZ              ; Return -1 if negative
a764 a764 d 3c
a764 a764 s         INC     A               ; Bump to +1
a765 a765 d c9
a765 a765 s         RET                     ; Positive - Return +1
a766 a766 s 
a766 a766 d cd57a7
a766 a766 s SGN:    CALL    TSTSGN          ; Test sign of FPREG
a769 a769 d 0688
a769 a769 s FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
a76b a76b d 110000
a76b a76b s         LD      DE,0            ; Zero NMSB and LSB
a76e a76e d 212cb1
a76e a76e s RETINT: LD      HL,FPEXP        ; Point to exponent
a771 a771 d 4f
a771 a771 s         LD      C,A             ; CDE = MSB,NMSB and LSB
a772 a772 d 70
a772 a772 s         LD      (HL),B          ; Save exponent
a773 a773 d 0600
a773 a773 s         LD      B,0             ; CDE = integer to normalise
a775 a775 d 23
a775 a775 s         INC     HL              ; Point to sign of result
a776 a776 d 3680
a776 a776 s         LD      (HL),80H        ; Set sign of result
a778 a778 d 17
a778 a778 s         RLA                     ; Carry = sign of integer
a779 a779 d c35fa5
a779 a779 s         JP      CONPOS          ; Set sign of result
a77c a77c s 
a77c a77c d cd57a7
a77c a77c s ABS:    CALL    TSTSGN          ; Test sign of FPREG
a77f a77f d f0
a77f a77f s         RET     P               ; Return if positive
a780 a780 d 212bb1
a780 a780 s INVSGN: LD      HL,FPREG+2      ; Point to MSB
a783 a783 d 7e
a783 a783 s         LD      A,(HL)          ; Get sign of mantissa
a784 a784 d ee80
a784 a784 s         XOR     80H             ; Invert sign of mantissa
a786 a786 d 77
a786 a786 s         LD      (HL),A          ; Re-save sign of mantissa
a787 a787 d c9
a787 a787 s         RET
a788 a788 s 
a788 a788 d eb
a788 a788 s STAKFP: EX      DE,HL           ; Save code string address
a789 a789 d 2a29b1
a789 a789 s         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
a78c a78c d e3
a78c a78c s         EX      (SP),HL         ; Stack them,get return
a78d a78d d e5
a78d a78d s         PUSH    HL              ; Re-save return
a78e a78e d 2a2bb1
a78e a78e s         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
a791 a791 d e3
a791 a791 s         EX      (SP),HL         ; Stack them,get return
a792 a792 d e5
a792 a792 s         PUSH    HL              ; Re-save return
a793 a793 d eb
a793 a793 s         EX      DE,HL           ; Restore code string address
a794 a794 d c9
a794 a794 s         RET
a795 a795 s 
a795 a795 d cda6a7
a795 a795 s PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
a798 a798 d eb
a798 a798 s FPBCDE: EX      DE,HL           ; Save code string address
a799 a799 d 2229b1
a799 a799 s         LD      (FPREG),HL      ; Save LSB,NLSB of number
a79c a79c d 60
a79c a79c s         LD      H,B             ; Exponent of number
a79d a79d d 69
a79d a79d s         LD      L,C             ; MSB of number
a79e a79e d 222bb1
a79e a79e s         LD      (FPREG+2),HL    ; Save MSB and exponent
a7a1 a7a1 d eb
a7a1 a7a1 s         EX      DE,HL           ; Restore code string address
a7a2 a7a2 d c9
a7a2 a7a2 s         RET
a7a3 a7a3 s 
a7a3 a7a3 d 2129b1
a7a3 a7a3 s BCDEFP: LD      HL,FPREG        ; Point to FPREG
a7a6 a7a6 d 5e
a7a6 a7a6 s LOADFP: LD      E,(HL)          ; Get LSB of number
a7a7 a7a7 d 23
a7a7 a7a7 s         INC     HL
a7a8 a7a8 d 56
a7a8 a7a8 s         LD      D,(HL)          ; Get NMSB of number
a7a9 a7a9 d 23
a7a9 a7a9 s         INC     HL
a7aa a7aa d 4e
a7aa a7aa s         LD      C,(HL)          ; Get MSB of number
a7ab a7ab d 23
a7ab a7ab s         INC     HL
a7ac a7ac d 46
a7ac a7ac s         LD      B,(HL)          ; Get exponent of number
a7ad a7ad d 23
a7ad a7ad s INCHL:  INC     HL              ; Used for conditional "INC HL"
a7ae a7ae d c9
a7ae a7ae s         RET
a7af a7af s 
a7af a7af d 1129b1
a7af a7af s FPTHL:  LD      DE,FPREG        ; Point to FPREG
a7b2 a7b2 d 0604
a7b2 a7b2 s DETHL4: LD      B,4             ; 4 bytes to move
a7b4 a7b4 d 1a
a7b4 a7b4 s DETHLB: LD      A,(DE)          ; Get source
a7b5 a7b5 d 77
a7b5 a7b5 s         LD      (HL),A          ; Save destination
a7b6 a7b6 d 13
a7b6 a7b6 s         INC     DE              ; Next source
a7b7 a7b7 d 23
a7b7 a7b7 s         INC     HL              ; Next destination
a7b8 a7b8 d 05
a7b8 a7b8 s         DEC     B               ; Count bytes
a7b9 a7b9 d c2b4a7
a7b9 a7b9 s         JP      NZ,DETHLB       ; Loop if more
a7bc a7bc d c9
a7bc a7bc s         RET
a7bd a7bd s 
a7bd a7bd d 212bb1
a7bd a7bd s SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
a7c0 a7c0 d 7e
a7c0 a7c0 s         LD      A,(HL)          ; Get MSB
a7c1 a7c1 d 07
a7c1 a7c1 s         RLCA                    ; Old sign to carry
a7c2 a7c2 d 37
a7c2 a7c2 s         SCF                     ; Set MSBit
a7c3 a7c3 d 1f
a7c3 a7c3 s         RRA                     ; Set MSBit of MSB
a7c4 a7c4 d 77
a7c4 a7c4 s         LD      (HL),A          ; Save new MSB
a7c5 a7c5 d 3f
a7c5 a7c5 s         CCF                     ; Complement sign
a7c6 a7c6 d 1f
a7c6 a7c6 s         RRA                     ; Old sign to carry
a7c7 a7c7 d 23
a7c7 a7c7 s         INC     HL
a7c8 a7c8 d 23
a7c8 a7c8 s         INC     HL
a7c9 a7c9 d 77
a7c9 a7c9 s         LD      (HL),A          ; Set sign of result
a7ca a7ca d 79
a7ca a7ca s         LD      A,C             ; Get MSB
a7cb a7cb d 07
a7cb a7cb s         RLCA                    ; Old sign to carry
a7cc a7cc d 37
a7cc a7cc s         SCF                     ; Set MSBit
a7cd a7cd d 1f
a7cd a7cd s         RRA                     ; Set MSBit of MSB
a7ce a7ce d 4f
a7ce a7ce s         LD      C,A             ; Save MSB
a7cf a7cf d 1f
a7cf a7cf s         RRA
a7d0 a7d0 d ae
a7d0 a7d0 s         XOR     (HL)            ; New sign of result
a7d1 a7d1 d c9
a7d1 a7d1 s         RET
a7d2 a7d2 s 
a7d2 a7d2 d 78
a7d2 a7d2 s CMPNUM: LD      A,B             ; Get exponent of number
a7d3 a7d3 d b7
a7d3 a7d3 s         OR      A
a7d4 a7d4 d ca57a7
a7d4 a7d4 s         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
a7d7 a7d7 d 2160a7
a7d7 a7d7 s         LD      HL,RETREL       ; Return relation routine
a7da a7da d e5
a7da a7da s         PUSH    HL              ; Save for return
a7db a7db d cd57a7
a7db a7db s         CALL    TSTSGN          ; Test sign of FPREG
a7de a7de d 79
a7de a7de s         LD      A,C             ; Get MSB of number
a7df a7df d c8
a7df a7df s         RET     Z               ; FPREG zero - Number's MSB
a7e0 a7e0 d 212bb1
a7e0 a7e0 s         LD      HL,FPREG+2      ; MSB of FPREG
a7e3 a7e3 d ae
a7e3 a7e3 s         XOR     (HL)            ; Combine signs
a7e4 a7e4 d 79
a7e4 a7e4 s         LD      A,C             ; Get MSB of number
a7e5 a7e5 d f8
a7e5 a7e5 s         RET     M               ; Exit if signs different
a7e6 a7e6 d cdeca7
a7e6 a7e6 s         CALL    CMPFP           ; Compare FP numbers
a7e9 a7e9 d 1f
a7e9 a7e9 s         RRA                     ; Get carry to sign
a7ea a7ea d a9
a7ea a7ea s         XOR     C               ; Combine with MSB of number
a7eb a7eb d c9
a7eb a7eb s         RET
a7ec a7ec s 
a7ec a7ec d 23
a7ec a7ec s CMPFP:  INC     HL              ; Point to exponent
a7ed a7ed d 78
a7ed a7ed s         LD      A,B             ; Get exponent
a7ee a7ee d be
a7ee a7ee s         CP      (HL)            ; Compare exponents
a7ef a7ef d c0
a7ef a7ef s         RET     NZ              ; Different
a7f0 a7f0 d 2b
a7f0 a7f0 s         DEC     HL              ; Point to MBS
a7f1 a7f1 d 79
a7f1 a7f1 s         LD      A,C             ; Get MSB
a7f2 a7f2 d be
a7f2 a7f2 s         CP      (HL)            ; Compare MSBs
a7f3 a7f3 d c0
a7f3 a7f3 s         RET     NZ              ; Different
a7f4 a7f4 d 2b
a7f4 a7f4 s         DEC     HL              ; Point to NMSB
a7f5 a7f5 d 7a
a7f5 a7f5 s         LD      A,D             ; Get NMSB
a7f6 a7f6 d be
a7f6 a7f6 s         CP      (HL)            ; Compare NMSBs
a7f7 a7f7 d c0
a7f7 a7f7 s         RET     NZ              ; Different
a7f8 a7f8 d 2b
a7f8 a7f8 s         DEC     HL              ; Point to LSB
a7f9 a7f9 d 7b
a7f9 a7f9 s         LD      A,E             ; Get LSB
a7fa a7fa d 96
a7fa a7fa s         SUB     (HL)            ; Compare LSBs
a7fb a7fb d c0
a7fb a7fb s         RET     NZ              ; Different
a7fc a7fc d e1
a7fc a7fc s         POP     HL              ; Drop RETurn
a7fd a7fd d e1
a7fd a7fd s         POP     HL              ; Drop another RETurn
a7fe a7fe d c9
a7fe a7fe s         RET
a7ff a7ff s 
a7ff a7ff d 47
a7ff a7ff s FPINT:  LD      B,A             ; <- Move
a800 a800 d 4f
a800 a800 s         LD      C,A             ; <- exponent
a801 a801 d 57
a801 a801 s         LD      D,A             ; <- to all
a802 a802 d 5f
a802 a802 s         LD      E,A             ; <- bits
a803 a803 d b7
a803 a803 s         OR      A               ; Test exponent
a804 a804 d c8
a804 a804 s         RET     Z               ; Zero - Return zero
a805 a805 d e5
a805 a805 s         PUSH    HL              ; Save pointer to number
a806 a806 d cda3a7
a806 a806 s         CALL    BCDEFP          ; Move FPREG to BCDE
a809 a809 d cdbda7
a809 a809 s         CALL    SIGNS           ; Set MSBs & sign of result
a80c a80c d ae
a80c a80c s         XOR     (HL)            ; Combine with sign of FPREG
a80d a80d d 67
a80d a80d s         LD      H,A             ; Save combined signs
a80e a80e d fc23a8
a80e a80e s         CALL    M,DCBCDE        ; Negative - Decrement BCDE
a811 a811 d 3e98
a811 a811 s         LD      A,80H+24        ; 24 bits
a813 a813 d 90
a813 a813 s         SUB     B               ; Bits to shift
a814 a814 d cdd6a5
a814 a814 s         CALL    SCALE           ; Shift BCDE
a817 a817 d 7c
a817 a817 s         LD      A,H             ; Get combined sign
a818 a818 d 17
a818 a818 s         RLA                     ; Sign to carry
a819 a819 d dca9a5
a819 a819 s         CALL    C,FPROND        ; Negative - Round number up
a81c a81c d 0600
a81c a81c s         LD      B,0             ; Zero exponent
a81e a81e d dcc2a5
a81e a81e s         CALL    C,COMPL         ; If negative make positive
a821 a821 d e1
a821 a821 s         POP     HL              ; Restore pointer to number
a822 a822 d c9
a822 a822 s         RET
a823 a823 s 
a823 a823 d 1b
a823 a823 s DCBCDE: DEC     DE              ; Decrement BCDE
a824 a824 d 7a
a824 a824 s         LD      A,D             ; Test LSBs
a825 a825 d a3
a825 a825 s         AND     E
a826 a826 d 3c
a826 a826 s         INC     A
a827 a827 d c0
a827 a827 s         RET     NZ              ; Exit if LSBs not FFFF
a828 a828 d 0b
a828 a828 s         DEC     BC              ; Decrement MSBs
a829 a829 d c9
a829 a829 s         RET
a82a a82a s 
a82a a82a d 212cb1
a82a a82a s INT:    LD      HL,FPEXP        ; Point to exponent
a82d a82d d 7e
a82d a82d s         LD      A,(HL)          ; Get exponent
a82e a82e d fe98
a82e a82e s         CP      80H+24          ; Integer accuracy only?
a830 a830 d 3a29b1
a830 a830 s         LD      A,(FPREG)       ; Get LSB
a833 a833 d d0
a833 a833 s         RET     NC              ; Yes - Already integer
a834 a834 d 7e
a834 a834 s         LD      A,(HL)          ; Get exponent
a835 a835 d cdffa7
a835 a835 s         CALL    FPINT           ; F.P to integer
a838 a838 d 3698
a838 a838 s         LD      (HL),80H+24     ; Save 24 bit integer
a83a a83a d 7b
a83a a83a s         LD      A,E             ; Get LSB of number
a83b a83b d f5
a83b a83b s         PUSH    AF              ; Save LSB
a83c a83c d 79
a83c a83c s         LD      A,C             ; Get MSB of number
a83d a83d d 17
a83d a83d s         RLA                     ; Sign to carry
a83e a83e d cd5fa5
a83e a83e s         CALL    CONPOS          ; Set sign of result
a841 a841 d f1
a841 a841 s         POP     AF              ; Restore LSB of number
a842 a842 d c9
a842 a842 s         RET
a843 a843 s 
a843 a843 d 210000
a843 a843 s MLDEBC: LD      HL,0            ; Clear partial product
a846 a846 d 78
a846 a846 s         LD      A,B             ; Test multiplier
a847 a847 d b1
a847 a847 s         OR      C
a848 a848 d c8
a848 a848 s         RET     Z               ; Return zero if zero
a849 a849 d 3e10
a849 a849 s         LD      A,16            ; 16 bits
a84b a84b d 29
a84b a84b s MLDBLP: ADD     HL,HL           ; Shift P.P left
a84c a84c d da83a0
a84c a84c s         JP      C,BSERR         ; ?BS Error if overflow
a84f a84f d eb
a84f a84f s         EX      DE,HL
a850 a850 d 29
a850 a850 s         ADD     HL,HL           ; Shift multiplier left
a851 a851 d eb
a851 a851 s         EX      DE,HL
a852 a852 d d259a8
a852 a852 s         JP      NC,NOMLAD       ; Bit was zero - No add
a855 a855 d 09
a855 a855 s         ADD     HL,BC           ; Add multiplicand
a856 a856 d da83a0
a856 a856 s         JP      C,BSERR         ; ?BS Error if overflow
a859 a859 d 3d
a859 a859 s NOMLAD: DEC     A               ; Count bits
a85a a85a d c24ba8
a85a a85a s         JP      NZ,MLDBLP       ; More
a85d a85d d c9
a85d a85d s         RET
a85e a85e s 
a85e a85e d fe2d
a85e a85e s ASCTFP: CP      '-'             ; Negative?
a860 a860 d f5
a860 a860 s         PUSH    AF              ; Save it and flags
a861 a861 d ca6aa8
a861 a861 s         JP      Z,CNVNUM        ; Yes - Convert number
a864 a864 d fe2b
a864 a864 s         CP      '+'             ; Positive?
a866 a866 d ca6aa8
a866 a866 s         JP      Z,CNVNUM        ; Yes - Convert number
a869 a869 d 2b
a869 a869 s         DEC     HL              ; DEC 'cos GETCHR INCs
a86a a86a d cd77a5
a86a a86a s CNVNUM: CALL    RESZER          ; Set result to zero
a86d a86d d 47
a86d a86d s         LD      B,A             ; Digits after point counter
a86e a86e d 57
a86e a86e s         LD      D,A             ; Sign of exponent
a86f a86f d 5f
a86f a86f s         LD      E,A             ; Exponent of ten
a870 a870 d 2f
a870 a870 s         CPL
a871 a871 d 4f
a871 a871 s         LD      C,A             ; Before or after point flag
a872 a872 d cd0599
a872 a872 s MANLP:  CALL    GETCHR          ; Get next character
a875 a875 d dabba8
a875 a875 s         JP      C,ADDIG         ; Digit - Add to number
a878 a878 d fe2e
a878 a878 s         CP      '.'
a87a a87a d ca96a8
a87a a87a s         JP      Z,DPOINT        ; '.' - Flag point
a87d a87d d fe45
a87d a87d s         CP      'E'
a87f a87f d c29aa8
a87f a87f s         JP      NZ,CONEXP       ; Not 'E' - Scale number
a882 a882 d cd0599
a882 a882 s         CALL    GETCHR          ; Get next character
a885 a885 d cdae9e
a885 a885 s         CALL    SGNEXP          ; Get sign of exponent
a888 a888 d cd0599
a888 a888 s EXPLP:  CALL    GETCHR          ; Get next character
a88b a88b d dadda8
a88b a88b s         JP      C,EDIGIT        ; Digit - Add to exponent
a88e a88e d 14
a88e a88e s         INC     D               ; Is sign negative?
a88f a88f d c29aa8
a88f a88f s         JP      NZ,CONEXP       ; No - Scale number
a892 a892 d af
a892 a892 s         XOR     A
a893 a893 d 93
a893 a893 s         SUB     E               ; Negate exponent
a894 a894 d 5f
a894 a894 s         LD      E,A             ; And re-save it
a895 a895 d 0c
a895 a895 s         INC     C               ; Flag end of number
a896 a896 d 0c
a896 a896 s DPOINT: INC     C               ; Flag point passed
a897 a897 d ca72a8
a897 a897 s         JP      Z,MANLP         ; Zero - Get another digit
a89a a89a d e5
a89a a89a s CONEXP: PUSH    HL              ; Save code string address
a89b a89b d 7b
a89b a89b s         LD      A,E             ; Get exponent
a89c a89c d 90
a89c a89c s         SUB     B               ; Subtract digits after point
a89d a89d d f4b3a8
a89d a89d s SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
a8a0 a8a0 d f2a9a8
a8a0 a8a0 s         JP      P,ENDCON        ; Positive - All done
a8a3 a8a3 d f5
a8a3 a8a3 s         PUSH    AF              ; Save number of times to /10
a8a4 a8a4 d cd9fa6
a8a4 a8a4 s         CALL    DIV10           ; Divide by 10
a8a7 a8a7 d f1
a8a7 a8a7 s         POP     AF              ; Restore count
a8a8 a8a8 d 3c
a8a8 a8a8 s         INC     A               ; Count divides
a8a9 a8a9 s 
a8a9 a8a9 d c29da8
a8a9 a8a9 s ENDCON: JP      NZ,SCALMI       ; More to do
a8ac a8ac d d1
a8ac a8ac s         POP     DE              ; Restore code string address
a8ad a8ad d f1
a8ad a8ad s         POP     AF              ; Restore sign of number
a8ae a8ae d cc80a7
a8ae a8ae s         CALL    Z,INVSGN        ; Negative - Negate number
a8b1 a8b1 d eb
a8b1 a8b1 s         EX      DE,HL           ; Code string address to HL
a8b2 a8b2 d c9
a8b2 a8b2 s         RET
a8b3 a8b3 s 
a8b3 a8b3 d c8
a8b3 a8b3 s SCALPL: RET     Z               ; Exit if no scaling needed
a8b4 a8b4 d f5
a8b4 a8b4 s MULTEN: PUSH    AF              ; Save count
a8b5 a8b5 d cd40a7
a8b5 a8b5 s         CALL    MLSP10          ; Multiply number by 10
a8b8 a8b8 d f1
a8b8 a8b8 s         POP     AF              ; Restore count
a8b9 a8b9 d 3d
a8b9 a8b9 s         DEC     A               ; Count multiplies
a8ba a8ba d c9
a8ba a8ba s         RET
a8bb a8bb s 
a8bb a8bb d d5
a8bb a8bb s ADDIG:  PUSH    DE              ; Save sign of exponent
a8bc a8bc d 57
a8bc a8bc s         LD      D,A             ; Save digit
a8bd a8bd d 78
a8bd a8bd s         LD      A,B             ; Get digits after point
a8be a8be d 89
a8be a8be s         ADC     A,C             ; Add one if after point
a8bf a8bf d 47
a8bf a8bf s         LD      B,A             ; Re-save counter
a8c0 a8c0 d c5
a8c0 a8c0 s         PUSH    BC              ; Save point flags
a8c1 a8c1 d e5
a8c1 a8c1 s         PUSH    HL              ; Save code string address
a8c2 a8c2 d d5
a8c2 a8c2 s         PUSH    DE              ; Save digit
a8c3 a8c3 d cd40a7
a8c3 a8c3 s         CALL    MLSP10          ; Multiply number by 10
a8c6 a8c6 d f1
a8c6 a8c6 s         POP     AF              ; Restore digit
a8c7 a8c7 d d630
a8c7 a8c7 s         SUB     '0'             ; Make it absolute
a8c9 a8c9 d cdd2a8
a8c9 a8c9 s         CALL    RSCALE          ; Re-scale number
a8cc a8cc d e1
a8cc a8cc s         POP     HL              ; Restore code string address
a8cd a8cd d c1
a8cd a8cd s         POP     BC              ; Restore point flags
a8ce a8ce d d1
a8ce a8ce s         POP     DE              ; Restore sign of exponent
a8cf a8cf d c372a8
a8cf a8cf s         JP      MANLP           ; Get another digit
a8d2 a8d2 s 
a8d2 a8d2 d cd88a7
a8d2 a8d2 s RSCALE: CALL    STAKFP          ; Put number on stack
a8d5 a8d5 d cd69a7
a8d5 a8d5 s         CALL    FLGREL          ; Digit to add to FPREG
a8d8 a8d8 d c1
a8d8 a8d8 s PADD:   POP     BC              ; Restore number
a8d9 a8d9 d d1
a8d9 a8d9 s         POP     DE
a8da a8da d c311a5
a8da a8da s         JP      FPADD           ; Add BCDE to FPREG and return
a8dd a8dd s 
a8dd a8dd d 7b
a8dd a8dd s EDIGIT: LD      A,E             ; Get digit
a8de a8de d 07
a8de a8de s         RLCA                    ; Times 2
a8df a8df d 07
a8df a8df s         RLCA                    ; Times 4
a8e0 a8e0 d 83
a8e0 a8e0 s         ADD     A,E             ; Times 5
a8e1 a8e1 d 07
a8e1 a8e1 s         RLCA                    ; Times 10
a8e2 a8e2 d 86
a8e2 a8e2 s         ADD     A,(HL)          ; Add next digit
a8e3 a8e3 d d630
a8e3 a8e3 s         SUB     '0'             ; Make it absolute
a8e5 a8e5 d 5f
a8e5 a8e5 s         LD      E,A             ; Save new digit
a8e6 a8e6 d c388a8
a8e6 a8e6 s         JP      EXPLP           ; Look for another digit
a8e9 a8e9 s 
a8e9 a8e9 d e5
a8e9 a8e9 s LINEIN: PUSH    HL              ; Save code string address
a8ea a8ea d 214594
a8ea a8ea s         LD      HL,INMSG        ; Output " in "
a8ed a8ed d cd4ea2
a8ed a8ed s         CALL    PRS             ; Output string at HL
a8f0 a8f0 d e1
a8f0 a8f0 s         POP     HL              ; Restore code string address
a8f1 a8f1 d eb
a8f1 a8f1 s PRNTHL: EX      DE,HL           ; Code string address to DE
a8f2 a8f2 d af
a8f2 a8f2 s         XOR     A
a8f3 a8f3 d 0698
a8f3 a8f3 s         LD      B,80H+24        ; 24 bits
a8f5 a8f5 d cd6ea7
a8f5 a8f5 s         CALL    RETINT          ; Return the integer
a8f8 a8f8 d 214da2
a8f8 a8f8 s         LD      HL,PRNUMS       ; Print number string
a8fb a8fb d e5
a8fb a8fb s         PUSH    HL              ; Save for return
a8fc a8fc d 212eb1
a8fc a8fc s NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
a8ff a8ff d e5
a8ff a8ff s         PUSH    HL              ; Save for return
a900 a900 d cd57a7
a900 a900 s         CALL    TSTSGN          ; Test sign of FPREG
a903 a903 d 3620
a903 a903 s         LD      (HL),' '        ; Space at start
a905 a905 d f20aa9
a905 a905 s         JP      P,SPCFST        ; Positive - Space to start
a908 a908 d 362d
a908 a908 s         LD      (HL),'-'        ; '-' sign at start
a90a a90a d 23
a90a a90a s SPCFST: INC     HL              ; First byte of number
a90b a90b d 3630
a90b a90b s         LD      (HL),'0'        ; '0' if zero
a90d a90d d cac0a9
a90d a90d s         JP      Z,JSTZER        ; Return '0' if zero
a910 a910 d e5
a910 a910 s         PUSH    HL              ; Save buffer address
a911 a911 d fc80a7
a911 a911 s         CALL    M,INVSGN        ; Negate FPREG if negative
a914 a914 d af
a914 a914 s         XOR     A               ; Zero A
a915 a915 d f5
a915 a915 s         PUSH    AF              ; Save it
a916 a916 d cdc6a9
a916 a916 s         CALL    RNGTST          ; Test number is in range
a919 a919 d 014391
a919 a919 s SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
a91c a91c d 11f84f
a91c a91c s         LD      DE,4FF8H
a91f a91f d cdd2a7
a91f a91f s         CALL    CMPNUM          ; Compare numbers
a922 a922 d b7
a922 a922 s         OR      A
a923 a923 d e237a9
a923 a923 s         JP      PO,INRNG        ; > 99999.9 - Sort it out
a926 a926 d f1
a926 a926 s         POP     AF              ; Restore count
a927 a927 d cdb4a8
a927 a927 s         CALL    MULTEN          ; Multiply by ten
a92a a92a d f5
a92a a92a s         PUSH    AF              ; Re-save count
a92b a92b d c319a9
a92b a92b s         JP      SIXDIG          ; Test it again
a92e a92e s 
a92e a92e d cd9fa6
a92e a92e s GTSIXD: CALL    DIV10           ; Divide by 10
a931 a931 d f1
a931 a931 s         POP     AF              ; Get count
a932 a932 d 3c
a932 a932 s         INC     A               ; Count divides
a933 a933 d f5
a933 a933 s         PUSH    AF              ; Re-save count
a934 a934 d cdc6a9
a934 a934 s         CALL    RNGTST          ; Test number is in range
a937 a937 d cdffa4
a937 a937 s INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
a93a a93a d 3c
a93a a93a s         INC     A
a93b a93b d cdffa7
a93b a93b s         CALL    FPINT           ; F.P to integer
a93e a93e d cd98a7
a93e a93e s         CALL    FPBCDE          ; Move BCDE to FPREG
a941 a941 d 010603
a941 a941 s         LD      BC,0306H        ; 1E+06 to 1E-03 range
a944 a944 d f1
a944 a944 s         POP     AF              ; Restore count
a945 a945 d 81
a945 a945 s         ADD     A,C             ; 6 digits before point
a946 a946 d 3c
a946 a946 s         INC     A               ; Add one
a947 a947 d fa53a9
a947 a947 s         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
a94a a94a d fe08
a94a a94a s         CP      6+1+1           ; More than 999999 ?
a94c a94c d d253a9
a94c a94c s         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
a94f a94f d 3c
a94f a94f s         INC     A               ; Adjust for exponent
a950 a950 d 47
a950 a950 s         LD      B,A             ; Exponent of number
a951 a951 d 3e02
a951 a951 s         LD      A,2             ; Make it zero after
a953 a953 s 
a953 a953 d 3d
a953 a953 s MAKNUM: DEC     A               ; Adjust for digits to do
a954 a954 d 3d
a954 a954 s         DEC     A
a955 a955 d e1
a955 a955 s         POP     HL              ; Restore buffer address
a956 a956 d f5
a956 a956 s         PUSH    AF              ; Save count
a957 a957 d 11d9a9
a957 a957 s         LD      DE,POWERS       ; Powers of ten
a95a a95a d 05
a95a a95a s         DEC     B               ; Count digits before point
a95b a95b d c264a9
a95b a95b s         JP      NZ,DIGTXT       ; Not zero - Do number
a95e a95e d 362e
a95e a95e s         LD      (HL),'.'        ; Save point
a960 a960 d 23
a960 a960 s         INC     HL              ; Move on
a961 a961 d 3630
a961 a961 s         LD      (HL),'0'        ; Save zero
a963 a963 d 23
a963 a963 s         INC     HL              ; Move on
a964 a964 d 05
a964 a964 s DIGTXT: DEC     B               ; Count digits before point
a965 a965 d 362e
a965 a965 s         LD      (HL),'.'        ; Save point in case
a967 a967 d ccada7
a967 a967 s         CALL    Z,INCHL         ; Last digit - move on
a96a a96a d c5
a96a a96a s         PUSH    BC              ; Save digits before point
a96b a96b d e5
a96b a96b s         PUSH    HL              ; Save buffer address
a96c a96c d d5
a96c a96c s         PUSH    DE              ; Save powers of ten
a96d a96d d cda3a7
a96d a96d s         CALL    BCDEFP          ; Move FPREG to BCDE
a970 a970 d e1
a970 a970 s         POP     HL              ; Powers of ten table
a971 a971 d 062f
a971 a971 s         LD      B, '0'-1        ; ASCII '0' - 1
a973 a973 d 04
a973 a973 s TRYAGN: INC     B               ; Count subtractions
a974 a974 d 7b
a974 a974 s         LD      A,E             ; Get LSB
a975 a975 d 96
a975 a975 s         SUB     (HL)            ; Subtract LSB
a976 a976 d 5f
a976 a976 s         LD      E,A             ; Save LSB
a977 a977 d 23
a977 a977 s         INC     HL
a978 a978 d 7a
a978 a978 s         LD      A,D             ; Get NMSB
a979 a979 d 9e
a979 a979 s         SBC     A,(HL)          ; Subtract NMSB
a97a a97a d 57
a97a a97a s         LD      D,A             ; Save NMSB
a97b a97b d 23
a97b a97b s         INC     HL
a97c a97c d 79
a97c a97c s         LD      A,C             ; Get MSB
a97d a97d d 9e
a97d a97d s         SBC     A,(HL)          ; Subtract MSB
a97e a97e d 4f
a97e a97e s         LD      C,A             ; Save MSB
a97f a97f d 2b
a97f a97f s         DEC     HL              ; Point back to start
a980 a980 d 2b
a980 a980 s         DEC     HL
a981 a981 d d273a9
a981 a981 s         JP      NC,TRYAGN       ; No overflow - Try again
a984 a984 d cdb6a5
a984 a984 s         CALL    PLUCDE          ; Restore number
a987 a987 d 23
a987 a987 s         INC     HL              ; Start of next number
a988 a988 d cd98a7
a988 a988 s         CALL    FPBCDE          ; Move BCDE to FPREG
a98b a98b d eb
a98b a98b s         EX      DE,HL           ; Save point in table
a98c a98c d e1
a98c a98c s         POP     HL              ; Restore buffer address
a98d a98d d 70
a98d a98d s         LD      (HL),B          ; Save digit in buffer
a98e a98e d 23
a98e a98e s         INC     HL              ; And move on
a98f a98f d c1
a98f a98f s         POP     BC              ; Restore digit count
a990 a990 d 0d
a990 a990 s         DEC     C               ; Count digits
a991 a991 d c264a9
a991 a991 s         JP      NZ,DIGTXT       ; More - Do them
a994 a994 d 05
a994 a994 s         DEC     B               ; Any decimal part?
a995 a995 d caa4a9
a995 a995 s         JP      Z,DOEBIT        ; No - Do 'E' bit
a998 a998 d 2b
a998 a998 s SUPTLZ: DEC     HL              ; Move back through buffer
a999 a999 d 7e
a999 a999 s         LD      A,(HL)          ; Get character
a99a a99a d fe30
a99a a99a s         CP      '0'             ; '0' character?
a99c a99c d ca98a9
a99c a99c s         JP      Z,SUPTLZ        ; Yes - Look back for more
a99f a99f d fe2e
a99f a99f s         CP      '.'             ; A decimal point?
a9a1 a9a1 d c4ada7
a9a1 a9a1 s         CALL    NZ,INCHL        ; Move back over digit
a9a4 a9a4 s 
a9a4 a9a4 d f1
a9a4 a9a4 s DOEBIT: POP     AF              ; Get 'E' flag
a9a5 a9a5 d cac3a9
a9a5 a9a5 s         JP      Z,NOENED        ; No 'E' needed - End buffer
a9a8 a9a8 d 3645
a9a8 a9a8 s         LD      (HL),'E'        ; Put 'E' in buffer
a9aa a9aa d 23
a9aa a9aa s         INC     HL              ; And move on
a9ab a9ab d 362b
a9ab a9ab s         LD      (HL),'+'        ; Put '+' in buffer
a9ad a9ad d f2b4a9
a9ad a9ad s         JP      P,OUTEXP        ; Positive - Output exponent
a9b0 a9b0 d 362d
a9b0 a9b0 s         LD      (HL),'-'        ; Put '-' in buffer
a9b2 a9b2 d 2f
a9b2 a9b2 s         CPL                     ; Negate exponent
a9b3 a9b3 d 3c
a9b3 a9b3 s         INC     A
a9b4 a9b4 d 062f
a9b4 a9b4 s OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
a9b6 a9b6 d 04
a9b6 a9b6 s EXPTEN: INC     B               ; Count subtractions
a9b7 a9b7 d d60a
a9b7 a9b7 s         SUB     10              ; Tens digit
a9b9 a9b9 d d2b6a9
a9b9 a9b9 s         JP      NC,EXPTEN       ; More to do
a9bc a9bc d c63a
a9bc a9bc s         ADD     A,'0'+10        ; Restore and make ASCII
a9be a9be d 23
a9be a9be s         INC     HL              ; Move on
a9bf a9bf d 70
a9bf a9bf s         LD      (HL),B          ; Save MSB of exponent
a9c0 a9c0 d 23
a9c0 a9c0 s JSTZER: INC     HL              ;
a9c1 a9c1 d 77
a9c1 a9c1 s         LD      (HL),A          ; Save LSB of exponent
a9c2 a9c2 d 23
a9c2 a9c2 s         INC     HL
a9c3 a9c3 d 71
a9c3 a9c3 s NOENED: LD      (HL),C          ; Mark end of buffer
a9c4 a9c4 d e1
a9c4 a9c4 s         POP     HL              ; Restore code string address
a9c5 a9c5 d c9
a9c5 a9c5 s         RET
a9c6 a9c6 s 
a9c6 a9c6 d 017494
a9c6 a9c6 s RNGTST: LD      BC,9474H        ; BCDE = 999999.
a9c9 a9c9 d 11f723
a9c9 a9c9 s         LD      DE,23F7H
a9cc a9cc d cdd2a7
a9cc a9cc s         CALL    CMPNUM          ; Compare numbers
a9cf a9cf d b7
a9cf a9cf s         OR      A
a9d0 a9d0 d e1
a9d0 a9d0 s         POP     HL              ; Return address to HL
a9d1 a9d1 d e22ea9
a9d1 a9d1 s         JP      PO,GTSIXD       ; Too big - Divide by ten
a9d4 a9d4 d e9
a9d4 a9d4 s         JP      (HL)            ; Otherwise return to caller
a9d5 a9d5 s 
a9d5 a9d5 d 00000080
a9d5 a9d5 s HALF:   .BYTE      00H,00H,00H,80H ; 0.5
a9d9 a9d9 s 
a9d9 a9d9 d a08601
a9d9 a9d9 s POWERS: .BYTE      0A0H,086H,001H  ; 100000
a9dc a9dc d 102700
a9dc a9dc s         .BYTE      010H,027H,000H  ;  10000
a9df a9df d e80300
a9df a9df s         .BYTE      0E8H,003H,000H  ;   1000
a9e2 a9e2 d 640000
a9e2 a9e2 s         .BYTE      064H,000H,000H  ;    100
a9e5 a9e5 d 0a0000
a9e5 a9e5 s         .BYTE      00AH,000H,000H  ;     10
a9e8 a9e8 d 010000
a9e8 a9e8 s         .BYTE      001H,000H,000H  ;      1
a9eb a9eb s 
a9eb a9eb d 2180a7
a9eb a9eb s NEGAFT: LD  HL,INVSGN           ; Negate result
a9ee a9ee d e3
a9ee a9ee s         EX      (SP),HL         ; To be done after caller
a9ef a9ef d e9
a9ef a9ef s         JP      (HL)            ; Return to caller
a9f0 a9f0 s 
a9f0 a9f0 d cd88a7
a9f0 a9f0 s SQR:    CALL    STAKFP          ; Put value on stack
a9f3 a9f3 d 21d5a9
a9f3 a9f3 s         LD      HL,HALF         ; Set power to 1/2
a9f6 a9f6 d cd95a7
a9f6 a9f6 s         CALL    PHLTFP          ; Move 1/2 to FPREG
a9f9 a9f9 s 
a9f9 a9f9 d c1
a9f9 a9f9 s POWER:  POP     BC              ; Get base
a9fa a9fa d d1
a9fa a9fa s         POP     DE
a9fb a9fb d cd57a7
a9fb a9fb s         CALL    TSTSGN          ; Test sign of power
a9fe a9fe d 78
a9fe a9fe s         LD      A,B             ; Get exponent of base
a9ff a9ff d ca3eaa
a9ff a9ff s         JP      Z,EXP           ; Make result 1 if zero
aa02 aa02 d f209aa
aa02 aa02 s         JP      P,POWER1        ; Positive base - Ok
aa05 aa05 d b7
aa05 aa05 s         OR      A               ; Zero to negative power?
aa06 aa06 d cab094
aa06 aa06 s         JP      Z,DZERR         ; Yes - ?/0 Error
aa09 aa09 d b7
aa09 aa09 s POWER1: OR      A               ; Base zero?
aa0a aa0a d ca78a5
aa0a aa0a s         JP      Z,SAVEXP        ; Yes - Return zero
aa0d aa0d d d5
aa0d aa0d s         PUSH    DE              ; Save base
aa0e aa0e d c5
aa0e aa0e s         PUSH    BC
aa0f aa0f d 79
aa0f aa0f s         LD      A,C             ; Get MSB of base
aa10 aa10 d f67f
aa10 aa10 s         OR      01111111B       ; Get sign status
aa12 aa12 d cda3a7
aa12 aa12 s         CALL    BCDEFP          ; Move power to BCDE
aa15 aa15 d f226aa
aa15 aa15 s         JP      P,POWER2        ; Positive base - Ok
aa18 aa18 d d5
aa18 aa18 s         PUSH    DE              ; Save power
aa19 aa19 d c5
aa19 aa19 s         PUSH    BC
aa1a aa1a d cd2aa8
aa1a aa1a s         CALL    INT             ; Get integer of power
aa1d aa1d d c1
aa1d aa1d s         POP     BC              ; Restore power
aa1e aa1e d d1
aa1e aa1e s         POP     DE
aa1f aa1f d f5
aa1f aa1f s         PUSH    AF              ; MSB of base
aa20 aa20 d cdd2a7
aa20 aa20 s         CALL    CMPNUM          ; Power an integer?
aa23 aa23 d e1
aa23 aa23 s         POP     HL              ; Restore MSB of base
aa24 aa24 d 7c
aa24 aa24 s         LD      A,H             ; but don't affect flags
aa25 aa25 d 1f
aa25 aa25 s         RRA                     ; Exponent odd or even?
aa26 aa26 d e1
aa26 aa26 s POWER2: POP     HL              ; Restore MSB and exponent
aa27 aa27 d 222bb1
aa27 aa27 s         LD      (FPREG+2),HL    ; Save base in FPREG
aa2a aa2a d e1
aa2a aa2a s         POP     HL              ; LSBs of base
aa2b aa2b d 2229b1
aa2b aa2b s         LD      (FPREG),HL      ; Save in FPREG
aa2e aa2e d dceba9
aa2e aa2e s         CALL    C,NEGAFT        ; Odd power - Negate result
aa31 aa31 d cc80a7
aa31 aa31 s         CALL    Z,INVSGN        ; Negative base - Negate it
aa34 aa34 d d5
aa34 aa34 s         PUSH    DE              ; Save power
aa35 aa35 d c5
aa35 aa35 s         PUSH    BC
aa36 aa36 d cd0ba6
aa36 aa36 s         CALL    LOG             ; Get LOG of base
aa39 aa39 d c1
aa39 aa39 s         POP     BC              ; Restore power
aa3a aa3a d d1
aa3a aa3a s         POP     DE
aa3b aa3b d cd4ca6
aa3b aa3b s         CALL    FPMULT          ; Multiply LOG by power
aa3e aa3e s 
aa3e aa3e d cd88a7
aa3e aa3e s EXP:    CALL    STAKFP          ; Put value on stack
aa41 aa41 d 013881
aa41 aa41 s         LD      BC,08138H       ; BCDE = 1/Ln(2)
aa44 aa44 d 113baa
aa44 aa44 s         LD      DE,0AA3BH
aa47 aa47 d cd4ca6
aa47 aa47 s         CALL    FPMULT          ; Multiply value by 1/LN(2)
aa4a aa4a d 3a2cb1
aa4a aa4a s         LD      A,(FPEXP)       ; Get exponent
aa4d aa4d d fe88
aa4d aa4d s         CP      80H+8           ; Is it in range?
aa4f aa4f d d233a7
aa4f aa4f s         JP      NC,OVTST1       ; No - Test for overflow
aa52 aa52 d cd2aa8
aa52 aa52 s         CALL    INT             ; Get INT of FPREG
aa55 aa55 d c680
aa55 aa55 s         ADD     A,80H           ; For excess 128
aa57 aa57 d c602
aa57 aa57 s         ADD     A,2             ; Exponent > 126?
aa59 aa59 d da33a7
aa59 aa59 s         JP      C,OVTST1        ; Yes - Test for overflow
aa5c aa5c d f5
aa5c aa5c s         PUSH    AF              ; Save scaling factor
aa5d aa5d d 21faa5
aa5d aa5d s         LD      HL,UNITY        ; Point to 1.
aa60 aa60 d cd02a5
aa60 aa60 s         CALL    ADDPHL          ; Add 1 to FPREG
aa63 aa63 d cd43a6
aa63 aa63 s         CALL    MULLN2          ; Multiply by LN(2)
aa66 aa66 d f1
aa66 aa66 s         POP     AF              ; Restore scaling factor
aa67 aa67 d c1
aa67 aa67 s         POP     BC              ; Restore exponent
aa68 aa68 d d1
aa68 aa68 s         POP     DE
aa69 aa69 d f5
aa69 aa69 s         PUSH    AF              ; Save scaling factor
aa6a aa6a d cd0ea5
aa6a aa6a s         CALL    SUBCDE          ; Subtract exponent from FPREG
aa6d aa6d d cd80a7
aa6d aa6d s         CALL    INVSGN          ; Negate result
aa70 aa70 d 217eaa
aa70 aa70 s         LD      HL,EXPTAB       ; Coefficient table
aa73 aa73 d cdaeaa
aa73 aa73 s         CALL    SMSER1          ; Sum the series
aa76 aa76 d 110000
aa76 aa76 s         LD      DE,0            ; Zero LSBs
aa79 aa79 d c1
aa79 aa79 s         POP     BC              ; Scaling factor
aa7a aa7a d 4a
aa7a aa7a s         LD      C,D             ; Zero MSB
aa7b aa7b d c34ca6
aa7b aa7b s         JP      FPMULT          ; Scale result to correct value
aa7e aa7e s 
aa7e aa7e d 08
aa7e aa7e s EXPTAB: .BYTE      8                       ; Table used by EXP
aa7f aa7f d 402e9474
aa7f aa7f s         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
aa83 aa83 d 704f2e77
aa83 aa83 s         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
aa87 aa87 d 6e02887a
aa87 aa87 s         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
aa8b aa8b d e6a02a7c
aa8b aa8b s         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
aa8f aa8f d 50aaaa7e
aa8f aa8f s         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
aa93 aa93 d ffff7f7f
aa93 aa93 s         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
aa97 aa97 d 00008081
aa97 aa97 s         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
aa9b aa9b d 00000081
aa9b aa9b s         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
aa9f aa9f s 
aa9f aa9f d cd88a7
aa9f aa9f s SUMSER: CALL    STAKFP          ; Put FPREG on stack
aaa2 aaa2 d 114aa6
aaa2 aaa2 s         LD      DE,MULT         ; Multiply by "X"
aaa5 aaa5 d d5
aaa5 aaa5 s         PUSH    DE              ; To be done after
aaa6 aaa6 d e5
aaa6 aaa6 s         PUSH    HL              ; Save address of table
aaa7 aaa7 d cda3a7
aaa7 aaa7 s         CALL    BCDEFP          ; Move FPREG to BCDE
aaaa aaaa d cd4ca6
aaaa aaaa s         CALL    FPMULT          ; Square the value
aaad aaad d e1
aaad aaad s         POP     HL              ; Restore address of table
aaae aaae d cd88a7
aaae aaae s SMSER1: CALL    STAKFP          ; Put value on stack
aab1 aab1 d 7e
aab1 aab1 s         LD      A,(HL)          ; Get number of coefficients
aab2 aab2 d 23
aab2 aab2 s         INC     HL              ; Point to start of table
aab3 aab3 d cd95a7
aab3 aab3 s         CALL    PHLTFP          ; Move coefficient to FPREG
aab6 aab6 d 06
aab6 aab6 s         .BYTE      06H             ; Skip "POP AF"
aab7 aab7 d f1
aab7 aab7 s SUMLP:  POP     AF              ; Restore count
aab8 aab8 d c1
aab8 aab8 s         POP     BC              ; Restore number
aab9 aab9 d d1
aab9 aab9 s         POP     DE
aaba aaba d 3d
aaba aaba s         DEC     A               ; Cont coefficients
aabb aabb d c8
aabb aabb s         RET     Z               ; All done
aabc aabc d d5
aabc aabc s         PUSH    DE              ; Save number
aabd aabd d c5
aabd aabd s         PUSH    BC
aabe aabe d f5
aabe aabe s         PUSH    AF              ; Save count
aabf aabf d e5
aabf aabf s         PUSH    HL              ; Save address in table
aac0 aac0 d cd4ca6
aac0 aac0 s         CALL    FPMULT          ; Multiply FPREG by BCDE
aac3 aac3 d e1
aac3 aac3 s         POP     HL              ; Restore address in table
aac4 aac4 d cda6a7
aac4 aac4 s         CALL    LOADFP          ; Number at HL to BCDE
aac7 aac7 d e5
aac7 aac7 s         PUSH    HL              ; Save address in table
aac8 aac8 d cd11a5
aac8 aac8 s         CALL    FPADD           ; Add coefficient to FPREG
aacb aacb d e1
aacb aacb s         POP     HL              ; Restore address in table
aacc aacc d c3b7aa
aacc aacc s         JP      SUMLP           ; More coefficients
aacf aacf s 
aacf aacf d cd57a7
aacf aacf s RND:    CALL    TSTSGN          ; Test sign of FPREG
aad2 aad2 d 215eb0
aad2 aad2 s         LD      HL,SEED+2       ; Random number seed
aad5 aad5 d fa30ab
aad5 aad5 s         JP      M,RESEED        ; Negative - Re-seed
aad8 aad8 d 217fb0
aad8 aad8 s         LD      HL,LSTRND       ; Last random number
aadb aadb d cd95a7
aadb aadb s         CALL    PHLTFP          ; Move last RND to FPREG
aade aade d 215eb0
aade aade s         LD      HL,SEED+2       ; Random number seed
aae1 aae1 d c8
aae1 aae1 s         RET     Z               ; Return if RND(0)
aae2 aae2 d 86
aae2 aae2 s         ADD     A,(HL)          ; Add (SEED)+2)
aae3 aae3 d e607
aae3 aae3 s         AND     00000111B       ; 0 to 7
aae5 aae5 d 0600
aae5 aae5 s         LD      B,0
aae7 aae7 d 77
aae7 aae7 s         LD      (HL),A          ; Re-save seed
aae8 aae8 d 23
aae8 aae8 s         INC     HL              ; Move to coefficient table
aae9 aae9 d 87
aae9 aae9 s         ADD     A,A             ; 4 bytes
aaea aaea d 87
aaea aaea s         ADD     A,A             ; per entry
aaeb aaeb d 4f
aaeb aaeb s         LD      C,A             ; BC = Offset into table
aaec aaec d 09
aaec aaec s         ADD     HL,BC           ; Point to coefficient
aaed aaed d cda6a7
aaed aaed s         CALL    LOADFP          ; Coefficient to BCDE
aaf0 aaf0 d cd4ca6
aaf0 aaf0 s         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
aaf3 aaf3 d 3a5db0
aaf3 aaf3 s         LD      A,(SEED+1)      ; Get (SEED+1)
aaf6 aaf6 d 3c
aaf6 aaf6 s         INC     A               ; Add 1
aaf7 aaf7 d e603
aaf7 aaf7 s         AND     00000011B       ; 0 to 3
aaf9 aaf9 d 0600
aaf9 aaf9 s         LD      B,0
aafb aafb d fe01
aafb aafb s         CP      1               ; Is it zero?
aafd aafd d 88
aafd aafd s         ADC     A,B             ; Yes - Make it 1
aafe aafe d 325db0
aafe aafe s         LD      (SEED+1),A      ; Re-save seed
ab01 ab01 d 2134ab
ab01 ab01 s         LD      HL,RNDTAB-4     ; Addition table
ab04 ab04 d 87
ab04 ab04 s         ADD     A,A             ; 4 bytes
ab05 ab05 d 87
ab05 ab05 s         ADD     A,A             ; per entry
ab06 ab06 d 4f
ab06 ab06 s         LD      C,A             ; BC = Offset into table
ab07 ab07 d 09
ab07 ab07 s         ADD     HL,BC           ; Point to value
ab08 ab08 d cd02a5
ab08 ab08 s         CALL    ADDPHL          ; Add value to FPREG
ab0b ab0b d cda3a7
ab0b ab0b s RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
ab0e ab0e d 7b
ab0e ab0e s         LD      A,E             ; Get LSB
ab0f ab0f d 59
ab0f ab0f s         LD      E,C             ; LSB = MSB
ab10 ab10 d ee4f
ab10 ab10 s         XOR     01001111B       ; Fiddle around
ab12 ab12 d 4f
ab12 ab12 s         LD      C,A             ; New MSB
ab13 ab13 d 3680
ab13 ab13 s         LD      (HL),80H        ; Set exponent
ab15 ab15 d 2b
ab15 ab15 s         DEC     HL              ; Point to MSB
ab16 ab16 d 46
ab16 ab16 s         LD      B,(HL)          ; Get MSB
ab17 ab17 d 3680
ab17 ab17 s         LD      (HL),80H        ; Make value -0.5
ab19 ab19 d 215cb0
ab19 ab19 s         LD      HL,SEED         ; Random number seed
ab1c ab1c d 34
ab1c ab1c s         INC     (HL)            ; Count seed
ab1d ab1d d 7e
ab1d ab1d s         LD      A,(HL)          ; Get seed
ab1e ab1e d d6ab
ab1e ab1e s         SUB     171             ; Do it modulo 171
ab20 ab20 d c227ab
ab20 ab20 s         JP      NZ,RND2         ; Non-zero - Ok
ab23 ab23 d 77
ab23 ab23 s         LD      (HL),A          ; Zero seed
ab24 ab24 d 0c
ab24 ab24 s         INC     C               ; Fillde about
ab25 ab25 d 15
ab25 ab25 s         DEC     D               ; with the
ab26 ab26 d 1c
ab26 ab26 s         INC     E               ; number
ab27 ab27 d cd62a5
ab27 ab27 s RND2:   CALL    BNORM           ; Normalise number
ab2a ab2a d 217fb0
ab2a ab2a s         LD      HL,LSTRND       ; Save random number
ab2d ab2d d c3afa7
ab2d ab2d s         JP      FPTHL           ; Move FPREG to last and return
ab30 ab30 s 
ab30 ab30 d 77
ab30 ab30 s RESEED: LD      (HL),A          ; Re-seed random numbers
ab31 ab31 d 2b
ab31 ab31 s         DEC     HL
ab32 ab32 d 77
ab32 ab32 s         LD      (HL),A
ab33 ab33 d 2b
ab33 ab33 s         DEC     HL
ab34 ab34 d 77
ab34 ab34 s         LD      (HL),A
ab35 ab35 d c30bab
ab35 ab35 s         JP      RND1            ; Return RND seed
ab38 ab38 s 
ab38 ab38 d 68b14668
ab38 ab38 s RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
ab3c ab3c d 99e99269
ab3c ab3c s         .BYTE   099H,0E9H,092H,069H
ab40 ab40 d 10d17568
ab40 ab40 s         .BYTE   010H,0D1H,075H,068H
ab44 ab44 s 
ab44 ab44 d 218eab
ab44 ab44 s COS:    LD      HL,HALFPI       ; Point to PI/2
ab47 ab47 d cd02a5
ab47 ab47 s         CALL    ADDPHL          ; Add it to PPREG
ab4a ab4a d cd88a7
ab4a ab4a s SIN:    CALL    STAKFP          ; Put angle on stack
ab4d ab4d d 014983
ab4d ab4d s         LD      BC,8349H        ; BCDE = 2 PI
ab50 ab50 d 11db0f
ab50 ab50 s         LD      DE,0FDBH
ab53 ab53 d cd98a7
ab53 ab53 s         CALL    FPBCDE          ; Move 2 PI to FPREG
ab56 ab56 d c1
ab56 ab56 s         POP     BC              ; Restore angle
ab57 ab57 d d1
ab57 ab57 s         POP     DE
ab58 ab58 d cdada6
ab58 ab58 s         CALL    DVBCDE          ; Divide angle by 2 PI
ab5b ab5b d cd88a7
ab5b ab5b s         CALL    STAKFP          ; Put it on stack
ab5e ab5e d cd2aa8
ab5e ab5e s         CALL    INT             ; Get INT of result
ab61 ab61 d c1
ab61 ab61 s         POP     BC              ; Restore number
ab62 ab62 d d1
ab62 ab62 s         POP     DE
ab63 ab63 d cd0ea5
ab63 ab63 s         CALL    SUBCDE          ; Make it 0 <= value < 1
ab66 ab66 d 2192ab
ab66 ab66 s         LD      HL,QUARTR       ; Point to 0.25
ab69 ab69 d cd08a5
ab69 ab69 s         CALL    SUBPHL          ; Subtract value from 0.25
ab6c ab6c d cd57a7
ab6c ab6c s         CALL    TSTSGN          ; Test sign of value
ab6f ab6f d 37
ab6f ab6f s         SCF                     ; Flag positive
ab70 ab70 d f27aab
ab70 ab70 s         JP      P,SIN1          ; Positive - Ok
ab73 ab73 d cdffa4
ab73 ab73 s         CALL    ROUND           ; Add 0.5 to value
ab76 ab76 d cd57a7
ab76 ab76 s         CALL    TSTSGN          ; Test sign of value
ab79 ab79 d b7
ab79 ab79 s         OR      A               ; Flag negative
ab7a ab7a d f5
ab7a ab7a s SIN1:   PUSH    AF              ; Save sign
ab7b ab7b d f480a7
ab7b ab7b s         CALL    P,INVSGN        ; Negate value if positive
ab7e ab7e d 2192ab
ab7e ab7e s         LD      HL,QUARTR       ; Point to 0.25
ab81 ab81 d cd02a5
ab81 ab81 s         CALL    ADDPHL          ; Add 0.25 to value
ab84 ab84 d f1
ab84 ab84 s         POP     AF              ; Restore sign
ab85 ab85 d d480a7
ab85 ab85 s         CALL    NC,INVSGN       ; Negative - Make positive
ab88 ab88 d 2196ab
ab88 ab88 s         LD      HL,SINTAB       ; Coefficient table
ab8b ab8b d c39faa
ab8b ab8b s         JP      SUMSER          ; Evaluate sum of series
ab8e ab8e s 
ab8e ab8e d db0f4981
ab8e ab8e s HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
ab92 ab92 s 
ab92 ab92 d 0000007f
ab92 ab92 s QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
ab96 ab96 s 
ab96 ab96 d 05
ab96 ab96 s SINTAB: .BYTE   5                       ; Table used by SIN
ab97 ab97 d bad71e86
ab97 ab97 s         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
ab9b ab9b d 64269987
ab9b ab9b s         .BYTE   064H,026H,099H,087H     ;-76.575
ab9f ab9f d 58342387
ab9f ab9f s         .BYTE   058H,034H,023H,087H     ; 81.602
aba3 aba3 d e05da586
aba3 aba3 s         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
aba7 aba7 d da0f4983
aba7 aba7 s         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
abab abab s 
abab abab d cd88a7
abab abab s TAN:    CALL    STAKFP          ; Put angle on stack
abae abae d cd4aab
abae abae s         CALL    SIN             ; Get SIN of angle
abb1 abb1 d c1
abb1 abb1 s         POP     BC              ; Restore angle
abb2 abb2 d e1
abb2 abb2 s         POP     HL
abb3 abb3 d cd88a7
abb3 abb3 s         CALL    STAKFP          ; Save SIN of angle
abb6 abb6 d eb
abb6 abb6 s         EX      DE,HL           ; BCDE = Angle
abb7 abb7 d cd98a7
abb7 abb7 s         CALL    FPBCDE          ; Angle to FPREG
abba abba d cd44ab
abba abba s         CALL    COS             ; Get COS of angle
abbd abbd d c3aba6
abbd abbd s         JP      DIV             ; TAN = SIN / COS
abc0 abc0 s 
abc0 abc0 d cd57a7
abc0 abc0 s ATN:    CALL    TSTSGN          ; Test sign of value
abc3 abc3 d fceba9
abc3 abc3 s         CALL    M,NEGAFT        ; Negate result after if -ve
abc6 abc6 d fc80a7
abc6 abc6 s         CALL    M,INVSGN        ; Negate value if -ve
abc9 abc9 d 3a2cb1
abc9 abc9 s         LD      A,(FPEXP)       ; Get exponent
abcc abcc d fe81
abcc abcc s         CP      81H             ; Number less than 1?
abce abce d daddab
abce abce s         JP      C,ATN1          ; Yes - Get arc tangnt
abd1 abd1 d 010081
abd1 abd1 s         LD      BC,8100H        ; BCDE = 1
abd4 abd4 d 51
abd4 abd4 s         LD      D,C
abd5 abd5 d 59
abd5 abd5 s         LD      E,C
abd6 abd6 d cdada6
abd6 abd6 s         CALL    DVBCDE          ; Get reciprocal of number
abd9 abd9 d 2108a5
abd9 abd9 s         LD      HL,SUBPHL       ; Sub angle from PI/2
abdc abdc d e5
abdc abdc s         PUSH    HL              ; Save for angle > 1
abdd abdd d 21e7ab
abdd abdd s ATN1:   LD      HL,ATNTAB       ; Coefficient table
abe0 abe0 d cd9faa
abe0 abe0 s         CALL    SUMSER          ; Evaluate sum of series
abe3 abe3 d 218eab
abe3 abe3 s         LD      HL,HALFPI       ; PI/2 - angle in case > 1
abe6 abe6 d c9
abe6 abe6 s         RET                     ; Number > 1 - Sub from PI/2
abe7 abe7 s 
abe7 abe7 d 09
abe7 abe7 s ATNTAB: .BYTE   9                       ; Table used by ATN
abe8 abe8 d 4ad73b78
abe8 abe8 s         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
abec abec d 026e847b
abec abec s         .BYTE   002H,06EH,084H,07BH     ;-1/15
abf0 abf0 d fec12f7c
abf0 abf0 s         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
abf4 abf4 d 74319a7d
abf4 abf4 s         .BYTE   074H,031H,09AH,07DH     ;-1/11
abf8 abf8 d 843d5a7d
abf8 abf8 s         .BYTE   084H,03DH,05AH,07DH     ; 1/9
abfc abfc d c87f917e
abfc abfc s         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
ac00 ac00 d e4bb4c7e
ac00 ac00 s         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
ac04 ac04 d 6caaaa7f
ac04 ac04 s         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
ac08 ac08 d 00000081
ac08 ac08 s         .BYTE   000H,000H,000H,081H     ; 1/1
ac0c ac0c s 
ac0c ac0c s 
ac0c ac0c d c9
ac0c ac0c s ARET:   RET                     ; A RETurn instruction
ac0d ac0d s 
ac0d ac0d s ;GETINP: RST	10H             ;input a character <FIXME>
ac0d ac0d d cd8fad
ac0d ac0d s GETINP: call	umon_getc	;<ESH> get serial input
ac10 ac10 d c9
ac10 ac10 s         RET
ac11 ac11 s 
ac11 ac11 s CLS: 
ac11 ac11 d 3e0c
ac11 ac11 s         LD      A,CS            ; ASCII Clear screen
ac13 ac13 d c34bad
ac13 ac13 s         JP      MONOUT          ; Output character
ac16 ac16 s 
ac16 ac16 d cdd6a4
ac16 ac16 s WIDTH:  CALL    GETINT          ; Get integer 0-255
ac19 ac19 d 7b
ac19 ac19 s         LD      A,E             ; Width to A
ac1a ac1a d 3287b0
ac1a ac1a s         LD      (LWIDTH),A      ; Set width
ac1d ac1d d c9
ac1d ac1d s         RET
ac1e ac1e s 
ac1e ac1e d cd759d
ac1e ac1e s LINES:  CALL    GETNUM          ; Get a number
ac21 ac21 d cdba99
ac21 ac21 s         CALL    DEINT           ; Get integer -32768 to 32767
ac24 ac24 d ed538bb0
ac24 ac24 s         LD      (LINESC),DE     ; Set lines counter
ac28 ac28 d ed538db0
ac28 ac28 s         LD      (LINESN),DE     ; Set lines number
ac2c ac2c d c9
ac2c ac2c s         RET
ac2d ac2d s 
ac2d ac2d d cdba99
ac2d ac2d s DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
ac30 ac30 d d5
ac30 ac30 s         PUSH    DE              ; Save number
ac31 ac31 d e1
ac31 ac31 s         POP     HL              ; Number to HL
ac32 ac32 d 46
ac32 ac32 s         LD      B,(HL)          ; Get LSB of contents
ac33 ac33 d 23
ac33 ac33 s         INC     HL
ac34 ac34 d 7e
ac34 ac34 s         LD      A,(HL)          ; Get MSB of contents
ac35 ac35 d c330a1
ac35 ac35 s         JP      ABPASS          ; Return integer AB
ac38 ac38 s 
ac38 ac38 d cd759d
ac38 ac38 s DOKE:   CALL    GETNUM          ; Get a number
ac3b ac3b d cdba99
ac3b ac3b s         CALL    DEINT           ; Get integer -32768 to 32767
ac3e ac3e d d5
ac3e ac3e s         PUSH    DE              ; Save address
ac3f ac3f d cd7b97
ac3f ac3f s         CALL    CHKSYN          ; Make sure ',' follows
ac42 ac42 d 2c
ac42 ac42 s         .BYTE      ','
ac43 ac43 d cd759d
ac43 ac43 s         CALL    GETNUM          ; Get a number
ac46 ac46 d cdba99
ac46 ac46 s         CALL    DEINT           ; Get integer -32768 to 32767
ac49 ac49 d e3
ac49 ac49 s         EX      (SP),HL         ; Save value,get address
ac4a ac4a d 73
ac4a ac4a s         LD      (HL),E          ; Save LSB of value
ac4b ac4b d 23
ac4b ac4b s         INC     HL
ac4c ac4c d 72
ac4c ac4c s         LD      (HL),D          ; Save MSB of value
ac4d ac4d d e1
ac4d ac4d s         POP     HL              ; Restore code string address
ac4e ac4e d c9
ac4e ac4e s         RET
ac4f ac4f s 
ac4f ac4f s 
ac4f ac4f s ; HEX$(nn) Convert 16 bit number to Hexadecimal string
ac4f ac4f s 
ac4f ac4f d cd789d
ac4f ac4f s HEX: 	CALL	TSTNUM          ; Verify it's a number
ac52 ac52 d cdba99
ac52 ac52 s         CALL	DEINT           ; Get integer -32768 to 32767
ac55 ac55 d c5
ac55 ac55 s         PUSH	BC              ; Save contents of BC
ac56 ac56 d 212eb1
ac56 ac56 s         LD	    HL,PBUFF
ac59 ac59 d 7a
ac59 ac59 s         LD	    A,D             ; Get high order into A
ac5a ac5a d fe00
ac5a ac5a s         CP      $0
ac5c ac5c d 280c
ac5c ac5c s 		JR      Z,HEX2          ; Skip output if both high digits are zero
ac5e ac5e d cd87ac
ac5e ac5e s         CALL    BYT2ASC         ; Convert D to ASCII
ac61 ac61 d 78
ac61 ac61 s 		LD      A,B
ac62 ac62 d fe30
ac62 ac62 s 		CP      '0'
ac64 ac64 d 2802
ac64 ac64 s 		JR      Z,HEX1          ; Don't store high digit if zero
ac66 ac66 d 70
ac66 ac66 s         LD	    (HL),B          ; Store it to PBUFF
ac67 ac67 d 23
ac67 ac67 s         INC	    HL              ; Next location
ac68 ac68 d 71
ac68 ac68 s HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
ac69 ac69 d 23
ac69 ac69 s         INC     HL              ; Next location
ac6a ac6a d 7b
ac6a ac6a s HEX2:   LD	    A,E             ; Get lower byte
ac6b ac6b d cd87ac
ac6b ac6b s         CALL    BYT2ASC         ; Convert E to ASCII
ac6e ac6e d 7a
ac6e ac6e s 		LD      A,D
ac6f ac6f d fe00
ac6f ac6f s         CP      $0
ac71 ac71 d 2005
ac71 ac71 s 		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
ac73 ac73 d 78
ac73 ac73 s 		LD      A,B
ac74 ac74 d fe30
ac74 ac74 s 		CP      '0'             ; If high digit of lower byte is zero then don't print
ac76 ac76 d 2802
ac76 ac76 s 		JR      Z,HEX4
ac78 ac78 d 70
ac78 ac78 s HEX3:   LD      (HL),B          ; to PBUFF+2
ac79 ac79 d 23
ac79 ac79 s         INC     HL              ; Next location
ac7a ac7a d 71
ac7a ac7a s HEX4:   LD      (HL),C          ; to PBUFF+3
ac7b ac7b d 23
ac7b ac7b s         INC     HL              ; PBUFF+4 to zero
ac7c ac7c d af
ac7c ac7c s         XOR     A               ; Terminating character
ac7d ac7d d 77
ac7d ac7d s         LD      (HL),A          ; Store zero to terminate
ac7e ac7e d 23
ac7e ac7e s         INC     HL              ; Make sure PBUFF is terminated
ac7f ac7f d 77
ac7f ac7f s         LD      (HL),A          ; Store the double zero there
ac80 ac80 d c1
ac80 ac80 s         POP     BC              ; Get BC back
ac81 ac81 d 212eb1
ac81 ac81 s         LD      HL,PBUFF        ; Reset to start of PBUFF
ac84 ac84 d c3dea1
ac84 ac84 s         JP      STR1            ; Convert the PBUFF to a string and return it
ac87 ac87 s 
ac87 ac87 d 47
ac87 ac87 s BYT2ASC	LD      B,A             ; Save original value
ac88 ac88 d e60f
ac88 ac88 s         AND     $0F             ; Strip off upper nybble
ac8a ac8a d fe0a
ac8a ac8a s         CP      $0A             ; 0-9?
ac8c ac8c d 3802
ac8c ac8c s         JR      C,ADD30         ; If A-F, add 7 more
ac8e ac8e d c607
ac8e ac8e s         ADD     A,$07           ; Bring value up to ASCII A-F
ac90 ac90 d c630
ac90 ac90 s ADD30	ADD     A,$30           ; And make ASCII
ac92 ac92 d 4f
ac92 ac92 s         LD      C,A             ; Save converted char to C
ac93 ac93 d 78
ac93 ac93 s         LD      A,B             ; Retrieve original value
ac94 ac94 d 0f
ac94 ac94 s         RRCA                    ; and Rotate it right
ac95 ac95 d 0f
ac95 ac95 s         RRCA
ac96 ac96 d 0f
ac96 ac96 s         RRCA
ac97 ac97 d 0f
ac97 ac97 s         RRCA
ac98 ac98 d e60f
ac98 ac98 s         AND     $0F             ; Mask off upper nybble
ac9a ac9a d fe0a
ac9a ac9a s         CP      $0A             ; 0-9? < A hex?
ac9c ac9c d 3802
ac9c ac9c s         JR      C,ADD301        ; Skip Add 7
ac9e ac9e d c607
ac9e ac9e s         ADD     A,$07           ; Bring it up to ASCII A-F
aca0 aca0 d c630
aca0 aca0 s ADD301	ADD     A,$30           ; And make it full ASCII
aca2 aca2 d 47
aca2 aca2 s         LD      B,A             ; Store high order byte
aca3 aca3 d c9
aca3 aca3 s         RET	
aca4 aca4 s 
aca4 aca4 s ; Convert "&Hnnnn" to FPREG
aca4 aca4 s ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
aca4 aca4 s ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
aca4 aca4 d eb
aca4 aca4 s HEXTFP  EX      DE,HL           ; Move code string pointer to DE
aca5 aca5 d 210000
aca5 aca5 s         LD      HL,$0000        ; Zero out the value
aca8 aca8 d cdbdac
aca8 aca8 s         CALL    GETHEX          ; Check the number for valid hex
acab acab d daddac
acab acab s         JP      C,HXERR         ; First value wasn't hex, HX error
acae acae d 1805
acae acae s         JR      HEXLP1          ; Convert first character
acb0 acb0 d cdbdac
acb0 acb0 s HEXLP   CALL    GETHEX          ; Get second and addtional characters
acb3 acb3 d 381f
acb3 acb3 s         JR      C,HEXIT         ; Exit if not a hex character
acb5 acb5 d 29
acb5 acb5 s HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
acb6 acb6 d 29
acb6 acb6 s         ADD     HL,HL
acb7 acb7 d 29
acb7 acb7 s         ADD     HL,HL
acb8 acb8 d 29
acb8 acb8 s         ADD     HL,HL
acb9 acb9 d b5
acb9 acb9 s         OR      L               ; Add in D0-D3 into L
acba acba d 6f
acba acba s         LD      L,A             ; Save new value
acbb acbb d 18f3
acbb acbb s         JR      HEXLP           ; And continue until all hex characters are in
acbd acbd s 
acbd acbd d 13
acbd acbd s GETHEX  INC     DE              ; Next location
acbe acbe d 1a
acbe acbe s         LD      A,(DE)          ; Load character at pointer
acbf acbf d fe20
acbf acbf s         CP      ' '
acc1 acc1 d cabdac
acc1 acc1 s         JP      Z,GETHEX        ; Skip spaces
acc4 acc4 d d630
acc4 acc4 s         SUB     $30             ; Get absolute value
acc6 acc6 d d8
acc6 acc6 s         RET     C               ; < "0", error
acc7 acc7 d fe0a
acc7 acc7 s         CP      $0A
acc9 acc9 d 3805
acc9 acc9 s         JR      C,NOSUB7        ; Is already in the range 0-9
accb accb d d607
accb accb s         SUB     $07             ; Reduce to A-F
accd accd d fe0a
accd accd s         CP      $0A             ; Value should be $0A-$0F at this point
accf accf d d8
accf accf s         RET     C               ; CY set if was :            ; < = > ? @
acd0 acd0 d fe10
acd0 acd0 s NOSUB7  CP      $10             ; > Greater than "F"?
acd2 acd2 d 3f
acd2 acd2 s         CCF
acd3 acd3 d c9
acd3 acd3 s         RET                     ; CY set if it wasn't valid hex
acd4 acd4 s     
acd4 acd4 d eb
acd4 acd4 s HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
acd5 acd5 d 7a
acd5 acd5 s         LD      A,D             ; Load DE into AC
acd6 acd6 d 4b
acd6 acd6 s         LD      C,E             ; For prep to 
acd7 acd7 d e5
acd7 acd7 s         PUSH    HL
acd8 acd8 d cd2fa1
acd8 acd8 s         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
acdb acdb d e1
acdb acdb s         POP     HL
acdc acdc d c9
acdc acdc s         RET
acdd acdd s 
acdd acdd d 1e26
acdd acdd s HXERR:  LD      E,HX            ; ?HEX Error
acdf acdf d c3c194
acdf acdf s         JP      ERROR
ace2 ace2 s 
ace2 ace2 s ; BIN$(NN) Convert integer to a 1-16 char binary string
ace2 ace2 d cd789d
ace2 ace2 s BIN:    CALL    TSTNUM          ; Verify it's a number
ace5 ace5 d cdba99
ace5 ace5 s         CALL    DEINT           ; Get integer -32768 to 32767
ace8 ace8 d c5
ace8 ace8 s BIN2:   PUSH    BC              ; Save contents of BC
ace9 ace9 d 212eb1
ace9 ace9 s         LD      HL,PBUFF
acec acec d 0611
acec acec s         LD      B,17            ; One higher than max char count
acee acee s ZEROSUP:                        ; Suppress leading zeros
acee acee d 05
acee acee s         DEC     B               ; Max 16 chars
acef acef d 78
acef acef s         LD      A,B
acf0 acf0 d fe01
acf0 acf0 s         CP      $01
acf2 acf2 d 2808
acf2 acf2 s         JR      Z,BITOUT        ; Always output at least one character
acf4 acf4 d cb13
acf4 acf4 s         RL      E
acf6 acf6 d cb12
acf6 acf6 s         RL      D
acf8 acf8 d 30f4
acf8 acf8 s         JR      NC,ZEROSUP
acfa acfa d 1804
acfa acfa s         JR      BITOUT2
acfc acfc s BITOUT:      
acfc acfc d cb13
acfc acfc s         RL      E
acfe acfe d cb12
acfe acfe s         RL      D               ; Top bit now in carry
ad00 ad00 s BITOUT2:
ad00 ad00 d 3e30
ad00 ad00 s         LD      A,'0'           ; Char for '0'
ad02 ad02 d ce00
ad02 ad02 s         ADC     A,0             ; If carry set then '0' --> '1'
ad04 ad04 d 77
ad04 ad04 s         LD      (HL),A
ad05 ad05 d 23
ad05 ad05 s         INC     HL
ad06 ad06 d 05
ad06 ad06 s         DEC     B
ad07 ad07 d 20f3
ad07 ad07 s         JR      NZ,BITOUT
ad09 ad09 d af
ad09 ad09 s         XOR     A               ; Terminating character
ad0a ad0a d 77
ad0a ad0a s         LD      (HL),A          ; Store zero to terminate
ad0b ad0b d 23
ad0b ad0b s         INC     HL              ; Make sure PBUFF is terminated
ad0c ad0c d 77
ad0c ad0c s         LD      (HL),A          ; Store the double zero there
ad0d ad0d d c1
ad0d ad0d s         POP     BC
ad0e ad0e d 212eb1
ad0e ad0e s         LD      HL,PBUFF
ad11 ad11 d c3dea1
ad11 ad11 s         JP      STR1
ad14 ad14 s 
ad14 ad14 s ; Convert "&Bnnnn" to FPREG
ad14 ad14 s ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
ad14 ad14 d eb
ad14 ad14 s BINTFP: EX      DE,HL           ; Move code string pointer to DE
ad15 ad15 d 210000
ad15 ad15 s         LD      HL,$0000        ; Zero out the value
ad18 ad18 d cd31ad
ad18 ad18 s         CALL    CHKBIN          ; Check the number for valid bin
ad1b ad1b d da3fad
ad1b ad1b s         JP      C,BINERR        ; First value wasn't bin, HX error
ad1e ad1e d d630
ad1e ad1e s BINIT:  SUB     '0'
ad20 ad20 d 29
ad20 ad20 s         ADD     HL,HL           ; Rotate HL left
ad21 ad21 d b5
ad21 ad21 s         OR      L
ad22 ad22 d 6f
ad22 ad22 s         LD      L,A
ad23 ad23 d cd31ad
ad23 ad23 s         CALL    CHKBIN          ; Get second and addtional characters
ad26 ad26 d 30f6
ad26 ad26 s         JR      NC,BINIT        ; Process if a bin character
ad28 ad28 d eb
ad28 ad28 s         EX      DE,HL           ; Value into DE, Code string into HL
ad29 ad29 d 7a
ad29 ad29 s         LD      A,D             ; Load DE into AC
ad2a ad2a d 4b
ad2a ad2a s         LD      C,E             ; For prep to 
ad2b ad2b d e5
ad2b ad2b s         PUSH    HL
ad2c ad2c d cd2fa1
ad2c ad2c s         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
ad2f ad2f d e1
ad2f ad2f s         POP     HL
ad30 ad30 d c9
ad30 ad30 s         RET
ad31 ad31 s 
ad31 ad31 s ; Char is in A, NC if char is 0 or 1
ad31 ad31 d 13
ad31 ad31 s CHKBIN: INC     DE
ad32 ad32 d 1a
ad32 ad32 s         LD      A,(DE)
ad33 ad33 d fe20
ad33 ad33 s         CP      ' '
ad35 ad35 d ca31ad
ad35 ad35 s         JP      Z,CHKBIN        ; Skip spaces
ad38 ad38 d fe30
ad38 ad38 s         CP      '0'             ; Set C if < '0'
ad3a ad3a d d8
ad3a ad3a s         RET     C
ad3b ad3b d fe32
ad3b ad3b s         CP      '2'
ad3d ad3d d 3f
ad3d ad3d s         CCF                     ; Set C if > '1'
ad3e ad3e d c9
ad3e ad3e s         RET
ad3f ad3f s 
ad3f ad3f d 1e28
ad3f ad3f s BINERR: LD      E,BN            ; ?BIN Error
ad41 ad41 d c3c194
ad41 ad41 s         JP      ERROR
ad44 ad44 s 
ad44 ad44 s 
ad44 ad44 s JJUMP1: 
ad44 ad44 d dd21ffff
ad44 ad44 s         LD      IX,-1           ; Flag cold start
ad48 ad48 d c31191
ad48 ad48 s         JP      CSTART          ; Go and initialise
ad4b ad4b s 
ad4b ad4b s MONOUT: 
ad4b ad4b d c3bbad
ad4b ad4b s 	jp	umon_putc
ad4e ad4e s ;        JP      $0008           ; output a char
ad4e ad4e s 
ad4e ad4e s 
ad4e ad4e s MONITR: 
ad4e ad4e d c30081
ad4e ad4e s         JP      $8100           ; <ESH> goto UMON
ad51 ad51 s 
ad51 ad51 s 
ad51 ad51 d 3e00
ad51 ad51 s INITST: LD      A,0             ; Clear break flag
ad53 ad53 d 3292b0
ad53 ad53 s         LD      (BRKFLG),A
ad56 ad56 d c31891
ad56 ad56 s         JP      INIT
ad59 ad59 s 
ad59 ad59 d ed45
ad59 ad59 s ARETN:  RETN                    ; Return from NMI
ad5b ad5b s 
ad5b ad5b s 
ad5b ad5b d f5
ad5b ad5b s TSTBIT: PUSH    AF              ; Save bit mask
ad5c ad5c d a0
ad5c ad5c s         AND     B               ; Get common bits
ad5d ad5d d c1
ad5d ad5d s         POP     BC              ; Restore bit mask
ad5e ad5e d b8
ad5e ad5e s         CP      B               ; Same bit set?
ad5f ad5f d 3e00
ad5f ad5f s         LD      A,0             ; Return 0 in A
ad61 ad61 d c9
ad61 ad61 s         RET
ad62 ad62 s 
ad62 ad62 d cd8697
ad62 ad62 s OUTNCR: CALL    OUTC            ; Output character in A
ad65 ad65 d c3b09b
ad65 ad65 s         JP      PRNTCRLF        ; Output CRLF
ad68 ad68 s 
ad68 ad68 s ;;; -------------------- SERIAL I/O --------------------
ad68 ad68 s 
ad68 ad68 s ;;; 
ad68 ad68 s ;;; serial port
ad68 ad68 s ;;; umon_putc:  send a character from A
ad68 ad68 s ;;; umon_getc:  receive a character to A
ad68 ad68 s ;;;
ad68 ad68 s ;;; 
ad68 ad68 s 
ad68 ad68 s 
ad68 ad68 s serial_port:	equ	80H	;input port
ad68 ad68 s led_port:	equ	0	;port 0 for LED/keyboard output
ad68 ad68 s 	
ad68 ad68 s data_bit:	equ	80H	;input data mask
ad68 ad68 s 	
ad68 ad68 s ;;; serial port timing macros
ad68 ad68 s ;;; 23/10 seem to be OK for 4800 baud (4MHz CPU) or 19200 (16MHz CPU)
ad68 ad68 s 
ad68 ad68 s ;;; UGH - z80asm doesn't support macros
ad68 ad68 s 
ad68 ad68 s dfull:	equ	22
ad68 ad68 s dhalf:	equ	9
ad68 ad68 s 
ad68 ad68 s ;;;;; delay macro:  uses B
ad68 ad68 s ;;delay	macro	p1
ad68 ad68 s ;;	local	dilly
ad68 ad68 s ;;	ld	b,p1		;7T
ad68 ad68 s ;;
ad68 ad68 s ;;;;; 33T per loop / 28T for last
ad68 ad68 s ;;dilly:	nop			;4T
ad68 ad68 s ;;	nop			;4T
ad68 ad68 s ;;	nop			;4T
ad68 ad68 s ;;	nop			;4T
ad68 ad68 s ;;	nop			;4T
ad68 ad68 s ;;	djnz	dilly		;13T / 8T
ad68 ad68 s ;;	endm
ad68 ad68 s 
ad68 ad68 s ;;bitdly	macro			;766T
ad68 ad68 s ;;	delay	full
ad68 ad68 s ;;	endm
ad68 ad68 s 
ad68 ad68 s ;;; there are an additional 70T in the rest of the code,
ad68 ad68 s ;;; 833T is ideal 19200 baud, so 833-70 = 763 target
ad68 ad68 s ;;; 763 - 27 (call/ret) - 7 (ld) = 729
ad68 ad68 s ;;; 23* loop = 721T so add 2 NOPs and we're good
ad68 ad68 s 
ad68 ad68 s ;;; delay exactly 763T (hopefully)?
ad68 ad68 s ;;; full=22: 27T+7T+28T+21*33T = 755 + 8 = 763
ad68 ad68 s                                 ;27T (call+ret)
ad68 ad68 d 0616
ad68 ad68 s bitdly:	ld	b,dfull         ;7T
ad6a ad6a d 00
ad6a ad6a s dilly:	nop			;4T
ad6b ad6b d 00
ad6b ad6b s 	nop			;4T
ad6c ad6c d 00
ad6c ad6c s 	nop			;4T
ad6d ad6d d 00
ad6d ad6d s 	nop			;4T
ad6e ad6e d 00
ad6e ad6e s 	nop			;4T
ad6f ad6f d 10f9
ad6f ad6f s 	djnz	dilly		;13T / 8T
ad71 ad71 d 00
ad71 ad71 s 	nop			;4T
ad72 ad72 d 00
ad72 ad72 s 	nop			;4T
ad73 ad73 d c9
ad73 ad73 s 	ret
ad74 ad74 s 
ad74 ad74 s ;;; old version was 332T
ad74 ad74 s ;;; this one is 330T
ad74 ad74 s                                 ;27T (call+ret)
ad74 ad74 d 0609
ad74 ad74 s halfdly: ld	b,dhalf		;7T
ad76 ad76 d 00
ad76 ad76 s dally:	nop			;4T
ad77 ad77 d 00
ad77 ad77 s 	nop			;4T
ad78 ad78 d 00
ad78 ad78 s 	nop			;4T
ad79 ad79 d 00
ad79 ad79 s 	nop			;4T
ad7a ad7a d 00
ad7a ad7a s 	nop			;4T
ad7b ad7b d 10f9
ad7b ad7b s 	djnz	dally		;13T / 8T
ad7d ad7d d 00
ad7d ad7d s 	nop			;4T
ad7e ad7e d c9
ad7e ad7e s 	ret
ad7f ad7f s 
ad7f ad7f s ;;;
ad7f ad7f s ;;; check for serial activity (break)
ad7f ad7f s ;;; if so, wait for end of activity, then receive a character
ad7f ad7f s ;;; return 0 (Z) if no character, else char in A
ad7f ad7f s ;;;
ad7f ad7f s umon_chkbrk:
ad7f ad7f d db80
ad7f ad7f s 	in	a,(serial_port)
ad81 ad81 d e680
ad81 ad81 s 	and	data_bit
ad83 ad83 d 2008
ad83 ad83 s 	jr	nz,nobrk
ad85 ad85 s 	;; got break, wait for it to end
ad85 ad85 d db80
ad85 ad85 s isbrk:	in	a,(serial_port)
ad87 ad87 d e680
ad87 ad87 s 	and	data_bit
ad89 ad89 d 28fa
ad89 ad89 s 	jr	z, isbrk	;loop while low
ad8b ad8b s 
ad8b ad8b d 1802
ad8b ad8b s 	jr	umon_getc	;now go get a character
ad8d ad8d s 
ad8d ad8d d af
ad8d ad8d s nobrk:	xor	a		; zero a, set Z
ad8e ad8e d c9
ad8e ad8e s 	ret
ad8f ad8f s 
ad8f ad8f s ;;; 
ad8f ad8f s ;;; receive a character to A
ad8f ad8f s ;;; 
ad8f ad8f s umon_getc:	
ad8f ad8f d c5
ad8f ad8f s 	push	bc
ad90 ad90 d d5
ad90 ad90 s 	push	de
ad91 ad91 d e5
ad91 ad91 s 	push	hl
ad92 ad92 s 
ad92 ad92 d 1e09
ad92 ad92 s 	ld	e,9		; bit count (start + 8 data)
ad94 ad94 s 	
ad94 ad94 s 	;; wait for high
ad94 ad94 d db80
ad94 ad94 s ci0:	in	a,(serial_port)
ad96 ad96 d e680
ad96 ad96 s 	and	data_bit
ad98 ad98 d 28fa
ad98 ad98 s 	jr	z,ci0		;loop if/while low
ad9a ad9a s 	
ad9a ad9a d db80
ad9a ad9a s ci1:	in	a,(serial_port) ; read serial line
ad9c ad9c d e680
ad9c ad9c s 	and	data_bit	; isolate serial bit
ad9e ad9e d 20fa
ad9e ad9e s 	jr	nz,ci1		; loop while high
ada0 ada0 d cd74ad
ada0 ada0 s 	call 	halfdly		;delay to middle of first (start) bit
ada3 ada3 s 
ada3 ada3 s ci3:
ada3 ada3 d cd68ad
ada3 ada3 s 	call	bitdly	       ;delay to middle of LSB data bit    766
ada6 ada6 d db80
ada6 ada6 s 	in	a,(serial_port) ; read serial character              12
ada8 ada8 d e680
ada8 ada8 s 	and	data_bit	; isolate serial data                 7
adaa adaa d 2801
adaa adaa s 	jr	z,ci6		; j if data is 0                  7 / 12
adac adac d 3c
adac adac s 	inc	a		; now register A=serial data          4
adad adad d 1f
adad adad s ci6:	rra			; rotate it into carry                4
adae adae d 1d
adae adae s 	dec	e		; dec bit count                       4
adaf adaf d 2805
adaf adaf s 	jr	z,ci5		; j if last bit                   7 / 12
adb1 adb1 s 	
adb1 adb1 d 79
adb1 adb1 s 	ld	a,c		; this is where we assemble char      4
adb2 adb2 d 1f
adb2 adb2 s 	rra			; rotate it into the character from c 4
adb3 adb3 d 4f
adb3 adb3 s 	ld	c,a		;                                     4
adb4 adb4 s 
adb4 adb4 d 18ed
adb4 adb4 s 	jr	ci3		; do next bit                        12
adb6 adb6 s 	
adb6 adb6 s 	;; total loop ~ 836T = 52.3 uS or 19139 Hz (0.3% error, not bad!)
adb6 adb6 s 
adb6 adb6 d 79
adb6 adb6 s ci5:	ld	a,c
adb7 adb7 s 	
adb7 adb7 d e1
adb7 adb7 s 	pop	hl
adb8 adb8 d d1
adb8 adb8 s 	pop	de
adb9 adb9 d c1
adb9 adb9 s 	pop	bc
adba adba s 
adba adba d c9
adba adba s 	ret
adbb adbb s 
adbb adbb s ;;;
adbb adbb s ;;; send character in A
adbb adbb s ;;; saves all
adbb adbb s ;;; 
adbb adbb s umon_putc:
adbb adbb d c5
adbb adbb s 	push	bc
adbc adbc d d5
adbc adbc s 	push	de
adbd adbd d f5
adbd adbd s 	push	af
adbe adbe d 4f
adbe adbe s 	ld	c,a		;character to C
adbf adbf s 
adbf adbf d 1e08
adbf adbf s 	ld	e,8		;bit counter
adc1 adc1 s 	
adc1 adc1 s ;	mark			;ensure a stop bit
adc1 adc1 d 3e80
adc1 adc1 s 	ld	a,data_bit
adc3 adc3 d d300
adc3 adc3 s 	out	(led_port),a
adc5 adc5 d cd68ad
adc5 adc5 s 	call	bitdly
adc8 adc8 s 	
adc8 adc8 s ;	spc			;start bit
adc8 adc8 d 3e00
adc8 adc8 s 	ld	a,0
adca adca d d300
adca adca s 	out	(led_port),a
adcc adcc d cd68ad
adcc adcc s 	call	bitdly
adcf adcf s 	
adcf adcf s 	;; loop here for bits
adcf adcf d cb19
adcf adcf s rrot:	rr	c		;shift out LSB
add1 add1 d 3806
add1 add1 s 	jr	c,one
add3 add3 s 	
add3 add3 s ;	spc
add3 add3 d 3e00
add3 add3 s 	ld	a,0
add5 add5 d d300
add5 add5 s 	out	(led_port),a
add7 add7 d 1804
add7 add7 s 	jr	bite
add9 add9 s one:
add9 add9 s ;	mark
add9 add9 d 3e80
add9 add9 s 	ld	a,data_bit
addb addb d d300
addb addb s 	out	(led_port),a
addd addd s bite:
addd addd d cd68ad
addd addd s 	call	bitdly
ade0 ade0 s 	
ade0 ade0 d 1d
ade0 ade0 s 	dec	e
ade1 ade1 d 20ec
ade1 ade1 s 	jr	nz,rrot
ade3 ade3 s ;	mark
ade3 ade3 d 3e80
ade3 ade3 s 	ld	a,data_bit
ade5 ade5 d d300
ade5 ade5 s 	out	(led_port),a
ade7 ade7 d cd68ad
ade7 ade7 s 	call	bitdly		; stop bit
adea adea s 	
adea adea d f1
adea adea s 	pop	af
adeb adeb d d1
adeb adeb s 	pop	de
adec adec d c1
adec adec s 	pop	bc
aded aded d c9
aded aded s 	ret
adee adee s 	
adee adee s 	.end
0012 v dd
0008 v fc
0016 v id
9b2e a if
0028 v bn
0020 v cn
000a v lf
0006 v od
0000 v nf
000d v cr
000c v cs
0010 v bs
0004 v rg
0022 v uf
000c v om
0024 v mo
0014 v dz
001c v ls
0026 v hx
0002 v sn
000e v ul
0018 v tm
000a v ov
001a v os
001e v st
9b10 a on
ad94 a ci0
ad9a a ci1
ada3 a ci3
adb6 a ci5
adad a ci6
a144 a def
007f v del
a77c a abs
a3cf a asc
ace2 a bin
a42a a mid
001b v esc
9f66 a dim
a10e a fre
a3e0 a chr
a3c0 a len
994b a brk
a60b a log
abab a tan
aacf a rnd
ab44 a cos
abc0 a atn
a493 a inp
a766 a sgn
a45a a val
ab4a a sin
a82a a int
ac4f a hex
aa3e a exp
984c a for
9ab6 a let
9aa1 a rem
ac11 a cls
a13c a pos
95b9 a new
00a7 v zfn
a24e a prs
a9f0 a sqr
9a3f a run
a6ab a div
a1d8 a str
b048 v usr
00b2 v zor
00a6 v zto
9ebe a por
add9 a one
a3f6 a mid1
ace8 a bin2
b04f v div1
b053 v div2
b057 v div3
b05a v div4
a478 a val1
a485 a val3
a482 a val2
ab0b a rnd1
ab27 a rnd2
ab7a a sin1
abdd a atn1
ac6a a hex2
ac68 a hex1
ac78 a hex3
9ee1 a por1
ac7a a hex4
a251 a prs1
a1de a str1
ac90 a add30
ac2d a deek
9a9f a data
a8d8 a padd
9c60 a read
a9d5 a half
b05c v seed
9100 a cold
ac38 a doke
9ebf a pand
a4e7 a peek
9b3c a ifgo
9952 a pend
9d87 a eval
a171 a dofn
9c0d a redo
a3f0 a left
99d4 a atoh
a69f a div10
ac0c a aret
a4ee a poke
0008 v bksp
0080 v zend
00a5 v ztab
9b1f a ongo
9118 a init
a4a5 a wait
997e a cont
9103 a warm
addd a bite
9a5c a goto
a50c a psub
9120 a copy
b099 v pset
9991 a null
97c1 a list
9d2a a next
008e v zrem
0081 v zfor
b0f2 v type
00a8 v zspc
00a4 v znew
00af v zdiv
9950 a stop
00b3 v zgtr
a49f a pout
00b5 v zlth
00b6 v zsgn
00aa v znot
a64a a mult
9786 a outc
aca0 a add301
adcf a rrot
9d8a a eval1
9d93 a eval2
9d96 a eval3
9d2d a next1
a5ec a shrt1
a8bb a addig
a66e a mult8
a511 a fpadd
0009 v dhalf
91ad a bfree
99f9 a clear
96c1 a dodel
95f8 a doagn
9be3 a dotab
a5d6 a scale
95df a clreg
b125 v fnarg
9689 a match
9d1f a fandt
94b6 a dderr
99cf a fcerr
b12e v pbuff
b129 v fpreg
99ba a deint
b0ab v stack
0083 v zdata
0003 v ctrlc
96ec a kilin
a283 a popaf
ac1e a lines
0007 v ctrlg
94b3 a nferr
a420 a right
9445 a inmsg
9a4b a gosub
ac16 a width
944a a okmsg
b09c v reset
000f v ctrlo
b12c v fpexp
0011 v ctrlq
0012 v ctrlr
0013 v ctrls
9135 a msize
0015 v ctrlu
b096 v point
9148 a mloop
94ad a snerr
b086 v nulls
9236 a words
9c31 a input
9b52 a print
00a9 v zthen
0088 v zgoto
00cf v zleft
a9f9 a power
00ab v zstep
9479 a movup
947f a movlp
94a2 a omerr
94c1 a error
94b0 a dzerr
94b9 a uferr
94bc a overr
00ac v zplus
94bf a tmerr
94e1 a errin
9a75 a ulerr
9581 a ptrlp
9678 a nospc
96e9 a otkln
9767 a outit
9820 a count
98ec a ifjmp
98ed a onjmp
993f a stall
996d a nolin
a7ff a fpint
99d5 a getln
a7b2 a dethl4
a7af a fpthl
9bcc a docom
a20c a crtst
9bc1 a nullp
9bfb a aspcs
9bf6 a dospc
9bff a spclp
a20d a qtstr
9d06 a fdtlp
a210 a dtstr
9cda a mordt
9cf5 a extig
9dfe a oprnd
9da3 a rltlp
9e54 a minus
9f46 a evnot
9e9d a fnval
9efa a cmplg1
9f87 a svnam2
97ed a lstlp2
97f0 a lstlp3
9fdb a fnthr
a7a3 a bcdefp
96d5 a echdel
a798 a fpbcde
a083 a bserr
a843 a mldebc
b112 v readfg
a291 a garbge
a13f a passa
a762 a flgdif
a502 a addphl
91fe a fnctab
958d a fndend
9775 a cpdehl
9c20 a badinp
b0f3 v datflg
9470 a indfnd
9505 a getcmd
96b8 a endbuf
9655 a search
93de a initab
b092 v brkflg
b119 v contad
b0a6 v buffer
b088 v comman
b0f1 v lcrflg
b091 v nmiflg
b08b v linesc
b08a v ctlofg
b0a1 v lineat
b10e v datlin
b110 v forflg
b113 v brklin
b11d v varend
b11f v arrend
a130 a abpass
943e a initbe
b089 v nulflg
b08d v linesn
b11b v prognd
b08f v chksum
b087 v lwidth
b111 v lstbin
b117 v errlin
b123 v fnrgnm
9106 a startb
b083 v inpsub
b12d v sgnres
b0f4 v lstram
b121 v nxtdat
b13b v mulval
b0a3 v bastxt
b07f v lstrnd
9111 a cstart
91f3 a memmsg
b045 v wrkspc
b04e v divsup
b084 v inport
b0f0 v curpos
b108 v strbot
b09f v strspc
b10a v curopr
b10c v loopst
b04b v outsub
b093 v rinput
b0f8 v tmstpl
b13e v progst
b1a2 v stlook
91a4 a warmst
b04c v otport
ad51 a initst
b104 v tmpstr
b115 v nxtopr
b0f6 v tmstpt
95fc a prompt
9905 a getchr
915a a tstmem
916c a settop
95ba a clrptr
91bc a signon
a8f1 a prnthl
91a7 a brkret
94f8 a prntok
9355 a wordtb
9915 a restor
9a7a a return
ad4e a monitr
008c v zgosub
009e v zprint
00ad v zminus
00ae v ztimes
00b4 v zequal
00c7 v zpoint
939f a pritab
93b4 a errors
96f2 a ttylin
943e a errmsg
9449 v zerbyt
9450 a brkmsg
9456 a bakstk
945a a lokfor
9493 a enfmem
947c a movstr
948a a chkstk
94a7 a datsnr
9ba3 a sttlin
a8e9 a linein
94f7 a popnok
96f2 a getlin
9609 a crunch
98e5 a excute
9599 a srchln
953e a linfnd
9555 a inewln
9546 a sftprg
957c a setptr
9574 a movbuf
95c5 a runfst
959c a srchlp
95c9 a intvar
9612 a crnclp
9691 a movdir
96b1 a cpylit
963c a fndwrd
968d a retnad
9657 a getnxt
9667 a nxtbyt
9681 a nochng
969f a setlit
96a2 a tstrem
96a8 a nxtchr
96fb a morinp
96e1 a delchr
97b0 a clotst
9714 a proces
9758 a putctl
9bab a endinp
9753 a putbuf
ad62 a outncr
976d a outnbs
977b a chksyn
97aa a dinpos
97a6 a inclen
ad4b a monout
ac0d a getinp
9817 a setlin
97cd a listlp
9930 a tstbrk
97ff a fndtok
9809 a outwrd
9843 a rslnbk
9860 a forslp
987c a forfnd
9d78 a tstnum
9d75 a getnum
98b8 a savstp
a757 a tstsgn
98c1 a putfid
98c5 a runcnt
995a a endprg
992a a restnl
992b a updata
9957 a inpbrk
a4d6 a getint
9999 a accsum
99a6 a chkltr
99ae a fpsint
99b1 a posint
99b4 a depint
a7d2 a cmpnum
99d8 a gtlnlp
9a1c a stored
9a5b a runlin
9a99 a retlin
9a9e a nxtdta
9aa5 a nxtstl
9aa8 a nxtstt
9f6b a getvar
9d7a a chktyp
9b09 a letnum
9ad1 a letstr
9af8 a crestr
9b00 a mvstpt
a3af a baktmp
a1e8 a savstr
9b20 a ongolp
9b4e a mrprnt
9b55 a prntlp
9c06 a nexitm
9b9c a prntst
a8fc a numasc
9b98 a prntnb
9bba a donull
9bda a zonelp
a4d3 a fndnum
a1b9 a idtest
9c4b a nopmpt
9c65 a nxtitm
9c71 a gtvlus
9c6d a nedmor
9c99 a antvlu
9cc3 a inpbin
9cb7 a strent
9cb4 a itmsep
9cce a ltstnd
a85e a asctfp
a795 a phltfp
a7a6 a loadfp
9d65 a kilfor
9d79 a tststr
9d83 a opnpar
9dbf a foprnd
9ee6 a tstred
a344 a concat
9de7 a stkths
a788 a stakfp
9e65 a convar
9e29 a notamp
aca4 a hextfp
ad14 a bintfp
9e76 a fnofst
9e4c a evlpar
a780 a invsgn
9e60 a retnum
9e68 a frmevl
9ea5 a gofunc
9eae a sgnexp
a12f a acpass
9ef8 a cmplog
9f3c a cmpres
a391 a gstrcu
a395 a gstrde
9f24 a cmpstr
a769 a flgrel
9f5d a dimret
9f70 a gtfnam
9f94 a charty
9f88 a endnam
9fa3 a notstr
a050 a arldsv
9fb3 a nscfor
a028 a sbscpt
a698 a pophrt
9fcd a fndvar
9fe6 a cfeval
a01a a retadr
a01d a retnul
a00c a zerolp
a02e a scptlp
a056 a fndary
a088 a creary
a06a a nxtary
a0e6 a findel
a0a3 a crarlp
a0ab a defsiz
a0c9 a zerary
a10a a enddim
a0eb a fndelp
a12a a frenum
a76e a retint
a1c7 a chekfn
a206 a svstad
a3ec a topool
a267 a testr
9bb0 a prntcrlf
a200 a crtmst
a384 a tostra
a1fd a mktmst
a213 a qtstlp
a222 a crtste
a22e a tstopl
a24d a prnums
a258 a prslp
a269 a grbdon
a285 a testos
a294 a garblp
a2a2 a grblp
a2f6 a stpool
a2b3 a smpvar
a2c9 a arrlp
a2f9 a stradd
a2c8 a gnxary
a31f a scnend
a2e8 a grbary
a394 a gstrhl
a37b a sstsa
a385 a tsalp
a38e a getstr
a3ad a pophl
a3c4 a getlen
a3d3 a gtflnm
a4d9 a makint
a489 a lfrgnm
a3f4 a right1
a3fe a allfol
a48e a midnum
a443 a rststr
a577 a reszer
a4c3 a setio
a4b9 a noxor
a4ba a waitlp
a4ff a round
a508 a subphl
a50e a subcde
a52b a noswap
a7bd a signs
a551 a mincde
a5b6 a plucde
a597 a rondup
a55f a conpos
a5c2 a compl
a562 a bnorm
a565 a bnrmlp
a584 a pnorm
a578 a savexp
a57c a normal
a598 a rondb
a5a9 a fprond
a5d8 a scallp
a5e5 a shrite
a5e8 a shrlp
a5fa a unity
a5fe a logtab
a6ad a dvbcde
aa9f a sumser
a8d2 a rscale
a643 a mulln2
a64c a fpmult
a715 a addexp
a69a a bytsft
a677 a mul8lp
a688 a nomadd
a6d2 a divlp
a6e5 a resdiv
a739 a ovtst3
a738 a ovtst2
a733 a ovtst1
a740 a mlsp10
a760 a retrel
a7ad a inchl
a7b4 a dethlb
a7ec a cmpfp
a823 a dcbcde
a84b a mldblp
a859 a nomlad
a86a a cnvnum
a872 a manlp
a896 a dpoint
a89a a conexp
a888 a explp
ad8f a umon_getc
a8dd a edigit
a89d a scalmi
a8b3 a scalpl
a8a9 a endcon
a8b4 a multen
a90a a spcfst
a9c0 a jstzer
a9c6 a rngtst
a919 a sixdig
a937 a inrng
a92e a gtsixd
a953 a maknum
a9d9 a powers
a964 a digtxt
a973 a tryagn
a9a4 a doebit
a998 a suptlz
a9c3 a noened
a9b4 a outexp
a9b6 a expten
a9eb a negaft
aa09 a power1
aa26 a power2
aa7e a exptab
aaae a smser1
aab7 a sumlp
ab30 a reseed
ab38 a rndtab
ab8e a halfpi
ab92 a quartr
ab96 a sintab
abe7 a atntab
ac87 a byt2asc
acbd a gethex
acdd a hxerr
acb5 a hexlp1
acb0 a hexlp
acd4 a hexit
acd0 a nosub7
acee a zerosup
acfc a bitout
ad00 a bitout2
ad31 a chkbin
ad3f a binerr
ad1e a binit
ad44 a jjump1
adbb a umon_putc
ad59 a aretn
ad5b a tstbit
0000 v led_port
0080 v data_bit
0016 v dfull
ad68 a bitdly
ad6a a dilly
ad74 a halfdly
ad76 a dally
ad8d a nobrk
ad85 a isbrk
ad7f a umon_chkbrk
0080 v serial_port
