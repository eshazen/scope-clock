binary-debuggable-source
0000 0000 f umon_8100H.asm
0000 0000 s ;;;
0000 0000 s ;;; simple Z80 monitor
0000 0000 s ;;;
0000 0000 s ;;; d <addr> <count>           dump memory
0000 0000 s ;;; e <addr> <dd> <dd>...      edit up to 16 bytes in memory
0000 0000 s ;;; o <port> <val>             output <val> to <port>
0000 0000 s ;;; z <val>		       set port zero value bits 0-6
0000 0000 s ;;; i <port>                   input from <port> and display
0000 0000 s ;;; g <addr>                   goto addr
0000 0000 s ;;; b <addr>                   set breakpoint (currently 3-byte call)
0000 0000 s ;;; a <val1> <val2>            hex Arithmetic
0000 0000 s ;;; f <addr>                   dump HP registers from <addr> (A)
0000 0000 s ;;; c                          continue from breakpoint
0000 0000 s ;;; c <addr>                   continue, set new breakpoint
0000 0000 s ;;; m <start> <end> <size>     memory region compare
0000 0000 s ;;; p <start> <end> <size>     memory region copy
0000 0000 s ;;; l			       binary load
0000 0000 s ;;; r			       repeat last command
0000 0000 s ;;; calculator hardware
0000 0000 s ;;; k                          scan keyboard
0000 0000 s ;;; 7 <addr>		       update 7-segment display from <addr>
0000 0000 s ;;; V <addr>                   update VFD display from <addr>
0000 0000 s 
0000 0000 s 
0000 0000 s ; 	org	08100H
8100 8100 s  	org	8100H	
8100 8100 s 
8100 8100 s stak:	equ	$		;stack grows down from start
8100 8100 s 
8100 8100 s ;;; jump table for useful entry points
8100 8100 d c30488
8100 8100 s 	jmp	main		;0000  cold start
8103 8103 d c3308b
8103 8103 s 	jmp	savestate	;0003  save state (breakpoint)
8106 8106 d c32582
8106 8106 s 	jmp	getc		;0006  read serial input to A
8109 8109 d c34f82
8109 8109 s 	jmp	putc		;0009  output serial from A
810c 810c d c39482
810c 810c s 	jmp	crlf		;000c  output CR/LF
810f 810f d c39d82
810f 810f s 	jmp	puts		;000f  output string from HL
8112 8112 d c30583
8112 8112 s 	jmp	phex2		;0012  output hex byte from A
8115 8115 d c31683
8115 8115 s 	jmp	phex4		;0015  output hex word from HL
8118 8118 s 
8118 8118 s ;;; ---- data area ----
8118 8118 s 
8118 8118 s ;;; save CPU state coming from extrnal prog
8118 8118 d 000000
8118 8118 s savein:	db	0,0,0		;instruction overwritten by breakpoint
811b 811b d 0000
811b 811b s savead:	dw	0		;address of breakpoint
811d 811d d 0000
811d 811d s savsp:	dw	0		;caller's stack pointer
811f 811f s 
811f 811f s ;;; saved registers
811f 811f d 0000
811f 811f s saviy:	dw	0
8121 8121 d 0000
8121 8121 s savix:	dw	0
8123 8123 s 
8123 8123 d 0000
8123 8123 s savhlp:	dw	0
8125 8125 d 0000
8125 8125 s savdep:	dw	0
8127 8127 d 0000
8127 8127 s savbcp:	dw	0
8129 8129 d 0000
8129 8129 s savafp:	dw	0
812b 812b s 	
812b 812b d 0000
812b 812b s savhl:	dw	0
812d 812d d 0000
812d 812d s savde:	dw	0
812f 812f d 0000
812f 812f s savbc:	dw	0
8131 8131 d 0000
8131 8131 s savaf:	dw	0
8133 8133 s 	
8133 8133 s savetop: equ	$
8133 8133 s 	
8133 8133 d 484c00444500424300414600
8133 8133 s regnam:	db	'HL', 0, 'DE', 0, 'BC', 0, 'AF', 0
813f 813f s 
813f 813f d 00
813f 813f s pzero:	db	0		;port 0 value bits 0-6
8140 8140 d 00
8140 8140 s lastc:	db	0		;last command byte
8141 8141 s 
8141 8141 s buff:	rept	60
8141 8141 s 	db	0
8141 8141 s 	endm
8141 8141 d 00
8141 8141 s 	db	0
8142 8142 s 	endm
8142 8142 d 00
8142 8142 s 	db	0
8143 8143 s 	endm
8143 8143 d 00
8143 8143 s 	db	0
8144 8144 s 	endm
8144 8144 d 00
8144 8144 s 	db	0
8145 8145 s 	endm
8145 8145 d 00
8145 8145 s 	db	0
8146 8146 s 	endm
8146 8146 d 00
8146 8146 s 	db	0
8147 8147 s 	endm
8147 8147 d 00
8147 8147 s 	db	0
8148 8148 s 	endm
8148 8148 d 00
8148 8148 s 	db	0
8149 8149 s 	endm
8149 8149 d 00
8149 8149 s 	db	0
814a 814a s 	endm
814a 814a d 00
814a 814a s 	db	0
814b 814b s 	endm
814b 814b d 00
814b 814b s 	db	0
814c 814c s 	endm
814c 814c d 00
814c 814c s 	db	0
814d 814d s 	endm
814d 814d d 00
814d 814d s 	db	0
814e 814e s 	endm
814e 814e d 00
814e 814e s 	db	0
814f 814f s 	endm
814f 814f d 00
814f 814f s 	db	0
8150 8150 s 	endm
8150 8150 d 00
8150 8150 s 	db	0
8151 8151 s 	endm
8151 8151 d 00
8151 8151 s 	db	0
8152 8152 s 	endm
8152 8152 d 00
8152 8152 s 	db	0
8153 8153 s 	endm
8153 8153 d 00
8153 8153 s 	db	0
8154 8154 s 	endm
8154 8154 d 00
8154 8154 s 	db	0
8155 8155 s 	endm
8155 8155 d 00
8155 8155 s 	db	0
8156 8156 s 	endm
8156 8156 d 00
8156 8156 s 	db	0
8157 8157 s 	endm
8157 8157 d 00
8157 8157 s 	db	0
8158 8158 s 	endm
8158 8158 d 00
8158 8158 s 	db	0
8159 8159 s 	endm
8159 8159 d 00
8159 8159 s 	db	0
815a 815a s 	endm
815a 815a d 00
815a 815a s 	db	0
815b 815b s 	endm
815b 815b d 00
815b 815b s 	db	0
815c 815c s 	endm
815c 815c d 00
815c 815c s 	db	0
815d 815d s 	endm
815d 815d d 00
815d 815d s 	db	0
815e 815e s 	endm
815e 815e d 00
815e 815e s 	db	0
815f 815f s 	endm
815f 815f d 00
815f 815f s 	db	0
8160 8160 s 	endm
8160 8160 d 00
8160 8160 s 	db	0
8161 8161 s 	endm
8161 8161 d 00
8161 8161 s 	db	0
8162 8162 s 	endm
8162 8162 d 00
8162 8162 s 	db	0
8163 8163 s 	endm
8163 8163 d 00
8163 8163 s 	db	0
8164 8164 s 	endm
8164 8164 d 00
8164 8164 s 	db	0
8165 8165 s 	endm
8165 8165 d 00
8165 8165 s 	db	0
8166 8166 s 	endm
8166 8166 d 00
8166 8166 s 	db	0
8167 8167 s 	endm
8167 8167 d 00
8167 8167 s 	db	0
8168 8168 s 	endm
8168 8168 d 00
8168 8168 s 	db	0
8169 8169 s 	endm
8169 8169 d 00
8169 8169 s 	db	0
816a 816a s 	endm
816a 816a d 00
816a 816a s 	db	0
816b 816b s 	endm
816b 816b d 00
816b 816b s 	db	0
816c 816c s 	endm
816c 816c d 00
816c 816c s 	db	0
816d 816d s 	endm
816d 816d d 00
816d 816d s 	db	0
816e 816e s 	endm
816e 816e d 00
816e 816e s 	db	0
816f 816f s 	endm
816f 816f d 00
816f 816f s 	db	0
8170 8170 s 	endm
8170 8170 d 00
8170 8170 s 	db	0
8171 8171 s 	endm
8171 8171 d 00
8171 8171 s 	db	0
8172 8172 s 	endm
8172 8172 d 00
8172 8172 s 	db	0
8173 8173 s 	endm
8173 8173 d 00
8173 8173 s 	db	0
8174 8174 s 	endm
8174 8174 d 00
8174 8174 s 	db	0
8175 8175 s 	endm
8175 8175 d 00
8175 8175 s 	db	0
8176 8176 s 	endm
8176 8176 d 00
8176 8176 s 	db	0
8177 8177 s 	endm
8177 8177 d 00
8177 8177 s 	db	0
8178 8178 s 	endm
8178 8178 d 00
8178 8178 s 	db	0
8179 8179 s 	endm
8179 8179 d 00
8179 8179 s 	db	0
817a 817a s 	endm
817a 817a d 00
817a 817a s 	db	0
817b 817b s 	endm
817b 817b d 00
817b 817b s 	db	0
817c 817c s 	endm
817c 817c d 00
817c 817c s 	db	0
817d 817d s 	endm
817d 817d s 
817d 817d s bend:	equ	$		;mark the end
817d 817d s 
817d 817d s maxarg:	equ	18		;maximum number of arguments
817d 817d d 00
817d 817d s argc:	db	0
817e 817e s 	
817e 817e s argv:	rept	maxarg*2
817e 817e s 	dw	0
817e 817e s 	endm
817e 817e d 0000
817e 817e s 	dw	0
8180 8180 s 	endm
8180 8180 d 0000
8180 8180 s 	dw	0
8182 8182 s 	endm
8182 8182 d 0000
8182 8182 s 	dw	0
8184 8184 s 	endm
8184 8184 d 0000
8184 8184 s 	dw	0
8186 8186 s 	endm
8186 8186 d 0000
8186 8186 s 	dw	0
8188 8188 s 	endm
8188 8188 d 0000
8188 8188 s 	dw	0
818a 818a s 	endm
818a 818a d 0000
818a 818a s 	dw	0
818c 818c s 	endm
818c 818c d 0000
818c 818c s 	dw	0
818e 818e s 	endm
818e 818e d 0000
818e 818e s 	dw	0
8190 8190 s 	endm
8190 8190 d 0000
8190 8190 s 	dw	0
8192 8192 s 	endm
8192 8192 d 0000
8192 8192 s 	dw	0
8194 8194 s 	endm
8194 8194 d 0000
8194 8194 s 	dw	0
8196 8196 s 	endm
8196 8196 d 0000
8196 8196 s 	dw	0
8198 8198 s 	endm
8198 8198 d 0000
8198 8198 s 	dw	0
819a 819a s 	endm
819a 819a d 0000
819a 819a s 	dw	0
819c 819c s 	endm
819c 819c d 0000
819c 819c s 	dw	0
819e 819e s 	endm
819e 819e d 0000
819e 819e s 	dw	0
81a0 81a0 s 	endm
81a0 81a0 d 0000
81a0 81a0 s 	dw	0
81a2 81a2 s 	endm
81a2 81a2 d 0000
81a2 81a2 s 	dw	0
81a4 81a4 s 	endm
81a4 81a4 d 0000
81a4 81a4 s 	dw	0
81a6 81a6 s 	endm
81a6 81a6 d 0000
81a6 81a6 s 	dw	0
81a8 81a8 s 	endm
81a8 81a8 d 0000
81a8 81a8 s 	dw	0
81aa 81aa s 	endm
81aa 81aa d 0000
81aa 81aa s 	dw	0
81ac 81ac s 	endm
81ac 81ac d 0000
81ac 81ac s 	dw	0
81ae 81ae s 	endm
81ae 81ae d 0000
81ae 81ae s 	dw	0
81b0 81b0 s 	endm
81b0 81b0 d 0000
81b0 81b0 s 	dw	0
81b2 81b2 s 	endm
81b2 81b2 d 0000
81b2 81b2 s 	dw	0
81b4 81b4 s 	endm
81b4 81b4 d 0000
81b4 81b4 s 	dw	0
81b6 81b6 s 	endm
81b6 81b6 d 0000
81b6 81b6 s 	dw	0
81b8 81b8 s 	endm
81b8 81b8 d 0000
81b8 81b8 s 	dw	0
81ba 81ba s 	endm
81ba 81ba d 0000
81ba 81ba s 	dw	0
81bc 81bc s 	endm
81bc 81bc d 0000
81bc 81bc s 	dw	0
81be 81be s 	endm
81be 81be d 0000
81be 81be s 	dw	0
81c0 81c0 s 	endm
81c0 81c0 d 0000
81c0 81c0 s 	dw	0
81c2 81c2 s 	endm
81c2 81c2 d 0000
81c2 81c2 s 	dw	0
81c4 81c4 s 	endm
81c4 81c4 d 0000
81c4 81c4 s 	dw	0
81c6 81c6 s 	endm
81c6 81c6 s 	
81c6 81c6 s iargv:	rept	maxarg*2
81c6 81c6 s 	dw	0
81c6 81c6 s 	endm
81c6 81c6 d 0000
81c6 81c6 s 	dw	0
81c8 81c8 s 	endm
81c8 81c8 d 0000
81c8 81c8 s 	dw	0
81ca 81ca s 	endm
81ca 81ca d 0000
81ca 81ca s 	dw	0
81cc 81cc s 	endm
81cc 81cc d 0000
81cc 81cc s 	dw	0
81ce 81ce s 	endm
81ce 81ce d 0000
81ce 81ce s 	dw	0
81d0 81d0 s 	endm
81d0 81d0 d 0000
81d0 81d0 s 	dw	0
81d2 81d2 s 	endm
81d2 81d2 d 0000
81d2 81d2 s 	dw	0
81d4 81d4 s 	endm
81d4 81d4 d 0000
81d4 81d4 s 	dw	0
81d6 81d6 s 	endm
81d6 81d6 d 0000
81d6 81d6 s 	dw	0
81d8 81d8 s 	endm
81d8 81d8 d 0000
81d8 81d8 s 	dw	0
81da 81da s 	endm
81da 81da d 0000
81da 81da s 	dw	0
81dc 81dc s 	endm
81dc 81dc d 0000
81dc 81dc s 	dw	0
81de 81de s 	endm
81de 81de d 0000
81de 81de s 	dw	0
81e0 81e0 s 	endm
81e0 81e0 d 0000
81e0 81e0 s 	dw	0
81e2 81e2 s 	endm
81e2 81e2 d 0000
81e2 81e2 s 	dw	0
81e4 81e4 s 	endm
81e4 81e4 d 0000
81e4 81e4 s 	dw	0
81e6 81e6 s 	endm
81e6 81e6 d 0000
81e6 81e6 s 	dw	0
81e8 81e8 s 	endm
81e8 81e8 d 0000
81e8 81e8 s 	dw	0
81ea 81ea s 	endm
81ea 81ea d 0000
81ea 81ea s 	dw	0
81ec 81ec s 	endm
81ec 81ec d 0000
81ec 81ec s 	dw	0
81ee 81ee s 	endm
81ee 81ee d 0000
81ee 81ee s 	dw	0
81f0 81f0 s 	endm
81f0 81f0 d 0000
81f0 81f0 s 	dw	0
81f2 81f2 s 	endm
81f2 81f2 d 0000
81f2 81f2 s 	dw	0
81f4 81f4 s 	endm
81f4 81f4 d 0000
81f4 81f4 s 	dw	0
81f6 81f6 s 	endm
81f6 81f6 d 0000
81f6 81f6 s 	dw	0
81f8 81f8 s 	endm
81f8 81f8 d 0000
81f8 81f8 s 	dw	0
81fa 81fa s 	endm
81fa 81fa d 0000
81fa 81fa s 	dw	0
81fc 81fc s 	endm
81fc 81fc d 0000
81fc 81fc s 	dw	0
81fe 81fe s 	endm
81fe 81fe d 0000
81fe 81fe s 	dw	0
8200 8200 s 	endm
8200 8200 d 0000
8200 8200 s 	dw	0
8202 8202 s 	endm
8202 8202 d 0000
8202 8202 s 	dw	0
8204 8204 s 	endm
8204 8204 d 0000
8204 8204 s 	dw	0
8206 8206 s 	endm
8206 8206 d 0000
8206 8206 s 	dw	0
8208 8208 s 	endm
8208 8208 d 0000
8208 8208 s 	dw	0
820a 820a s 	endm
820a 820a d 0000
820a 820a s 	dw	0
820c 820c s 	endm
820c 820c d 0000
820c 820c s 	dw	0
820e 820e s 	endm
820e 820e s 
820e 820e s ;	INCLUDE "s1200.asm"	
820e 820e s 	INCLUDE "s19200.asm"	
820e 820e f s19200.asm
820e 820e s ;;; ------------------------------------------------------------------------
820e 820e s ;;; serial port
820e 820e s ;;; putc:  send a character from A
820e 820e s ;;; getc:  receive a character to A
820e 820e s ;;; ------------------------------------------------------------------------
820e 820e s 
820e 820e s 
820e 820e s serial_port:	equ	80H	;input port
820e 820e s led_port:	equ	0	;port 0 for LED/keyboard output
820e 820e s 	
820e 820e s data_bit:	equ	80H	;input data mask
820e 820e s 	
820e 820e s ;;; serial port timing macros
820e 820e s ;;; 23/10 seem to be OK for 4800 baud (4MHz CPU) or 19200 (16MHz CPU)
820e 820e s 
820e 820e s ;;; UGH - z80asm doesn't support macros
820e 820e s 
820e 820e s full:	equ	22
820e 820e s half:	equ	9
820e 820e s 
820e 820e s                                 ;27T (call+ret)
820e 820e d 0616
820e 820e s bitdly:	ld	b,full          ;7T
8210 8210 d 00
8210 8210 s dilly:	nop			;4T
8211 8211 d 00
8211 8211 s 	nop			;4T
8212 8212 d 00
8212 8212 s 	nop			;4T
8213 8213 d 00
8213 8213 s 	nop			;4T
8214 8214 d 00
8214 8214 s 	nop			;4T
8215 8215 d 10f9
8215 8215 s 	djnz	dilly		;13T / 8T
8217 8217 d 00
8217 8217 s 	nop			;4T
8218 8218 d 00
8218 8218 s 	nop			;4T
8219 8219 d c9
8219 8219 s 	ret
821a 821a s 
821a 821a s ;;; old version was 332T
821a 821a s ;;; this one is 330T
821a 821a s                                 ;27T (call+ret)
821a 821a d 0609
821a 821a s halfdly: ld	b,half		;7T
821c 821c d 00
821c 821c s dally:	nop			;4T
821d 821d d 00
821d 821d s 	nop			;4T
821e 821e d 00
821e 821e s 	nop			;4T
821f 821f d 00
821f 821f s 	nop			;4T
8220 8220 d 00
8220 8220 s 	nop			;4T
8221 8221 d 10f9
8221 8221 s 	djnz	dally		;13T / 8T
8223 8223 d 00
8223 8223 s 	nop			;4T
8224 8224 d c9
8224 8224 s 	ret
8225 8225 s 
8225 8225 s ;;; 
8225 8225 s ;;; receive a character to A
8225 8225 s ;;; 
8225 8225 s getc:	
8225 8225 d c5
8225 8225 s 	push	bc
8226 8226 d d5
8226 8226 s 	push	de
8227 8227 s 	
8227 8227 d 1e09
8227 8227 s 	ld	e,9		; bit count (start + 8 data)
8229 8229 s 	
8229 8229 s 	;; wait for high
8229 8229 d db80
8229 8229 s ci0:	in	a,(serial_port)
822b 822b d e680
822b 822b s 	and	data_bit
822d 822d d 28fa
822d 822d s 	jr	z,ci0		;loop if/while low
822f 822f s 	
822f 822f d db80
822f 822f s ci1:	in	a,(serial_port) ; read serial line
8231 8231 d e680
8231 8231 s 	and	data_bit	; isolate serial bit
8233 8233 d 20fa
8233 8233 s 	jr	nz,ci1		; loop while high
8235 8235 d cd1a82
8235 8235 s 	call 	halfdly		;delay to middle of first (start) bit
8238 8238 s 
8238 8238 s ci3:
8238 8238 d cd0e82
8238 8238 s 	call	bitdly	       ;delay to middle of LSB data bit    766
823b 823b d db80
823b 823b s 	in	a,(serial_port) ; read serial character              12
823d 823d d e680
823d 823d s 	and	data_bit	; isolate serial data                 7
823f 823f d 2801
823f 823f s 	jr	z,ci6		; j if data is 0                  7 / 12
8241 8241 d 3c
8241 8241 s 	inc	a		; now register A=serial data          4
8242 8242 d 1f
8242 8242 s ci6:	rra			; rotate it into carry                4
8243 8243 d 1d
8243 8243 s 	dec	e		; dec bit count                       4
8244 8244 d 2805
8244 8244 s 	jr	z,ci5		; j if last bit                   7 / 12
8246 8246 s 	
8246 8246 d 79
8246 8246 s 	ld	a,c		; this is where we assemble char      4
8247 8247 d 1f
8247 8247 s 	rra			; rotate it into the character from c 4
8248 8248 d 4f
8248 8248 s 	ld	c,a		;                                     4
8249 8249 s 
8249 8249 d 18ed
8249 8249 s 	jr	ci3		; do next bit                        12
824b 824b s 	
824b 824b s 	;; total loop ~ 836T = 52.3 uS or 19139 Hz (0.3% error, not bad!)
824b 824b s 
824b 824b d 79
824b 824b s ci5:	ld	a,c
824c 824c s 
824c 824c d d1
824c 824c s 	pop	de
824d 824d d c1
824d 824d s 	pop	bc
824e 824e s 
824e 824e d c9
824e 824e s 	ret
824f 824f s 
824f 824f s ;;;
824f 824f s ;;; send character in A
824f 824f s ;;; saves all
824f 824f s ;;; 
824f 824f s putc:
824f 824f d c5
824f 824f s 	push	bc
8250 8250 d d5
8250 8250 s 	push	de
8251 8251 d f5
8251 8251 s 	push	af
8252 8252 s 
8252 8252 d 4f
8252 8252 s 	ld	c,a
8253 8253 s 
8253 8253 d 1e08
8253 8253 s 	ld	e,8		;bit counter
8255 8255 s 	
8255 8255 s ;	mark			;ensure a stop bit
8255 8255 d 3e80
8255 8255 s 	ld	a,data_bit
8257 8257 d d300
8257 8257 s 	out	(led_port),a
8259 8259 d cd0e82
8259 8259 s 	call	bitdly
825c 825c s 	
825c 825c s ;	spc			;start bit
825c 825c d 3e00
825c 825c s 	ld	a,0
825e 825e d d300
825e 825e s 	out	(led_port),a
8260 8260 d cd0e82
8260 8260 s 	call	bitdly
8263 8263 s 	
8263 8263 s 	;; loop here for bits
8263 8263 d cb19
8263 8263 s rrot:	rr	c		;shift out LSB
8265 8265 d 3806
8265 8265 s 	jr	c,one
8267 8267 s 	
8267 8267 s ;	spc
8267 8267 d 3e00
8267 8267 s 	ld	a,0
8269 8269 d d300
8269 8269 s 	out	(led_port),a
826b 826b d 1804
826b 826b s 	jr	biter
826d 826d s one:
826d 826d s ;	mark
826d 826d d 3e80
826d 826d s 	ld	a,data_bit
826f 826f d d300
826f 826f s 	out	(led_port),a
8271 8271 s biter:
8271 8271 d cd0e82
8271 8271 s 	call	bitdly
8274 8274 s 	
8274 8274 d 1d
8274 8274 s 	dec	e
8275 8275 d 20ec
8275 8275 s 	jr	nz,rrot
8277 8277 s ;	mark
8277 8277 d 3e80
8277 8277 s 	ld	a,data_bit
8279 8279 d d300
8279 8279 s 	out	(led_port),a
827b 827b d cd0e82
827b 827b s 	call	bitdly		; stop bit
827e 827e s 	
827e 827e d f1
827e 827e s 	pop	af
827f 827f d d1
827f 827f s 	pop	de
8280 8280 d c1
8280 8280 s 	pop	bc
8281 8281 d c9
8281 8281 s 	ret
8282 8282 s 
8282 8282 s ;;; function to update port zero, keep serial line marking
8282 8282 s ;;; (use to output port 0 when serial line is idle)
8282 8282 s updpzero:
8282 8282 d 3e80
8282 8282 s 	ld	a,data_bit
8284 8284 d d300
8284 8284 s 	out	(led_port),a
8286 8286 s ;	mark
8286 8286 d c9
8286 8286 s 	ret
8287 8287 s 	
8287 8287 f umon_8100H.asm
8287 8287 s 	INCLUDE "console.asm"
8287 8287 f console.asm
8287 8287 s ;;; Console I/O
8287 8287 s ;;;
8287 8287 s ;;; assumes putc, getc
8287 8287 s ;;; 
8287 8287 s 
8287 8287 s ;;; convert A to uppercase
8287 8287 d fe61
8287 8287 s toupper: cp	'a'
8289 8289 d d8
8289 8289 s 	ret	c
828a 828a d fe7b
828a 828a s 	cp	'z'+1
828c 828c d d0
828c 828c s 	ret	nc
828d 828d d e65f
828d 828d s 	and	5FH
828f 828f d c9
828f 828f s 	ret
8290 8290 s 	
8290 8290 s ;;; output space
8290 8290 d 3e20
8290 8290 s space:	ld	a,' '
8292 8292 d 18bb
8292 8292 s 	jr	putc
8294 8294 s 
8294 8294 s ;;; output CR/LF
8294 8294 d 3e0d
8294 8294 s crlf:	ld	a,13
8296 8296 d cd4f82
8296 8296 s 	call 	putc
8299 8299 d 3e0a
8299 8299 s 	ld	a,10
829b 829b d 18b2
829b 829b s 	jr	putc
829d 829d s 
829d 829d s ;;; output null-terminated string from HL
829d 829d s ;;; return with HL pointing past null
829d 829d d 7e
829d 829d s puts:	ld	a,(hl)
829e 829e d 23
829e 829e s 	inc	hl
829f 829f d b7
829f 829f s 	or	a
82a0 82a0 d c8
82a0 82a0 s 	ret	z
82a1 82a1 d cd4f82
82a1 82a1 s 	call	putc
82a4 82a4 d 18f7
82a4 82a4 s 	jr	puts
82a6 82a6 s 
82a6 82a6 s ;;; read string from console to HL
82a6 82a6 s ;;; stop on CR/LF/ESC
82a6 82a6 s ;;; null-terminate the string without the terminating control char
82a6 82a6 s ;;; return the control character in A
82a6 82a6 s ;;; only accept up to BC bytes
82a6 82a6 s ;;; used:  A + 3 stack levels
82a6 82a6 s 
82a6 82a6 d d5
82a6 82a6 s gets:	push	de
82a7 82a7 d e5
82a7 82a7 s 	push	hl
82a8 82a8 d c5
82a8 82a8 s 	push	bc
82a9 82a9 s 	
82a9 82a9 d 54
82a9 82a9 s 	ld	d,h		;buffer pointer to DE for reference
82aa 82aa d 5d
82aa 82aa s 	ld	e,l
82ab 82ab s 	
82ab 82ab d 09
82ab 82ab s 	add	hl,bc		;hl now points to buffer limit
82ac 82ac s 
82ac 82ac d 44
82ac 82ac s 	ld	b,h
82ad 82ad d 4d
82ad 82ad s 	ld	c,l		;limit to BC
82ae 82ae s 	
82ae 82ae d 0b
82ae 82ae s 	dec	bc		;adjust limit to leave room for null terminator
82af 82af d 62
82af 82af s 	ld	h,d
82b0 82b0 d 6b
82b0 82b0 s 	ld	l,e		;now: HL=buff BC=limit DE=buff
82b1 82b1 s 
82b1 82b1 s gets0:	
82b1 82b1 d cd2582
82b1 82b1 s 	call	getc
82b4 82b4 d cd8782
82b4 82b4 s 	call	toupper		;force all input to uppercase for now
82b7 82b7 d fe0d
82b7 82b7 s 	cp	0dh		;check for CR
82b9 82b9 d 282f
82b9 82b9 s 	jr	z,gets1
82bb 82bb d fe0a
82bb 82bb s 	cp	0ah		;check for LF
82bd 82bd d 282b
82bd 82bd s 	jr	z,gets1
82bf 82bf d fe1b
82bf 82bf s 	cp	1bh		;check for ESC
82c1 82c1 d 2827
82c1 82c1 s 	jr	z,gets1
82c3 82c3 d fe08
82c3 82c3 s 	cp	08h		;check for BS
82c5 82c5 d 2804
82c5 82c5 s 	jr	z,gets3
82c7 82c7 d fe20
82c7 82c7 s 	cp	20h		;check for printable
82c9 82c9 d 3011
82c9 82c9 s 	jr	nc,gets2	;store only printable
82cb 82cb s 	;; handle backspace
82cb 82cb s gets3:
82cb 82cb d b7
82cb 82cb s 	or	a		;clear CY
82cc 82cc d e5
82cc 82cc s 	push	HL
82cd 82cd d ed52
82cd 82cd s 	sbc	HL,DE		;are we at the beginning?
82cf 82cf d e1
82cf 82cf s 	pop	HL
82d0 82d0 d 28df
82d0 82d0 s 	jr	z,gets0		;yes, no backspace
82d2 82d2 s 	;; perform the backspace
82d2 82d2 d 3e08
82d2 82d2 s 	ld	a,8
82d4 82d4 d cd4f82
82d4 82d4 s 	call	putc		;echo the backspace
82d7 82d7 d 3600
82d7 82d7 s 	ld	(hl),0		;null-terminate here
82d9 82d9 d 2b
82d9 82d9 s 	dec	hl
82da 82da d 18d5
82da 82da s 	jr	gets0
82dc 82dc s 
82dc 82dc s 	;; try to store a printable char
82dc 82dc s gets2:	
82dc 82dc s 	;; check if at end of buffer
82dc 82dc d e5
82dc 82dc s 	push	hl
82dd 82dd d b7
82dd 82dd s 	or	a
82de 82de d ed42
82de 82de s 	sbc	hl,bc
82e0 82e0 d e1
82e0 82e0 s 	pop	hl
82e1 82e1 d 28ce
82e1 82e1 s 	jr	z,gets0
82e3 82e3 s 
82e3 82e3 d cd4f82
82e3 82e3 s 	call	putc		;echo the char
82e6 82e6 d 77
82e6 82e6 s 	ld	(hl),a		;store it
82e7 82e7 d 23
82e7 82e7 s 	inc	hl		;increment
82e8 82e8 s 	;; should really check for buffer overflow here
82e8 82e8 d 18c7
82e8 82e8 s 	jr	gets0
82ea 82ea s 	
82ea 82ea d 3600
82ea 82ea s gets1:	ld	(hl),0
82ec 82ec d f5
82ec 82ec s 	push	af
82ed 82ed d cd9482
82ed 82ed s 	call	crlf
82f0 82f0 d f1
82f0 82f0 s 	pop	af
82f1 82f1 s 
82f1 82f1 d e1
82f1 82f1 s 	pop	hl
82f2 82f2 d d1
82f2 82f2 s 	pop	de
82f3 82f3 d c1
82f3 82f3 s 	pop	bc
82f4 82f4 s 	
82f4 82f4 d c9
82f4 82f4 s 	ret
82f5 82f5 s 	
82f5 82f5 f umon_8100H.asm
82f5 82f5 s 	INCLUDE "hex.asm"
82f5 82f5 f hex.asm
82f5 82f5 s ;;; 
82f5 82f5 s ;;; hex input/output
82f5 82f5 s ;;;
82f5 82f5 s ;;; phex1    - print hex digit from A
82f5 82f5 s ;;; phex2    - print hex byte from A
82f5 82f5 s ;;; phex4    - print hex word from HL
82f5 82f5 s ;;; ihex1    - hex to binary in A, NC if valid
82f5 82f5 s 
82f5 82f5 s 
82f5 82f5 s ;;; print hex nibble from a
82f5 82f5 d f5
82f5 82f5 s phex1:	push 	af
82f6 82f6 d e60f
82f6 82f6 s 	and 	a, 0fh
82f8 82f8 d c630
82f8 82f8 s 	add	a,'0'
82fa 82fa d fe3a
82fa 82fa s 	cp	'9'+1
82fc 82fc d 3802
82fc 82fc s 	jr	c,phex1a
82fe 82fe d c607
82fe 82fe s 	add	a,'A'-'0'-10
8300 8300 d cd4f82
8300 8300 s phex1a:	call	putc
8303 8303 d f1
8303 8303 s 	pop	af
8304 8304 d c9
8304 8304 s 	ret
8305 8305 s 
8305 8305 s ;;; print hex byte from a
8305 8305 d f5
8305 8305 s phex2:	push	af
8306 8306 d c5
8306 8306 s 	push	bc
8307 8307 d 47
8307 8307 s 	ld	b,a		;save value
8308 8308 d 0f
8308 8308 s 	rrca
8309 8309 d 0f
8309 8309 s 	rrca
830a 830a d 0f
830a 830a s 	rrca
830b 830b d 0f
830b 830b s 	rrca			;get high nibble
830c 830c d cdf582
830c 830c s 	call	phex1
830f 830f d 78
830f 830f s 	ld	a,b		;get low nibble
8310 8310 d cdf582
8310 8310 s 	call	phex1
8313 8313 d c1
8313 8313 s 	pop	bc
8314 8314 d f1
8314 8314 s 	pop	af
8315 8315 d c9
8315 8315 s 	ret
8316 8316 s 
8316 8316 s ;;; print hex word from HL
8316 8316 d e5
8316 8316 s phex4:	push	hl
8317 8317 d f5
8317 8317 s 	push	af
8318 8318 d 7c
8318 8318 s 	ld	a,h
8319 8319 d cd0583
8319 8319 s 	call	phex2
831c 831c d 7d
831c 831c s 	ld	a,l
831d 831d d cd0583
831d 831d s 	call	phex2
8320 8320 d f1
8320 8320 s 	pop	af
8321 8321 d e1
8321 8321 s 	pop	hl
8322 8322 d c9
8322 8322 s 	ret
8323 8323 s 
8323 8323 s ;;; convert ASCII hex in A to binary
8323 8323 s ;;; NC if valid hex
8323 8323 s ;;; if invalid, A is modified but not valid
8323 8323 d d630
8323 8323 s ihex1:	sub	'0'		;A-'0'
8325 8325 d d8
8325 8325 s 	ret	c		;A < '0', not valid
8326 8326 d fe0a
8326 8326 s 	cp	10
8328 8328 d 3f
8328 8328 s 	ccf
8329 8329 d d0
8329 8329 s 	ret	nc		;all done if result < 10
832a 832a d d607
832a 832a s 	sub	'A'-'9'-1	;should give value 10..15
832c 832c d fe0a
832c 832c s 	cp	10
832e 832e d d8
832e 832e s 	ret	c
832f 832f d fe10
832f 832f s 	cp	16
8331 8331 d 3f
8331 8331 s 	ccf
8332 8332 d c9
8332 8332 s 	ret
8333 8333 s 
8333 8333 s ;;;;;; dump argc/argv
8333 8333 s ;;;adump:	ld	a,(argc)
8333 8333 s ;;;	ld	b,a
8333 8333 s ;;;	call	phex2
8333 8333 s ;;;	call	crlf
8333 8333 s ;;;	ld	hl,iargv
8333 8333 s ;;;	ld	a,b
8333 8333 s ;;;	or	a
8333 8333 s ;;;	ret	z
8333 8333 s ;;;	
8333 8333 s ;;;adump1:	ld	e,(hl)
8333 8333 s ;;;	inc	hl
8333 8333 s ;;;	ld	d,(hl)
8333 8333 s ;;;	inc	hl
8333 8333 s ;;;	ex	de,hl		;swap hl/de
8333 8333 s ;;;	call	phex4
8333 8333 s ;;;	ex	de,hl
8333 8333 s ;;;	call	space
8333 8333 s ;;;	djnz	adump1
8333 8333 s ;;;	call	crlf
8333 8333 s ;;;	ret
8333 8333 s 
8333 8333 s ;;; get hex from (hl) and return in A (NC if valid)
8333 8333 s ;;; increment HL past char
8333 8333 d 7e
8333 8333 s ghex1:	ld	a,(hl)
8334 8334 d 23
8334 8334 s 	inc	hl
8335 8335 d c32383
8335 8335 s 	jp	ihex1
8338 8338 s 
8338 8338 s ;;; get 2-digit hex from HL
8338 8338 s ;;; return in A, other regs preserved
8338 8338 d c5
8338 8338 s ghex2:	push	bc
8339 8339 d cd3383
8339 8339 s 	call	ghex1
833c 833c d 380d
833c 833c s 	jr	c,ghex2a
833e 833e d 07
833e 833e s 	rlca
833f 833f d 07
833f 833f s 	rlca
8340 8340 d 07
8340 8340 s 	rlca
8341 8341 d 07
8341 8341 s 	rlca
8342 8342 d e6f0
8342 8342 s 	and	0f0h
8344 8344 d 47
8344 8344 s 	ld	b,a
8345 8345 d cd3383
8345 8345 s 	call	ghex1
8348 8348 d 3801
8348 8348 s 	jr	c,ghex2a
834a 834a d b0
834a 834a s 	or	b
834b 834b d c1
834b 834b s ghex2a:	pop	bc
834c 834c d c9
834c 834c s 	ret
834d 834d s 
834d 834d s ;;; get 4-digit hex value from HL and return in DE
834d 834d d cd3883
834d 834d s ghex4:	call	ghex2
8350 8350 d d8
8350 8350 s 	ret	c
8351 8351 d 57
8351 8351 s 	ld	d,a
8352 8352 d cd3883
8352 8352 s 	call	ghex2
8355 8355 d 5f
8355 8355 s 	ld	e,a
8356 8356 d c9
8356 8356 s 	ret
8357 8357 s 
8357 8357 s ;;; parse hex value up to 4 digits at (hl)
8357 8357 s ;;; convert to binary in de
8357 8357 s ;;; return c on error, nc on valid hex
8357 8357 s ;;; advance HL to char after last hex digit
8357 8357 d 110000
8357 8357 s vhex:	ld	de,0
835a 835a d cd3383
835a 835a s vhex1:	call	ghex1
835d 835d d d8
835d 835d s 	ret	c		;not valid hex, just return with cy
835e 835e s 	
835e 835e d eb
835e 835e s 	ex	de,hl		;shift DE left 4 bits
835f 835f d 29
835f 835f s 	add	hl,hl
8360 8360 d 29
8360 8360 s 	add	hl,hl
8361 8361 d 29
8361 8361 s 	add	hl,hl
8362 8362 d 29
8362 8362 s 	add	hl,hl
8363 8363 d eb
8363 8363 s 	ex	de,hl
8364 8364 s 	
8364 8364 d b3
8364 8364 s 	or	e		;merge in digit just converted
8365 8365 d 5f
8365 8365 s 	ld	e,a
8366 8366 d 18f2
8366 8366 s 	jr	vhex1
8368 8368 s 
8368 8368 s ;;; convert numeric tokens from pointer list at HL
8368 8368 s ;;; to integers in list at DE
8368 8368 s ;;; token count in B
8368 8368 s ;;; overwrites HL, DE
8368 8368 s cvint:	
8368 8368 d 04
8368 8368 s 	inc	b		;return now if zero count
8369 8369 d 05
8369 8369 s 	dec	b
836a 836a d c8
836a 836a s 	ret	z
836b 836b s 
836b 836b d dde5
836b 836b s 	push	ix		;save index regs
836d 836d d fde5
836d 836d s 	push	iy
836f 836f s 	
836f 836f s 	;; move HL, DE to ix, iy - lazy
836f 836f d e5
836f 836f s 	push	hl
8370 8370 d dde1
8370 8370 s 	pop	ix
8372 8372 d d5
8372 8372 s 	push	de
8373 8373 d fde1
8373 8373 s 	pop	iy
8375 8375 s 
8375 8375 d dd6e00
8375 8375 s plop:	ld	l,(ix+0)	;get pointer
8378 8378 d dd6601
8378 8378 s 	ld	h,(ix+1)
837b 837b d dd23
837b 837b s 	inc	ix
837d 837d d dd23
837d 837d s 	inc	ix
837f 837f s 
837f 837f d cd5783
837f 837f s 	call	vhex		;convert value at (HL) to DE
8382 8382 d fd7300
8382 8382 s 	ld	(iy+0),e
8385 8385 d fd7201
8385 8385 s 	ld	(iy+1),d
8388 8388 d fd23
8388 8388 s 	inc	iy
838a 838a d fd23
838a 838a s 	inc	iy
838c 838c s 
838c 838c d 10e7
838c 838c s 	djnz	plop
838e 838e s 
838e 838e d fde1
838e 838e s pardon:	pop	iy
8390 8390 d dde1
8390 8390 s 	pop	ix
8392 8392 d c9
8392 8392 s 	ret
8393 8393 s 
8393 8393 f umon_8100H.asm
8393 8393 s 	INCLUDE "strings.asm"
8393 8393 f strings.asm
8393 8393 s ;;;
8393 8393 s ;;; string library
8393 8393 s ;;;
8393 8393 s 
8393 8393 s 	;; parse string at (HL) into space-separated tokens
8393 8393 s 	;; In:	HL points to null-terminated string
8393 8393 s 	;; 	DE points to buffer for 16-bit pointers to tokens
8393 8393 s 	;; 	B contains maximum token count
8393 8393 s 	;; Out: HL overwritten
8393 8393 s 	;; 	DE overwritten
8393 8393 s 	;; 	C contains count of tokens found
8393 8393 s 	;; 	separators in buffer overwritten with \0
8393 8393 s 	;; 
8393 8393 s 	;; leading spaces in buffer ignored
8393 8393 s 
8393 8393 s 	;; initialize
8393 8393 d af
8393 8393 s strtok:	xor	a		;clear a
8394 8394 d 4f
8394 8394 s 	ld	c,a		;zero count
8395 8395 s 
8395 8395 s 	;; skip space(s)
8395 8395 d 7e
8395 8395 s dotok:	ld	a,(hl)
8396 8396 d 23
8396 8396 s 	inc	hl
8397 8397 d b7
8397 8397 s 	or	a		;check for terminator
8398 8398 d c8
8398 8398 s 	ret	z		;return if so
8399 8399 s 	
8399 8399 d fe20
8399 8399 s 	cp	a,' '		;check for space
839b 839b d 28f8
839b 839b s 	jr	z,dotok		;keep scanning if so
839d 839d s 	
839d 839d d 2b
839d 839d s 	dec	hl		;back up to non-space char
839e 839e s 	;; HL now points to non-space, non-null (start of token)
839e 839e s 
839e 839e s 	;; store pointer HL at DE, increment DE past pointer
839e 839e d eb
839e 839e s 	ex	de,hl
839f 839f d 73
839f 839f s 	ld	(hl),e
83a0 83a0 d 23
83a0 83a0 s 	inc	hl
83a1 83a1 d 72
83a1 83a1 s 	ld	(hl),d
83a2 83a2 d 23
83a2 83a2 s 	inc	hl
83a3 83a3 d eb
83a3 83a3 s 	ex	de,hl
83a4 83a4 s 
83a4 83a4 d 0c
83a4 83a4 s 	inc	c		;update the token count
83a5 83a5 s 
83a5 83a5 s 	;; HL points to a non-space, non-term
83a5 83a5 s 	;; scan to next space or term
83a5 83a5 d 23
83a5 83a5 s skan:	inc	hl
83a6 83a6 d 7e
83a6 83a6 s 	ld	a,(hl)
83a7 83a7 d b7
83a7 83a7 s 	or	a		;check for null
83a8 83a8 d c8
83a8 83a8 s 	ret	z		;we're done
83a9 83a9 d fe20
83a9 83a9 s 	cp	a,' '
83ab 83ab d 20f8
83ab 83ab s 	jr	nz,skan		;scan past non-spaces
83ad 83ad s 
83ad 83ad s 	;; HL points to space.  Over-write with NULL
83ad 83ad d 3600
83ad 83ad s 	ld	(hl),0
83af 83af s 
83af 83af d 23
83af 83af s 	inc	hl		;point to next char past null
83b0 83b0 d 10e3
83b0 83b0 s 	djnz	dotok
83b2 83b2 s 	
83b2 83b2 d c9
83b2 83b2 s 	ret
83b3 83b3 f umon_8100H.asm
83b3 83b3 s 	INCLUDE "diskey.asm"
83b3 83b3 f diskey.asm
83b3 83b3 s ;;; ------------------------------------------------------------
83b3 83b3 s ;;; display / keyboard support
83b3 83b3 s ;;; ------------------------------------------------------------
83b3 83b3 s 
83b3 83b3 s ;;; control ports
83b3 83b3 s inpt:	equ	80H
83b3 83b3 s 
83b3 83b3 s ;;; scan the keyboard
83b3 83b3 s ;;; return row/column in A, L or 0 if no key pressed
83b3 83b3 s ;;;  Row = bits 3:5
83b3 83b3 s ;;;  Col = bits 0:2
83b3 83b3 s kbscan:
83b3 83b3 d 210000
83b3 83b3 s 	ld	hl,0
83b6 83b6 d 11ffff
83b6 83b6 s 	ld	de,0ffffh	;row/col = ff/ff 
83b9 83b9 d 0efe
83b9 83b9 s 	ld	c,0xfe		;one row set to 0
83bb 83bb d 0607
83bb 83bb s 	ld	b,7		;row down count
83bd 83bd s 
83bd 83bd d 79
83bd 83bd s row:	ld	a,c
83be 83be d d300
83be 83be s 	out	(0),a
83c0 83c0 d 14
83c0 83c0 s 	inc	d		;increment row, start at 1
83c1 83c1 d db80
83c1 83c1 s 	in	a,(inpt)
83c3 83c3 d eeff
83c3 83c3 s 	xor	0ffh
83c5 83c5 d 280f
83c5 83c5 s 	jr	z,nohit
83c7 83c7 s 	;; find bit number in E
83c7 83c7 s 
83c7 83c7 d 1c
83c7 83c7 s col:	inc	e
83c8 83c8 d cb0f
83c8 83c8 s 	rrc	a
83ca 83ca d 30fb
83ca 83ca s 	jr	nc,col		;definitely a 1
83cc 83cc s 	;; we found a hit, copy to hl
83cc 83cc d 7b
83cc 83cc s 	ld	a,e		;row
83cd 83cd d cb27
83cd 83cd s 	sla	a		;shift left 3
83cf 83cf d cb27
83cf 83cf s 	sla	a
83d1 83d1 d cb27
83d1 83d1 s 	sla	a
83d3 83d3 d b2
83d3 83d3 s 	or	d
83d4 83d4 d 6f
83d4 83d4 s 	ld	l,a
83d5 83d5 d 24
83d5 83d5 s 	inc	h		;H counts hits
83d6 83d6 s 	
83d6 83d6 d cb01
83d6 83d6 s nohit:	rlc	c
83d8 83d8 d 10e3
83d8 83d8 s 	djnz	row
83da 83da d 7d
83da 83da s 	ld	a,l		;return scan result in A, HL
83db 83db d c9
83db 83db s 	ret
83dc 83dc s 
83dc 83dc s 
83dc 83dc s ;;;
83dc 83dc s ;;; update the display
83dc 83dc s ;;; use HP-style encoding, so:
83dc 83dc s ;;;   zero = blank
83dc 83dc s ;;;   1-10 = 0 to 9
83dc 83dc s ;;;   11   = "r"
83dc 83dc s ;;;   12   = "F"
83dc 83dc s ;;;   13   = "o"
83dc 83dc s ;;;   14   = "p"
83dc 83dc s ;;;   15   = "e"
83dc 83dc s ;;; bit 6 -> replace digit with "-"
83dc 83dc s ;;; bit 7 -> turn on decimal after
83dc 83dc s ;;;
83dc 83dc s ;;; HL points to 12-byte array for the digits
83dc 83dc s ;;; 
83dc 83dc s ;;; this requires bare unencoded mode on the 7218
83dc 83dc s 
83dc 83dc d 80fbb0edf5b6d7df
83dc 83dc s s7tbl:	db	80h,0fbh,0b0h,0edh,0f5h,0b6h,0d7h,0dfh
83e4 83e4 d f0fff78cce9deecf
83e4 83e4 s 	db	0f0h,0ffh,0f7h,08ch,0ceh,09dh,0eeh,0cfh
83ec 83ec s 
83ec 83ec s minus:	equ	84h		;code for "-" with no decimal
83ec 83ec s 
83ec 83ec s left_m: equ	41h		;left 8 digits mode port
83ec 83ec s left_d:	equ	40h		;left 8 digits data port
83ec 83ec s right_m: equ	0c1h		;right 4 digits mode port
83ec 83ec s right_d: equ	0c0h		;right 4 digits data port
83ec 83ec s 
83ec 83ec s dpymod:	equ	0b0h		;no decode, data coming, not blanked
83ec 83ec s 
83ec 83ec s display:
83ec 83ec d dde5
83ec 83ec s 	push	ix
83ee 83ee d e5
83ee 83ee s 	push	hl
83ef 83ef d dde1
83ef 83ef s 	pop	ix
83f1 83f1 d 0e41
83f1 83f1 s 	ld	c,left_m
83f3 83f3 d 0608
83f3 83f3 s 	ld	b,8
83f5 83f5 d cd0284
83f5 83f5 s 	call	do7218
83f8 83f8 s 	
83f8 83f8 d 0ec1
83f8 83f8 s 	ld	c,right_m
83fa 83fa d 0608
83fa 83fa s 	ld	b,8
83fc 83fc d cd0284
83fc 83fc s 	call	do7218
83ff 83ff d dde1
83ff 83ff s 	pop	ix
8401 8401 d c9
8401 8401 s 	ret
8402 8402 s 
8402 8402 s ;;; output data at IX to 7218 decoded using s7tbl
8402 8402 s ;;; (data is 16-bit words, skip high byte)
8402 8402 s ;;; c is mode port (data port + 1)
8402 8402 s ;;; b is word count
8402 8402 s ;;;
8402 8402 s ;;; uses A, IX, BC
8402 8402 d 3eb0
8402 8402 s do7218:	ld	a,dpymod
8404 8404 d ed79
8404 8404 s 	out	(c),a
8406 8406 d 0d
8406 8406 s 	dec	c		;point to data port
8407 8407 d dd7e00
8407 8407 s do71:	ld	a,(ix)
840a 840a d e60f
840a 840a s 	and	0fh
840c 840c d ddcb0076
840c 840c s 	bit	6,(ix)
8410 8410 d 2804
8410 8410 s 	jr	z,nminus	;not "-"
8412 8412 d 3e84
8412 8412 s 	ld	a,minus		;else replace with minus code
8414 8414 d 1808
8414 8414 s 	jr	do72
8416 8416 s 	
8416 8416 s 	;; translate using table
8416 8416 d 21dc83
8416 8416 s nminus:	ld	hl,s7tbl
8419 8419 d 5f
8419 8419 s 	ld	e,a
841a 841a d 1600
841a 841a s 	ld	d,0
841c 841c d 19
841c 841c s 	add	hl,de
841d 841d d 7e
841d 841d s 	ld	a,(hl)
841e 841e s 	;; check for decimal and set if so
841e 841e d ddcb007e
841e 841e s do72:	bit	7,(ix)
8422 8422 d 2802
8422 8422 s 	jr	z,do73
8424 8424 d cbbf
8424 8424 s 	res	7,a		;clear high bit
8426 8426 s 
8426 8426 d ed79
8426 8426 s do73:	out	(c),a
8428 8428 d dd23
8428 8428 s 	inc	ix
842a 842a d dd23
842a 842a s 	inc	ix
842c 842c d 10d9
842c 842c s 	djnz	do71
842e 842e s 
842e 842e d c9
842e 842e s 	ret
842f 842f s 
842f 842f f umon_8100H.asm
842f 842f s 	INCLUDE "c-link.asm"
842f 842f f c-link.asm
842f 842f s ;;; ------------------------------------------------------------
842f 842f s ;;; C-compatible entry points for some useful functions
842f 842f s ;;; ------------------------------------------------------------
842f 842f s 
842f 842f s ;;; output character from L
842f 842f d 7d
842f 842f s putch:	ld	a,l
8430 8430 d c32582
8430 8430 s 	jp	getc
8433 8433 s 
8433 8433 s ;;; get character to HL
8433 8433 d cd2582
8433 8433 s getch:	call	getc
8436 8436 d 6f
8436 8436 s 	ld	l,a
8437 8437 d 2600
8437 8437 s 	ld	h,0
8439 8439 d c9
8439 8439 s 	ret
843a 843a s 	
843a 843a f umon_8100H.asm
843a 843a s 	INCLUDE "vfd.asm"
843a 843a f vfd.asm
843a 843a s ;;; ------------------------------------------------------------
843a 843a s ;;; VFD display control (output only)
843a 843a s ;;; ------------------------------------------------------------
843a 843a s 
843a 843a s 
843a 843a s 
843a 843a s ;;;
843a 843a s ;;; update the display
843a 843a s ;;; use HP-style encoding, so:
843a 843a s ;;;   zero = blank
843a 843a s ;;;   1-10 = 0 to 9
843a 843a s ;;;   11   = "r"
843a 843a s ;;;   12   = "F"
843a 843a s ;;;   13   = "o"
843a 843a s ;;;   14   = "p"
843a 843a s ;;;   15   = "e"
843a 843a s ;;; bit 6 -> replace digit with "-"
843a 843a s ;;; bit 7 -> turn on decimal after
843a 843a s ;;;
843a 843a s ;;; HL points to 12-byte array for the digits
843a 843a s ;;; 
843a 843a s ;;; this requires bare unencoded mode on the 7218
843a 843a s 
843a 843a s 	;;         0     1     2     3     4     5     6
843a 843a d 00de82ece6b2767e
843a 843a s vs7tbl:	db	0, 0deh, 082h, 0ech, 0e6h, 0b2h, 076h, 07eh
8442 8442 s 	;;      7     8     9     r     F     o     p     E
8442 8442 d c2fef628782ef87e
8442 8442 s 	db	0c2h, 0feh, 0f6h, 028h, 078h, 02eh, 0f8h, 07eh
844a 844a s 
844a 844a s vminus:	equ	020h		;code for "-" with no decimal
844a 844a s 	;; or maybe 08h?
844a 844a s 
844a 844a s vfd_prt:	equ	40h		;display controller port
844a 844a s 
844a 844a s vfd_d:	 equ	1		;VFD data bit
844a 844a s vfd_stb: equ	2		;VFD strobe bit
844a 844a s vfd_clk: equ	4		;VFD shift clock
844a 844a s vfd_bl:	equ	8		;VFD blanking
844a 844a s vfd_led2: equ	10h		;VFD LED2 (power supply control?)
844a 844a s vfd_led1: equ	20h		;VFD LED1 (power supply control?)
844a 844a s 
844a 844a s vfd_digits: equ	12		;number of digits
844a 844a s vfd_extra: equ	4		;extra clocks
844a 844a s 	
844a 844a s ;;; initialize the display hardware
844a 844a s vfd_init:	
844a 844a d 3e08
844a 844a s 	ld	a,vfd_bl	;blank display by default
844c 844c d d340
844c 844c s 	out	(vfd_prt),a
844e 844e d c9
844e 844e s 	ret
844f 844f s 
844f 844f s vfd_display:	
844f 844f d dde5
844f 844f s 	push	ix
8451 8451 d c5
8451 8451 s 	push	bc
8452 8452 d d5
8452 8452 s 	push	de
8453 8453 s 
8453 8453 d 0e0c
8453 8453 s 	ld	c,vfd_digits	;digit count
8455 8455 s 
8455 8455 d e5
8455 8455 s 	push	hl		;display data pointer to IX
8456 8456 d dde1
8456 8456 s 	pop	ix
8458 8458 s 
8458 8458 s 	;; extra clocks
8458 8458 d 0604
8458 8458 s 	ld	b,vfd_extra
845a 845a d cd9484
845a 845a s 	call	vfd_shifty
845d 845d s 
845d 845d d dd7e00
845d 845d s dpyb:	ld	a,(ix)		;get display byte
8460 8460 s 
8460 8460 s ;;; comment out below for raw data
8460 8460 d e60f
8460 8460 s 	and	0fh		;only want low  bits
8462 8462 d 1600
8462 8462 s 	ld	d,0
8464 8464 d 5f
8464 8464 s 	ld	e,a
8465 8465 d 213a84
8465 8465 s 	ld	hl,vs7tbl	;look up in table
8468 8468 d 19
8468 8468 s 	add	hl,de
8469 8469 d 7e
8469 8469 s 	ld	a,(hl)
846a 846a d ddcb007e
846a 846a s 	bit	7,(ix)		;decimal?
846e 846e d 2802
846e 846e s 	jr	z,nodp
8470 8470 d f601
8470 8470 s 	or	a,1		;set decimal bit if so
8472 8472 d ddcb0076
8472 8472 s nodp:	bit	6,(ix)		;check minus flag
8476 8476 d 2802
8476 8476 s 	jr	z,nomi
8478 8478 d 3e20
8478 8478 s 	ld	a,vminus	;yes, replace with "-" code
847a 847a s 
847a 847a s 	;; shift out bits 
847a 847a d 0608
847a 847a s nomi:	ld	b,8
847c 847c d cd9484
847c 847c s 	call	vfd_shifty
847f 847f s 
847f 847f d dd23
847f 847f s 	inc	ix
8481 8481 d 0d
8481 8481 s 	dec	c
8482 8482 d 20d9
8482 8482 s 	jr	nz,dpyb
8484 8484 s 
8484 8484 s ;;; cycle the strobe to update the display, and un-blank
8484 8484 d 3e02
8484 8484 s 	ld	a,vfd_stb
8486 8486 d d340
8486 8486 s 	out	(vfd_prt),a
8488 8488 d 00
8488 8488 s 	nop
8489 8489 d 00
8489 8489 s 	nop
848a 848a d af
848a 848a s 	xor	a
848b 848b d d340
848b 848b s 	out	(vfd_prt),a
848d 848d d 00
848d 848d s 	nop
848e 848e d 00
848e 848e s 	nop
848f 848f s 	
848f 848f d d1
848f 848f s 	pop	de
8490 8490 d c1
8490 8490 s 	pop	bc
8491 8491 d dde1
8491 8491 s 	pop	ix
8493 8493 d c9
8493 8493 s 	ret
8494 8494 s 
8494 8494 s ;;; shift B bits to display from A, LSB first
8494 8494 s ;;; uses HL
8494 8494 s vfd_shifty:
8494 8494 d 6f
8494 8494 s 	ld	l,a
8495 8495 d 2600
8495 8495 s 	ld	h,0
8497 8497 s 	
8497 8497 d af
8497 8497 s vfd_sh:	xor	a		;clear a
8498 8498 d cb0d
8498 8498 s 	rrc	l		;data bit to CY
849a 849a d 8c
849a 849a s 	adc	a,h		;data bit to A bit 0
849b 849b d d340
849b 849b s 	out	(vfd_prt),a
849d 849d d 00
849d 849d s 	nop
849e 849e d 00
849e 849e s 	nop
849f 849f d f604
849f 849f s 	or	a,vfd_clk	;assert CLK
84a1 84a1 d d340
84a1 84a1 s 	out	(vfd_prt),a
84a3 84a3 d 00
84a3 84a3 s 	nop
84a4 84a4 d 00
84a4 84a4 s 	nop
84a5 84a5 d e601
84a5 84a5 s 	and	a,1		;deassert CLK
84a7 84a7 d d340
84a7 84a7 s 	out	(vfd_prt),a
84a9 84a9 d 00
84a9 84a9 s 	nop
84aa 84aa d 00
84aa 84aa s 	nop
84ab 84ab d 10ea
84ab 84ab s 	djnz	vfd_sh
84ad 84ad s 
84ad 84ad d c9
84ad 84ad s 	ret
84ae 84ae s 	
84ae 84ae s 	
84ae 84ae f umon_8100H.asm
84ae 84ae s 
84ae 84ae d 554d4f4e2076302e37204f52472000
84ae 84ae s banner:	db	"UMON v0.7 ORG ",0
84bd 84bd d 4552524f5200
84bd 84bd s error:	db	"ERROR",0
84c3 84c3 s 	
84c3 84c3 d 682020202020202020202020202020202020202020207072696e7420746869732068656c700d0a
84c3 84c3 s usage:  db      "h                     print this help", 13, 10
84ea 84ea d 64203c616464723e203c636f756e740d0a
84ea 84ea s         db      "d <addr> <count", 13, 10
84fb 84fb d 64203c616464723e203c636f756e743e20202020202064756d70206d656d6f72790d0a
84fb 84fb s         db      "d <addr> <count>      dump memory", 13, 10
851e 851e d 65203c616464723e203c64643e203c64643e2e2e2e206564697420757020746f20313620627974657320696e206d656d6f72790d0a
851e 851e s         db      "e <addr> <dd> <dd>... edit up to 16 bytes in memory", 13, 10
8553 8553 d 6f203c616464723e203c76616c3e20202020202020206f7574707574203c76616c3e20746f20706f7274203c616464723e0d0a
8553 8553 s         db      "o <addr> <val>        output <val> to port <addr>", 13, 10
8586 8586 d 7a203c76616c3e20202020202020202020202020202073657420706f7274207a65726f2076616c7565206269747320302d360d0a
8586 8586 s         db      "z <val>               set port zero value bits 0-6", 13, 10
85ba 85ba d 69203c616464723e2020202020202020202020202020696e7075742066726f6d203c616464723e20616e6420646973706c61790d0a
85ba 85ba s         db      "i <addr>              input from <addr> and display", 13, 10
85ef 85ef d 67203c616464723e2020202020202020202020202020676f746f20616464720d0a
85ef 85ef s         db      "g <addr>              goto addr", 13, 10
8610 8610 d 62203c616464723e202020202020202020202020202073657420627265616b706f696e74202863757272656e746c7920332d627974652063616c6c290d0a
8610 8610 s         db      "b <addr>              set breakpoint (currently 3-byte call)", 13, 10
864e 864e d 61203c76616c313e203c76616c323e202020202020206865782041726974686d657469630d0a
864e 864e s         db      "a <val1> <val2>       hex Arithmetic", 13, 10
8674 8674 d 67203c616464723e202020202020202020202020202064756d70204850207265676973746572732066726f6d203c616464723e202841290d0a
8674 8674 s         db      "g <addr>              dump HP registers from <addr> (A)", 13, 10
86ad 86ad d 6d203c6164313e203c6164323e203c6e3e20202020206d656d6f727920636f6d706172650d0a
86ad 86ad s 	db	"m <ad1> <ad2> <n>     memory compare", 13, 10
86d3 86d3 d 70203c6164313e203c6164323e203c6e3e20202020206d656d6f727920636f70790d0a
86d3 86d3 s 	db	"p <ad1> <ad2> <n>     memory copy", 13, 10
86f6 86f6 d 63202020202020202020202020202020202020202020636f6e74696e75652066726f6d20627265616b706f696e740d0a
86f6 86f6 s         db      "c                     continue from breakpoint", 13, 10
8726 8726 d 6c20202020202020202020202020202020202020202062696e617279206c6f61640d0a
8726 8726 s         db      "l                     binary load", 13, 10
8749 8749 d 72202020202020202020202020202020202020202020726570656174206c61737420636f6d6d616e640d0a
8749 8749 s         db      "r                     repeat last command", 13, 10
8774 8774 d 6b2020202020202020202020202020202020202020207363616e206b6579626f6172640d0a
8774 8774 s         db      "k                     scan keyboard", 13, 10
8799 8799 d 37203c616464723e2020202020202020202020202020757064617465204c454420646973706c61792066726f6d203c616464723e0d0a
8799 8799 s         db      "7 <addr>              update LED display from <addr>", 13, 10
87cf 87cf d 56203c616464723e20202020202020202020202020207570646174652056464420646973706c61792028303d626c616e6b290d0a
87cf 87cf s         db      "V <addr>              update VFD display (0=blank)", 13, 10
8803 8803 d 00
8803 8803 s 	db	0
8804 8804 s 
8804 8804 d 310081
8804 8804 s main:	ld	sp,stak
8807 8807 d 21ae84
8807 8807 s 	ld	hl,banner
880a 880a d cd9d82
880a 880a s 	call	puts
880d 880d d 210081
880d 880d s 	ld	hl,stak
8810 8810 d cd1683
8810 8810 s 	call	phex4
8813 8813 d cd9082
8813 8813 s 	call	space
8816 8816 d 212b8c
8816 8816 s 	ld	hl,umontop
8819 8819 d cd1683
8819 8819 s 	call	phex4
881c 881c d cd9482
881c 881c s 	call	crlf
881f 881f s 	
881f 881f d 3e3e
881f 881f s loop:	ld	a,'>'		;prompt
8821 8821 d cd4f82
8821 8821 s 	call	putc
8824 8824 s 
8824 8824 d 214181
8824 8824 s 	ld	hl,buff
8827 8827 d 013c00
8827 8827 s 	ld	bc,bend-buff	; maximum size
882a 882a d cda682
882a 882a s 	call	gets
882d 882d s 
882d 882d s 	;; check for 'R'
882d 882d d 3a4181
882d 882d s 	ld	a,(buff)
8830 8830 d fe52
8830 8830 s 	cp	a,'R'
8832 8832 d 2006
8832 8832 s 	jr	nz,not_r
8834 8834 s 
8834 8834 s 	;; restore last command byte
8834 8834 d 3a4081
8834 8834 s 	ld	a,(lastc)
8837 8837 d 324181
8837 8837 s 	ld	(buff),a
883a 883a s 
883a 883a s 	;; parse string into tokens at argc / argv
883a 883a d 214181
883a 883a s not_r:	ld	hl,buff
883d 883d d 117e81
883d 883d s 	ld	de,argv
8840 8840 d 0612
8840 8840 s 	ld	b,maxarg
8842 8842 d cd9383
8842 8842 s 	call	strtok	
8845 8845 d 79
8845 8845 s 	ld	a,c
8846 8846 d 327d81
8846 8846 s 	ld	(argc),a
8849 8849 s 
8849 8849 s 	;; convert tokens to integers
8849 8849 d 217e81
8849 8849 s 	ld	hl,argv
884c 884c d 11c681
884c 884c s 	ld	de,iargv
884f 884f d 47
884f 884f s 	ld	b,a
8850 8850 d cd6883
8850 8850 s 	call	cvint
8853 8853 s 
8853 8853 d 214181
8853 8853 s 	ld	hl,buff		;parse command character
8856 8856 d 7e
8856 8856 s 	ld	a,(hl)
8857 8857 d 324081
8857 8857 s 	ld	(lastc),a	;save for possible repeat
885a 885a s 
885a 885a d fe44
885a 885a s 	cp	a,'D'		;dump memory
885c 885c d ca978a
885c 885c s 	jz	dump
885f 885f s 
885f 885f d fe48
885f 885f s 	cp	a,'H'
8861 8861 d caf188
8861 8861 s 	jz	help
8864 8864 s 
8864 8864 d fe46
8864 8864 s 	cp	a,'F'
8866 8866 d caf88a
8866 8866 s 	jz	hpdump
8869 8869 s 	
8869 8869 d fe41
8869 8869 s 	cp	a,'A'
886b 886b d cace8a
886b 886b s 	jz	arith
886e 886e s 
886e 886e d fe45
886e 886e s 	cp	a,'E'
8870 8870 d ca778a
8870 8870 s 	jz	edit
8873 8873 s 
8873 8873 d fe42
8873 8873 s 	cp	a,'B'
8875 8875 d ca5a89
8875 8875 s 	jz	brkpt
8878 8878 s 
8878 8878 d fe43
8878 8878 s 	cp	a,'C'
887a 887a d ca1589
887a 887a s 	jz	continu
887d 887d s 
887d 887d d fe47
887d 887d s 	cp	a,'G'
887f 887f d ca6e8a
887f 887f s 	jz	goto
8882 8882 s 
8882 8882 d fe4c
8882 8882 s 	cp	a,'L'
8884 8884 d ca078a
8884 8884 s 	jz	binary
8887 8887 s 	
8887 8887 d fe4f
8887 8887 s 	cp	a,'O'
8889 8889 d cafa88
8889 8889 s 	jz	output
888c 888c s 
888c 888c d fe49
888c 888c s 	cp	a,'I'
888e 888e d ca0689
888e 888e s 	jz	input
8891 8891 s 
8891 8891 d fe5a
8891 8891 s 	cp	a,'Z'
8893 8893 d cae488
8893 8893 s 	jz	zero
8896 8896 s 
8896 8896 d fe4b
8896 8896 s 	cp	a,'K'
8898 8898 d cabe88
8898 8898 s 	jz	kbtest
889b 889b s 
889b 889b d fe37
889b 889b s 	cp	a,'7'
889d 889d d caca88
889d 889d s 	jz	dptest
88a0 88a0 s 
88a0 88a0 d fe56
88a0 88a0 s 	cp	a,'V'
88a2 88a2 d cad388
88a2 88a2 s 	jz	vfdtest
88a5 88a5 s 
88a5 88a5 d fe4d
88a5 88a5 s 	cp	a,'M'
88a7 88a7 d cad98b
88a7 88a7 s 	jz	memcmp
88aa 88aa s 
88aa 88aa d fe50
88aa 88aa s 	cp	a,'P'
88ac 88ac d cad18b
88ac 88ac s 	jz	memcpy
88af 88af s 	
88af 88af d 21bd84
88af 88af s errz:	ld	hl,error
88b2 88b2 d cd9d82
88b2 88b2 s 	call	puts
88b5 88b5 d cd9482
88b5 88b5 s 	call	crlf
88b8 88b8 s 	
88b8 88b8 d c31f88
88b8 88b8 s 	jp	loop
88bb 88bb s 
88bb 88bb d c30000
88bb 88bb s quit:	jp	0
88be 88be s 
88be 88be d cdb383
88be 88be s kbtest:	call	kbscan
88c1 88c1 d cd1683
88c1 88c1 s 	call	phex4
88c4 88c4 d cd9482
88c4 88c4 s 	call	crlf
88c7 88c7 d c31f88
88c7 88c7 s 	jp	loop
88ca 88ca s 
88ca 88ca d 2ac881
88ca 88ca s dptest:	ld	hl,(iargv+2)
88cd 88cd d cdec83
88cd 88cd s 	call	display
88d0 88d0 d c31f88
88d0 88d0 s 	jp	loop
88d3 88d3 s 
88d3 88d3 d cd4a84
88d3 88d3 s vfdtest: call	vfd_init	;initialize (and blank) VFD display
88d6 88d6 d 2ac881
88d6 88d6 s  	ld	hl,(iargv+2)	;get address to display from
88d9 88d9 d 7c
88d9 88d9 s 	ld	a,h		;check for zero (blank)
88da 88da d b5
88da 88da s 	or	l
88db 88db d ca1f88
88db 88db s 	jp	z,loop		;zero, leave display blanked
88de 88de s 	
88de 88de d cd4f84
88de 88de s 	call	vfd_display	;else update the display
88e1 88e1 d c31f88
88e1 88e1 s 	jp	loop
88e4 88e4 s 
88e4 88e4 s ;;; set port zero value
88e4 88e4 d 3ac881
88e4 88e4 s zero:	ld	a,(iargv+2)
88e7 88e7 d 323f81
88e7 88e7 s 	ld	(pzero),a
88ea 88ea d c31f88
88ea 88ea s 	jp	loop
88ed 88ed s 
88ed 88ed s ;;; alternative subr to do this from outside
88ed 88ed d 323f81
88ed 88ed s setpzero: ld (pzero),a
88f0 88f0 d c9
88f0 88f0 s 	ret
88f1 88f1 s 
88f1 88f1 d 21c384
88f1 88f1 s help:	ld	hl,usage
88f4 88f4 d cd9d82
88f4 88f4 s 	call	puts
88f7 88f7 d c31f88
88f7 88f7 s 	jp	loop
88fa 88fa s 
88fa 88fa s ;;; output to port
88fa 88fa d 3ac881
88fa 88fa s output:	ld	a,(iargv+2)
88fd 88fd d 4f
88fd 88fd s 	ld	c,a
88fe 88fe d 3aca81
88fe 88fe s 	ld	a,(iargv+4)
8901 8901 d ed79
8901 8901 s 	out	(c),a
8903 8903 d c31f88
8903 8903 s 	jp	loop
8906 8906 s 
8906 8906 s ;;; input from port
8906 8906 d 3ac881
8906 8906 s input:	ld	a,(iargv+2)
8909 8909 d 4f
8909 8909 s 	ld	c,a
890a 890a d ed78
890a 890a s 	in	a,(c)
890c 890c d cd0583
890c 890c s 	call	phex2
890f 890f d cd9482
890f 890f s 	call	crlf
8912 8912 d c31f88
8912 8912 s 	jp	loop
8915 8915 s 
8915 8915 s 	;; continue after breakpoint
8915 8915 s 	;; check if there is one first
8915 8915 s 	;; clears breakpoint as part of the process
8915 8915 d 2a1b81
8915 8915 s continu: ld	hl,(savead)
8918 8918 d 7d
8918 8918 s 	ld	a,l
8919 8919 d b4
8919 8919 s 	or	h
891a 891a d cac389
891a 891a s 	jp	z,nobrk		;go if not set
891d 891d d 110000
891d 891d s 	ld	de,0
8920 8920 d ed531b81
8920 8920 s 	ld	(savead),de	;mark as cleared
8924 8924 s 
8924 8924 d eb
8924 8924 s 	ex	de,hl		;address to HL
8925 8925 s 	
8925 8925 s 	;; first restore the instruction saved
8925 8925 d 211881
8925 8925 s 	ld	hl,savein
8928 8928 d eda0
8928 8928 s 	ldi
892a 892a d eda0
892a 892a s 	ldi
892c 892c d eda0
892c 892c s 	ldi
892e 892e s 
892e 892e s 	;; optionally, set a new breakpoint
892e 892e d 3a7d81
892e 892e s 	ld	a,(argc)
8931 8931 d fe02
8931 8931 s 	cp	2
8933 8933 d 200f
8933 8933 s 	jr	nz,nonew
8935 8935 s 
8935 8935 s 	;; set new breakpoint
8935 8935 d 2ac881
8935 8935 s 	ld	hl,(iargv+2)
8938 8938 d cda089
8938 8938 s 	call	brkat
893b 893b s 	
893b 893b d cd1683
893b 893b s 	call	phex4
893e 893e d 21cc89
893e 893e s 	ld	hl,msgset
8941 8941 d cd9d82
8941 8941 s 	call	puts
8944 8944 s 
8944 8944 s 	;; restore the machine state
8944 8944 d 311f81
8944 8944 s nonew:	ld	sp,saviy
8947 8947 s 
8947 8947 d fde1
8947 8947 s 	pop	iy
8949 8949 d dde1
8949 8949 s 	pop	ix
894b 894b s 
894b 894b d e1
894b 894b s 	pop	hl
894c 894c d d1
894c 894c s 	pop	de
894d 894d d c1
894d 894d s 	pop	bc
894e 894e d f1
894e 894e s 	pop	af
894f 894f d d9
894f 894f s 	exx
8950 8950 d 08
8950 8950 s 	ex	af,af'
8951 8951 s 	
8951 8951 d e1
8951 8951 s 	pop	hl
8952 8952 d d1
8952 8952 s 	pop	de
8953 8953 d c1
8953 8953 s 	pop	bc
8954 8954 d f1
8954 8954 s 	pop	af
8955 8955 s 
8955 8955 d ed7b1d81
8955 8955 s 	ld	sp,(savsp)	;get back caller's stack
8959 8959 d c9
8959 8959 s 	ret			;should to back to BP locn
895a 895a s 
895a 895a s 	
895a 895a s ;;; set breakpoint
895a 895a d 3a7d81
895a 895a s brkpt:	ld	a,(argc)
895d 895d d fe02
895d 895d s 	cp	2		;single numeric argument?
895f 895f d 2826
895f 895f s 	jr	z,brkset
8961 8961 s 
8961 8961 s 	;; clear breakpoint if set
8961 8961 d 2a1b81
8961 8961 s brkclr:	ld	hl,(savead)
8964 8964 d 7d
8964 8964 s 	ld	a,l
8965 8965 d b4
8965 8965 s 	or	h
8966 8966 d 285b
8966 8966 s 	jr	z,nobrk		;go if not set
8968 8968 s 
8968 8968 d cd1683
8968 8968 s 	call	phex4
896b 896b d 21dd89
896b 896b s 	ld	hl,msgclr
896e 896e d cd9d82
896e 896e s 	call	puts
8971 8971 s 
8971 8971 d 2a1b81
8971 8971 s 	ld	hl,(savead)
8974 8974 d eb
8974 8974 s 	ex	de,hl
8975 8975 d 211881
8975 8975 s 	ld	hl,savein
8978 8978 d eda0
8978 8978 s 	ldi
897a 897a d eda0
897a 897a s 	ldi
897c 897c d eda0
897c 897c s 	ldi
897e 897e s 
897e 897e d 210000
897e 897e s 	ld	hl,0
8981 8981 d 221b81
8981 8981 s 	ld	(savead),hl	;erase saved address
8984 8984 s 
8984 8984 d c31f88
8984 8984 s 	jp	loop
8987 8987 s 
8987 8987 s 	;; check for breakpoint already set
8987 8987 d 2a1b81
8987 8987 s brkset:	ld	hl,(savead)
898a 898a d 7c
898a 898a s 	ld	a,h
898b 898b d b5
898b 898b s 	or	l
898c 898c d 202c
898c 898c s 	jr	nz,brkovr	;attempt to overwrite breakpoint
898e 898e s 
898e 898e d 2ac881
898e 898e s 	ld	hl,(iargv+2)	;breakpoint goes here
8991 8991 d cda089
8991 8991 s 	call	brkat
8994 8994 d cd1683
8994 8994 s 	call	phex4
8997 8997 d 21cc89
8997 8997 s 	ld	hl,msgset
899a 899a d cd9d82
899a 899a s 	call	puts
899d 899d s 
899d 899d d c31f88
899d 899d s 	jp	loop
89a0 89a0 s 
89a0 89a0 s brkat:	
89a0 89a0 d e5
89a0 89a0 s 	push	hl		;save locn
89a1 89a1 d 221b81
89a1 89a1 s 	ld	(savead),hl	;set brkpt locn
89a4 89a4 d 111881
89a4 89a4 s 	ld	de,savein	;save area for 3-byte instruction
89a7 89a7 d eda0
89a7 89a7 s 	ldi
89a9 89a9 d eda0
89a9 89a9 s 	ldi
89ab 89ab d eda0
89ab 89ab s 	ldi			;copy 3 bytes
89ad 89ad d e1
89ad 89ad s 	pop	hl		;get locn back
89ae 89ae d e5
89ae 89ae s 	push	hl
89af 89af d 36cd
89af 89af s 	ld	(hl),0cdh	;CALL
89b1 89b1 d 23
89b1 89b1 s 	inc	hl
89b2 89b2 d 11308b
89b2 89b2 s 	ld	de,savestate	;target for call
89b5 89b5 d 73
89b5 89b5 s 	ld	(hl),e
89b6 89b6 d 23
89b6 89b6 s 	inc	hl
89b7 89b7 d 72
89b7 89b7 s 	ld	(hl),d
89b8 89b8 d e1
89b8 89b8 s 	pop	hl
89b9 89b9 d c9
89b9 89b9 s 	ret
89ba 89ba s 
89ba 89ba d 21e889
89ba 89ba s brkovr:	ld	hl,msgovr
89bd 89bd d cd9d82
89bd 89bd s 	call	puts
89c0 89c0 d c31f88
89c0 89c0 s 	jp	loop
89c3 89c3 s 
89c3 89c3 d 21d389
89c3 89c3 s nobrk:	ld	hl,msgno
89c6 89c6 d cd9d82
89c6 89c6 s 	call	puts
89c9 89c9 d c31f88
89c9 89c9 s 	jp	loop
89cc 89cc s 
89cc 89cc d 205345540d0a00
89cc 89cc s msgset:	db	' SET', 13, 10, 0
89d3 89d3 d 4e4f20424b50540d0a00
89d3 89d3 s msgno:	db	'NO BKPT', 13, 10, 0
89dd 89dd d 20434c45415245440d0a00
89dd 89dd s msgclr:	db	' CLEARED', 13, 10, 0
89e8 89e8 d 424b505420414c52454144592053455420434c4541522046495253540d0a00
89e8 89e8 s msgovr:	db	'BKPT ALREADY SET CLEAR FIRST', 13, 10, 0
8a07 8a07 s 
8a07 8a07 s 
8a07 8a07 s ;;; start binary loader
8a07 8a07 s ;;; expect binary words (LSB first):
8a07 8a07 s ;;;    0x5791, <addr>, <count>
8a07 8a07 s ;;; then <count> data bytes
8a07 8a07 s ;;; does not jump after, just returns to prompt
8a07 8a07 s ;;; if header not seen after a few bytes, bail out
8a07 8a07 s ;;;
8a07 8a07 s ;;; echo back all received
8a07 8a07 s ;;; 
8a07 8a07 d 0605
8a07 8a07 s binary:	ld	b,5		;max bad bytes
8a09 8a09 s 	;; read chars until 5 received or 0x91 seen
8a09 8a09 d cd2582
8a09 8a09 s bin1:	call	getc
8a0c 8a0c d cd4f82
8a0c 8a0c s 	call	putc
8a0f 8a0f d fe91
8a0f 8a0f s 	cp	0x91		;first magic byte?
8a11 8a11 d 2805
8a11 8a11 s 	jr	z,bin1a
8a13 8a13 d 10f4
8a13 8a13 s 	djnz	bin1
8a15 8a15 d c3af88
8a15 8a15 s 	jp	errz
8a18 8a18 s 	
8a18 8a18 s 	;; read chars, skipping repeat 0x91, wait for 0x57
8a18 8a18 d cd2582
8a18 8a18 s bin1a:	call	getc
8a1b 8a1b d cd4f82
8a1b 8a1b s 	call	putc
8a1e 8a1e d fe91
8a1e 8a1e s 	cp	0x91
8a20 8a20 d 28f6
8a20 8a20 s 	jr	z,bin1a
8a22 8a22 d fe57
8a22 8a22 s 	cp	0x57
8a24 8a24 d c2af88
8a24 8a24 s 	jp	nz,errz
8a27 8a27 s 	
8a27 8a27 s 	;; get address to hl
8a27 8a27 d cd2582
8a27 8a27 s 	call	getc
8a2a 8a2a d cd4f82
8a2a 8a2a s 	call	putc
8a2d 8a2d d 6f
8a2d 8a2d s 	ld	l,a
8a2e 8a2e d cd2582
8a2e 8a2e s 	call	getc
8a31 8a31 d cd4f82
8a31 8a31 s 	call	putc
8a34 8a34 d 67
8a34 8a34 s 	ld	h,a
8a35 8a35 d 22c681
8a35 8a35 s 	ld	(iargv),hl
8a38 8a38 s 	;; get count to bc
8a38 8a38 d cd2582
8a38 8a38 s 	call	getc
8a3b 8a3b d cd4f82
8a3b 8a3b s 	call	putc
8a3e 8a3e d 4f
8a3e 8a3e s 	ld	c,a
8a3f 8a3f d cd2582
8a3f 8a3f s 	call	getc
8a42 8a42 d cd4f82
8a42 8a42 s 	call	putc
8a45 8a45 d 47
8a45 8a45 s 	ld	b,a
8a46 8a46 d ed43c881
8a46 8a46 s 	ld	(iargv+2),bc
8a4a 8a4a s 	;; read and store data
8a4a 8a4a d cd2582
8a4a 8a4a s bin2:	call	getc
8a4d 8a4d d cd4f82
8a4d 8a4d s 	call	putc
8a50 8a50 d 77
8a50 8a50 s 	ld	(hl),a
8a51 8a51 d 23
8a51 8a51 s 	inc	hl
8a52 8a52 d 0b
8a52 8a52 s 	dec	bc
8a53 8a53 d 78
8a53 8a53 s 	ld	a,b
8a54 8a54 d b1
8a54 8a54 s 	or	c
8a55 8a55 d 20f3
8a55 8a55 s 	jr	nz,bin2
8a57 8a57 s 
8a57 8a57 s 	;; leave addr, count in iargv+2, iargv+4
8a57 8a57 s 	;; display them too
8a57 8a57 d 2ac681
8a57 8a57 s 	ld	hl,(iargv)
8a5a 8a5a d cd1683
8a5a 8a5a s 	call	phex4
8a5d 8a5d d cd9482
8a5d 8a5d s 	call	crlf
8a60 8a60 d ed4bc881
8a60 8a60 s 	ld	bc,(iargv+2)
8a64 8a64 d 09
8a64 8a64 s 	add	hl,bc
8a65 8a65 d cd1683
8a65 8a65 s 	call	phex4
8a68 8a68 d cd9482
8a68 8a68 s 	call	crlf
8a6b 8a6b d c31f88
8a6b 8a6b s 	jp	loop
8a6e 8a6e s 
8a6e 8a6e s ;;; jump to 1st arg
8a6e 8a6e d fe02
8a6e 8a6e s goto:	cp	2
8a70 8a70 d daaf88
8a70 8a70 s 	jp	c,errz
8a73 8a73 d 2ac881
8a73 8a73 s 	ld	hl,(iargv+2)
8a76 8a76 d e9
8a76 8a76 s 	jp	(hl)
8a77 8a77 s 
8a77 8a77 s ;;; edit values into memory
8a77 8a77 d 3a7d81
8a77 8a77 s edit:	ld	a,(argc)
8a7a 8a7a d fe03
8a7a 8a7a s 	cp	a,3		;need at least 3 args
8a7c 8a7c d daaf88
8a7c 8a7c s 	jp	c,errz
8a7f 8a7f s 
8a7f 8a7f d d602
8a7f 8a7f s 	sub	a,2
8a81 8a81 d 47
8a81 8a81 s 	ld	b,a		;count of bytes to store
8a82 8a82 s 
8a82 8a82 d 2ac881
8a82 8a82 s 	ld	hl,(iargv+2)	;get address
8a85 8a85 d dd21ca81
8a85 8a85 s 	ld	ix,iargv+4	;pointer to first data item
8a89 8a89 s 
8a89 8a89 d dd7e00
8a89 8a89 s eloop:	ld	a,(ix)
8a8c 8a8c d 77
8a8c 8a8c s 	ld	(hl),a
8a8d 8a8d d 23
8a8d 8a8d s 	inc	hl
8a8e 8a8e d dd23
8a8e 8a8e s 	inc	ix
8a90 8a90 d dd23
8a90 8a90 s 	inc	ix
8a92 8a92 d 10f5
8a92 8a92 s 	djnz	eloop
8a94 8a94 d c31f88
8a94 8a94 s 	jp	loop
8a97 8a97 s 
8a97 8a97 s ;;; dump some memory
8a97 8a97 d 2ac881
8a97 8a97 s dump:	ld	hl,(iargv+2)	;first arg
8a9a 8a9a d 3aca81
8a9a 8a9a s 	ld	a,(iargv+4)	;second arg
8a9d 8a9d s 	
8a9d 8a9d d 47
8a9d 8a9d s 	ld	b,a		;count
8a9e 8a9e d cda48a
8a9e 8a9e s 	call	hdump
8aa1 8aa1 d c31f88
8aa1 8aa1 s 	jp	loop
8aa4 8aa4 s 
8aa4 8aa4 s ;;; hex dump B bytes from HL
8aa4 8aa4 s 	;; see if we need to print the address
8aa4 8aa4 s 	;; either on 16-byte boundary, or first address
8aa4 8aa4 d cdbd8a
8aa4 8aa4 s hdump:	call	haddr		;always print first address
8aa7 8aa7 d 1806
8aa7 8aa7 s 	jr	bite		;skip the 16-byte test
8aa9 8aa9 s 
8aa9 8aa9 d 7d
8aa9 8aa9 s hdump2:	ld	a,l
8aaa 8aaa d e60f
8aaa 8aaa s 	and	0xf
8aac 8aac d ccbd8a
8aac 8aac s 	call	z,haddr
8aaf 8aaf s 
8aaf 8aaf d 7e
8aaf 8aaf s bite:	ld	a,(hl)
8ab0 8ab0 d 23
8ab0 8ab0 s 	inc	hl
8ab1 8ab1 d cd0583
8ab1 8ab1 s 	call	phex2
8ab4 8ab4 d cd9082
8ab4 8ab4 s 	call	space
8ab7 8ab7 s 
8ab7 8ab7 d 10f0
8ab7 8ab7 s noadr:	djnz	hdump2
8ab9 8ab9 d cd9482
8ab9 8ab9 s 	call	crlf
8abc 8abc d c9
8abc 8abc s 	ret
8abd 8abd s 
8abd 8abd s ;;; print address in HL
8abd 8abd d e5
8abd 8abd s haddr:	push	hl
8abe 8abe d cd9482
8abe 8abe s 	call	crlf
8ac1 8ac1 d cd1683
8ac1 8ac1 s 	call	phex4
8ac4 8ac4 d 3e3a
8ac4 8ac4 s 	ld	a,':'
8ac6 8ac6 d cd4f82
8ac6 8ac6 s 	call	putc
8ac9 8ac9 d cd9082
8ac9 8ac9 s 	call	space
8acc 8acc d e1
8acc 8acc s 	pop	hl
8acd 8acd d c9
8acd 8acd s 	ret
8ace 8ace s 
8ace 8ace s ;;; do hex arithmetic
8ace 8ace d 2ac881
8ace 8ace s arith:	ld	hl,(iargv+2)	;first arg
8ad1 8ad1 d ed5bca81
8ad1 8ad1 s 	ld	de,(iargv+4)	;second arg
8ad5 8ad5 s 	
8ad5 8ad5 d 19
8ad5 8ad5 s 	add	hl,de
8ad6 8ad6 d cd1683
8ad6 8ad6 s 	call	phex4
8ad9 8ad9 d cd9082
8ad9 8ad9 s 	call	space
8adc 8adc d 2ac881
8adc 8adc s 	ld	hl,(iargv+2)	;first arg
8adf 8adf d ed5bca81
8adf 8adf s 	ld	de,(iargv+4)	;second arg
8ae3 8ae3 d b7
8ae3 8ae3 s 	or	a		;clear CY
8ae4 8ae4 d ed52
8ae4 8ae4 s 	sbc	hl,de
8ae6 8ae6 d cd1683
8ae6 8ae6 s 	call	phex4
8ae9 8ae9 d cd9482
8ae9 8ae9 s 	call	crlf
8aec 8aec d c31f88
8aec 8aec s 	jp	loop
8aef 8aef s 
8aef 8aef s ;;; HP calculator word size
8aef 8aef s wsize:	equ	14
8aef 8aef s ;;; register names
8aef 8aef d 414258595a54313200
8aef 8aef s hpregs:	db	"ABXYZT12", 0
8af8 8af8 s 
8af8 8af8 s ;;; dump HP registers
8af8 8af8 s ;;; all 14 nibbles:  A, B, X, Y, Z, T, M1, M2
8af8 8af8 d 2ac881
8af8 8af8 s hpdump:	ld	hl,(iargv+2)	;first arg
8afb 8afb d 110e00
8afb 8afb s 	ld	de,wsize
8afe 8afe d dd21ef8a
8afe 8afe s 	ld	ix,hpregs
8b02 8b02 s 	
8b02 8b02 d dd7e00
8b02 8b02 s hpd1:	ld	a,(ix)		;get register name
8b05 8b05 d dd23
8b05 8b05 s 	inc	ix
8b07 8b07 d b7
8b07 8b07 s 	or	a		;Z=done
8b08 8b08 d ca1f88
8b08 8b08 s 	jp	z,loop
8b0b 8b0b s 
8b0b 8b0b d cd4f82
8b0b 8b0b s 	call	putc		;display reg name
8b0e 8b0e d cd9082
8b0e 8b0e s 	call	space		;space
8b11 8b11 d cd168b
8b11 8b11 s 	call	hpreg		;display reg
8b14 8b14 d 18ec
8b14 8b14 s 	jr	hpd1
8b16 8b16 s 
8b16 8b16 s ;;; display HP register from (HL)
8b16 8b16 s ;;; de must be WSIZE (14)
8b16 8b16 s ;;; save bc, advance HL past reg
8b16 8b16 d e5
8b16 8b16 s hpreg:	push	hl
8b17 8b17 d c5
8b17 8b17 s 	push	bc
8b18 8b18 d 060e
8b18 8b18 s 	ld	b,wsize
8b1a 8b1a d 19
8b1a 8b1a s 	add	hl,de		;point to next reg
8b1b 8b1b d 2b
8b1b 8b1b s hpr1:	dec	hl
8b1c 8b1c d 7e
8b1c 8b1c s 	ld	a,(hl)
8b1d 8b1d d cdf582
8b1d 8b1d s 	call	phex1
8b20 8b20 d 10f9
8b20 8b20 s 	djnz	hpr1
8b22 8b22 d c1
8b22 8b22 s 	pop	bc
8b23 8b23 d e1
8b23 8b23 s 	pop	hl
8b24 8b24 d 19
8b24 8b24 s 	add	hl,de
8b25 8b25 d cd9482
8b25 8b25 s 	call	crlf
8b28 8b28 d c9
8b28 8b28 s 	ret
8b29 8b29 s 
8b29 8b29 d 425245414b2000
8b29 8b29 s altban:	db	"BREAK ",0	
8b30 8b30 s 
8b30 8b30 s ;;; ---------- breakpoint entry ----------
8b30 8b30 s ;;; Save machine state and display it
8b30 8b30 s ;;; Restore code at breakpoint
8b30 8b30 s ;;; --------------------------------------
8b30 8b30 s savestate:	
8b30 8b30 s 	;; get the return address and save it
8b30 8b30 d e3
8b30 8b30 s 	ex	(sp),hl		;return address to HL
8b31 8b31 d 2b
8b31 8b31 s 	dec	hl
8b32 8b32 d 2b
8b32 8b32 s 	dec	hl
8b33 8b33 d 2b
8b33 8b33 s 	dec	hl		;back up over breakpoint call
8b34 8b34 d e3
8b34 8b34 s 	ex	(sp),hl		;put back on caller's stack
8b35 8b35 d ed731d81
8b35 8b35 s 	ld	(savsp),sp	;save caller's SP
8b39 8b39 s 	;; reset the stack to the save area
8b39 8b39 d 313381
8b39 8b39 s 	ld	sp,savetop
8b3c 8b3c s 	;; save primary regs
8b3c 8b3c d f5
8b3c 8b3c s 	push	af
8b3d 8b3d d c5
8b3d 8b3d s 	push	bc
8b3e 8b3e d d5
8b3e 8b3e s 	push	de
8b3f 8b3f d e5
8b3f 8b3f s 	push	hl
8b40 8b40 s 	;; save alternate regs
8b40 8b40 d d9
8b40 8b40 s 	exx
8b41 8b41 d 08
8b41 8b41 s 	ex	af,af'
8b42 8b42 d f5
8b42 8b42 s 	push	af
8b43 8b43 d c5
8b43 8b43 s 	push	bc
8b44 8b44 d d5
8b44 8b44 s 	push	de
8b45 8b45 d e5
8b45 8b45 s 	push	hl
8b46 8b46 s 	;; save IX, IY
8b46 8b46 d dde5
8b46 8b46 s 	push	ix
8b48 8b48 d fde5
8b48 8b48 s 	push	iy
8b4a 8b4a s 	
8b4a 8b4a s ;;; cold start with alternate banner, display struct address
8b4a 8b4a d 310081
8b4a 8b4a s 	ld	sp,stak		;restore UMON stack
8b4d 8b4d d 21298b
8b4d 8b4d s 	ld	hl,altban
8b50 8b50 d cd9d82
8b50 8b50 s 	call	puts
8b53 8b53 s 	;; display breakpoint location
8b53 8b53 d 2a1b81
8b53 8b53 s 	ld	hl,(savead)
8b56 8b56 d cd1683
8b56 8b56 s 	call	phex4
8b59 8b59 d cd9482
8b59 8b59 s 	call	crlf
8b5c 8b5c d cd628b
8b5c 8b5c s 	call	pstate		;display regs from state
8b5f 8b5f d c31f88
8b5f 8b5f s 	jp	loop
8b62 8b62 s 	
8b62 8b62 s ;;; display machine state from stored values
8b62 8b62 s pstate:
8b62 8b62 d 2a3181
8b62 8b62 s 	ld	hl,(savaf)
8b65 8b65 d 114146
8b65 8b65 s 	ld	de,'AF'
8b68 8b68 d cd148c
8b68 8b68 s 	call	pregn
8b6b 8b6b s 
8b6b 8b6b d 2a2f81
8b6b 8b6b s 	ld	hl,(savbc)
8b6e 8b6e d 114243
8b6e 8b6e s 	ld	de,'BC'
8b71 8b71 d cd148c
8b71 8b71 s 	call	pregn
8b74 8b74 s 
8b74 8b74 d 2a2d81
8b74 8b74 s 	ld	hl,(savde)
8b77 8b77 d 114445
8b77 8b77 s 	ld	de,'DE'
8b7a 8b7a d cd148c
8b7a 8b7a s 	call	pregn
8b7d 8b7d s 
8b7d 8b7d d 2a2b81
8b7d 8b7d s 	ld	hl,(savhl)
8b80 8b80 d 11484c
8b80 8b80 s 	ld	de,'HL'
8b83 8b83 d cd148c
8b83 8b83 s 	call	pregn
8b86 8b86 s 
8b86 8b86 d cd9482
8b86 8b86 s 	call	crlf
8b89 8b89 s 
8b89 8b89 s 	;; alternate regs
8b89 8b89 d 2a2981
8b89 8b89 s 	ld	hl,(savafp)
8b8c 8b8c d 114127
8b8c 8b8c s 	ld	de,'A'''
8b8f 8b8f d cd148c
8b8f 8b8f s 	call	pregn
8b92 8b92 s 
8b92 8b92 d 2a2781
8b92 8b92 s 	ld	hl,(savbcp)
8b95 8b95 d 114227
8b95 8b95 s 	ld	de,'B'''
8b98 8b98 d cd148c
8b98 8b98 s 	call	pregn
8b9b 8b9b s 
8b9b 8b9b d 2a2581
8b9b 8b9b s 	ld	hl,(savdep)
8b9e 8b9e d 114427
8b9e 8b9e s 	ld	de,'D'''
8ba1 8ba1 d cd148c
8ba1 8ba1 s 	call	pregn
8ba4 8ba4 s 
8ba4 8ba4 d 2a2381
8ba4 8ba4 s 	ld	hl,(savhlp)
8ba7 8ba7 d 114827
8ba7 8ba7 s 	ld	de,'H'''
8baa 8baa d cd148c
8baa 8baa s 	call	pregn
8bad 8bad d cd9482
8bad 8bad s 	call	crlf
8bb0 8bb0 s 
8bb0 8bb0 d 2a2181
8bb0 8bb0 s 	ld	hl,(savix)
8bb3 8bb3 d 114958
8bb3 8bb3 s 	ld	de,'IX'
8bb6 8bb6 d cd148c
8bb6 8bb6 s 	call	pregn
8bb9 8bb9 s 
8bb9 8bb9 d 2a1f81
8bb9 8bb9 s 	ld	hl,(saviy)
8bbc 8bbc d 114959
8bbc 8bbc s 	ld	de,'IY'
8bbf 8bbf d cd148c
8bbf 8bbf s 	call	pregn
8bc2 8bc2 s 
8bc2 8bc2 d 2a1d81
8bc2 8bc2 s 	ld	hl,(savsp)
8bc5 8bc5 d 115350
8bc5 8bc5 s 	ld	de,'SP'
8bc8 8bc8 d cd148c
8bc8 8bc8 s 	call	pregn
8bcb 8bcb s 	
8bcb 8bcb d cd9482
8bcb 8bcb s 	call	crlf
8bce 8bce s 	
8bce 8bce d c31f88
8bce 8bce s 	jp	loop
8bd1 8bd1 s 	
8bd1 8bd1 s ;;; copy memory
8bd1 8bd1 d cd088c
8bd1 8bd1 s memcpy:	call	load3w
8bd4 8bd4 d edb0
8bd4 8bd4 s 	ldir
8bd6 8bd6 d c31f88
8bd6 8bd6 s 	jp	loop
8bd9 8bd9 s 
8bd9 8bd9 s ;;; compare memory
8bd9 8bd9 s ;;; up to 16 errors then stop
8bd9 8bd9 d cd088c
8bd9 8bd9 s memcmp:	call	load3w
8bdc 8bdc d 1a
8bdc 8bdc s memcp1:	ld	a,(de)
8bdd 8bdd d be
8bdd 8bdd s 	cp	a,(hl)
8bde 8bde d 200a
8bde 8bde s 	jr	nz,nocmp
8be0 8be0 d 23
8be0 8be0 s memnxt:	inc	hl
8be1 8be1 d 13
8be1 8be1 s 	inc	de
8be2 8be2 d 0b
8be2 8be2 s 	dec	bc
8be3 8be3 d 78
8be3 8be3 s 	ld	a,b
8be4 8be4 d b1
8be4 8be4 s 	or	c
8be5 8be5 d 20f5
8be5 8be5 s 	jr	nz,memcp1
8be7 8be7 d c31f88
8be7 8be7 s 	jp	loop
8bea 8bea s 
8bea 8bea s 	;; display memory mismatch
8bea 8bea d cd1683
8bea 8bea s nocmp:	call	phex4		;display hl
8bed 8bed d cd9082
8bed 8bed s 	call	space
8bf0 8bf0 d 7e
8bf0 8bf0 s 	ld	a,(hl)
8bf1 8bf1 d cd0583
8bf1 8bf1 s 	call	phex2
8bf4 8bf4 d cd9082
8bf4 8bf4 s 	call	space
8bf7 8bf7 d eb
8bf7 8bf7 s 	ex	de,hl
8bf8 8bf8 d cd1683
8bf8 8bf8 s 	call	phex4		;display hl
8bfb 8bfb d cd9082
8bfb 8bfb s 	call	space
8bfe 8bfe d 7e
8bfe 8bfe s 	ld	a,(hl)
8bff 8bff d cd0583
8bff 8bff s 	call	phex2
8c02 8c02 d eb
8c02 8c02 s 	ex	de,hl
8c03 8c03 d cd9482
8c03 8c03 s 	call	crlf
8c06 8c06 d 18d8
8c06 8c06 s 	jr	memnxt
8c08 8c08 s 	
8c08 8c08 s ;;; load hl, de, bc from 3 arguments for compare/copy
8c08 8c08 d 2ac881
8c08 8c08 s load3w:	ld	hl,(iargv+2)	;source
8c0b 8c0b d ed5bca81
8c0b 8c0b s 	ld	de,(iargv+4)	;dest
8c0f 8c0f d ed4bcc81
8c0f 8c0f s 	ld	bc,(iargv+6)	;count
8c13 8c13 d c9
8c13 8c13 s 	ret
8c14 8c14 s 
8c14 8c14 s ;;; display reg name from de, value from hl
8c14 8c14 s pregn:	
8c14 8c14 d cd9082
8c14 8c14 s 	call	space
8c17 8c17 d 7b
8c17 8c17 s 	ld	a,e
8c18 8c18 d cd4f82
8c18 8c18 s 	call	putc
8c1b 8c1b d 7a
8c1b 8c1b s 	ld	a,d
8c1c 8c1c d cd4f82
8c1c 8c1c s 	call	putc
8c1f 8c1f d 3e3a
8c1f 8c1f s 	ld	a,':'
8c21 8c21 d cd4f82
8c21 8c21 s 	call	putc
8c24 8c24 d cd1683
8c24 8c24 s 	call	phex4
8c27 8c27 d cd9082
8c27 8c27 s 	call	space
8c2a 8c2a d c9
8c2a 8c2a s 	ret
8c2b 8c2b s 
8c2b 8c2b s 	
8c2b 8c2b s umontop:	equ	$
8c2b 8c2b s 	
8c2b 8c2b s 	.end
8229 a ci0
822f a ci1
8238 a ci3
824b a ci5
8242 a ci6
8407 a do71
841e a do72
8426 a do73
83c7 a col
826d a one
83bd a row
8a09 a bin1
8a4a a bin2
8b02 a hpd1
8b1b a hpr1
817d v bend
0009 v half
817d a argc
8225 a getc
8141 a buff
8804 a main
8402 a do7218
8294 a crlf
8a77 a edit
88f1 a help
8aaf a bite
83a5 a skan
845d a dpyb
817e a argv
8472 a nodp
8100 v stak
0016 v full
82a6 a gets
847a a nomi
8a97 a dump
8a6e a goto
881f a loop
8357 a vhex
824f a putc
8375 a plop
0080 v inpt
88e4 a zero
88af a errz
88bb a quit
8263 a rrot
8a18 a bin1a
829d a puts
8333 a ghex1
8338 a ghex2
8323 a ihex1
834d a ghex4
82b1 a gets0
82ea a gets1
82dc a gets2
82cb a gets3
8305 a phex2
82f5 a phex1
8316 a phex4
835a a vhex1
83dc a s7tbl
0001 v vfd_d
8abd a haddr
8433 a getch
8290 a space
812f a savbc
8131 a savaf
812d a savde
89a0 a brkat
84c3 a usage
821c a dally
8140 a lastc
8271 a biter
81c6 a iargv
8ace a arith
8ab7 a noadr
89c3 a nobrk
8b16 a hpreg
812b a savhl
8210 a dilly
8a89 a eloop
8395 a dotok
83d6 a nohit
883a a not_r
8368 a cvint
842f a putch
895a a brkpt
8944 a nonew
89d3 a msgno
8aa4 a hdump
84bd a error
8121 a savix
811f a saviy
811d a savsp
0084 v minus
8c14 a pregn
813f a pzero
8906 a input
000e v wsize
8bea a nocmp
834b a ghex2a
8bdc a memcp1
8300 a phex1a
8c08 a load3w
8aa9 a hdump2
843a a vs7tbl
0008 v vfd_bl
0040 v left_d
83b3 a kbscan
8b29 a altban
811b a savead
84ae a banner
0041 v left_m
8133 a regnam
8497 a vfd_sh
8127 a savbcp
0012 v maxarg
8129 a savafp
8bd9 a memcmp
8125 a savdep
838e a pardon
8a07 a binary
8118 a savein
8961 a brkclr
820e a bitdly
89dd a msgclr
8aef a hpregs
8bd1 a memcpy
8987 a brkset
00b0 v dpymod
8123 a savhlp
8af8 a hpdump
88be a kbtest
8b62 a pstate
89cc a msgset
88ca a dptest
89ba a brkovr
8be0 a memnxt
8416 a nminus
89e8 a msgovr
0020 v vminus
8393 a strtok
88fa a output
0004 v vfd_clk
00c0 v right_d
821a a halfdly
0002 v vfd_stb
00c1 v right_m
0040 v vfd_prt
83ec a display
8915 a continu
88d3 a vfdtest
8133 v savetop
0020 v vfd_led1
0010 v vfd_led2
8287 a toupper
8c2b v umontop
0080 v data_bit
844a a vfd_init
0000 v led_port
8282 a updpzero
88ed a setpzero
0004 v vfd_extra
8b30 a savestate
000c v vfd_digits
8494 a vfd_shifty
844f a vfd_display
0080 v serial_port
